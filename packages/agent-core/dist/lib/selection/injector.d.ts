/**
 * Script injected into preview iframe for element selection
 * This runs in the iframe's context and communicates with parent via postMessage
 */
export declare const SELECTION_SCRIPT = "\n(function() {\n  console.log('\uD83C\uDFAF SentryVibe selection script loaded (dormant)');\n  console.log('   window.parent exists:', !!window.parent);\n  console.log('   window.parent.postMessage exists:', typeof window.parent.postMessage);\n\n  // Selection state - DORMANT by default\n  let isInspectorActive = false;\n  let inspectorStyle = null;\n  let highlightedElement = null;\n  let highlightOverlay = null;\n  let mouseHandler = null;\n  let clickHandler = null;\n\n  function getProxyPrefix() {\n    try {\n      var parts = window.location.pathname.split('/').filter(Boolean);\n      var projectsIndex = parts.indexOf('projects');\n      if (projectsIndex === -1) {\n        return null;\n      }\n\n      var projectId = parts[projectsIndex + 1];\n      if (!projectId) {\n        return null;\n      }\n\n      return '/api/projects/' + projectId + '/proxy?path=';\n    } catch (error) {\n      console.warn('\u26A0\uFE0F [SentryVibe CSS] Unable to derive proxy prefix:', error);\n      return null;\n    }\n  }\n\n  var proxyPrefix = getProxyPrefix();\n\n  function rewriteStylesheetHref(link) {\n    if (!proxyPrefix || !link) {\n      return false;\n    }\n\n    var href = link.getAttribute('href');\n    if (!href) {\n      return false;\n    }\n\n    var trimmed = href.trim();\n\n    if (\n      trimmed.indexOf('proxy?path=') !== -1 ||\n      trimmed.indexOf('http://') === 0 ||\n      trimmed.indexOf('https://') === 0 ||\n      trimmed.indexOf('//') === 0 ||\n      trimmed.indexOf('data:') === 0\n    ) {\n      return false;\n    }\n\n    if (trimmed.charAt(0) === '/') {\n      var proxiedHref = proxyPrefix + encodeURIComponent(trimmed);\n      if (link.getAttribute('href') !== proxiedHref) {\n        link.setAttribute('href', proxiedHref);\n        console.log('\uD83C\uDFA8 [SentryVibe CSS] rewrote stylesheet href to proxy:', proxiedHref);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // Debug helper: track when stylesheets are added/loaded inside the iframe\n  function monitorStylesheets() {\n    const loggedLinks = new WeakSet();\n    const loggedStyles = new WeakSet();\n\n    const logLink = (link, phase) => {\n      if (!link) return;\n      const href = link.getAttribute('href') || '(no href)';\n      console.log('\uD83C\uDFA8 [SentryVibe CSS]', phase + ' stylesheet:', href);\n    };\n\n    const logStyle = (style, phase) => {\n      if (!style) return;\n      const sample = (style.textContent || '')\n        .replace(/s+/g, ' ')\n        .trim()\n        .slice(0, 140);\n      console.log('\uD83C\uDFA8 [SentryVibe CSS]', phase + ' inline style', sample);\n    };\n\n    const attachLinkListeners = (link, phase) => {\n      if (!link || loggedLinks.has(link)) return;\n      loggedLinks.add(link);\n      const rewritten = rewriteStylesheetHref(link);\n      const phaseLabel = rewritten ? phase + ' (rewritten)' : phase;\n      logLink(link, phaseLabel);\n\n      link.addEventListener(\n        'load',\n        () => {\n          rewriteStylesheetHref(link);\n          logLink(link, 'loaded');\n        },\n        { once: true }\n      );\n\n      link.addEventListener(\n        'error',\n        () => {\n          rewriteStylesheetHref(link);\n          logLink(link, 'error loading');\n        },\n        { once: true }\n      );\n    };\n\n    const recordStyleElement = (style, phase) => {\n      if (!style || loggedStyles.has(style)) return;\n      loggedStyles.add(style);\n      logStyle(style, phase);\n    };\n\n    // Observe new link/style nodes appended to the document\n    const observer = new MutationObserver((mutations) => {\n      mutations.forEach((mutation) => {\n        mutation.addedNodes.forEach((node) => {\n          if (!(node instanceof HTMLElement)) return;\n\n          if (node.tagName === 'LINK' && (node.getAttribute('rel') || '').includes('stylesheet')) {\n            attachLinkListeners(node, 'added');\n          }\n\n          if (node.tagName === 'STYLE') {\n            recordStyleElement(node, 'added');\n          }\n        });\n      });\n    });\n\n    try {\n      const head = document.head || document.documentElement;\n      if (head) {\n        observer.observe(head, { childList: true, subtree: true });\n      }\n    } catch (e) {\n      console.warn('\u26A0\uFE0F [SentryVibe CSS] Failed to observe stylesheet mutations:', e);\n    }\n\n    // Log existing stylesheet/link elements when script runs\n    document\n      .querySelectorAll('link[rel~=\"stylesheet\"], style')\n      .forEach((node) => {\n        if (node.tagName === 'LINK') {\n          attachLinkListeners(node, 'existing');\n        } else if (node.tagName === 'STYLE') {\n          recordStyleElement(node, 'existing');\n        }\n      });\n\n    // Capture late load events (when link is in DOM before listener added)\n    document.addEventListener(\n      'load',\n      (event) => {\n        const target = event.target;\n        if (\n          target instanceof HTMLLinkElement &&\n          (target.getAttribute('rel') || '').includes('stylesheet')\n        ) {\n          attachLinkListeners(target, 'load event');\n        }\n      },\n      true\n    );\n  }\n\n  monitorStylesheets();\n\n  // Create highlight overlay\n  function createHighlightOverlay() {\n    if (highlightOverlay) return highlightOverlay;\n\n    const overlay = document.createElement('div');\n    overlay.id = '__sentryvibe-highlight';\n    overlay.style.cssText = `\n      position: absolute;\n      pointer-events: none;\n      border: 2px solid #7553FF;\n      background: rgba(117, 83, 255, 0.1);\n      z-index: 999999;\n      transition: all 0.1s ease;\n      box-shadow: 0 0 0 1px rgba(117, 83, 255, 0.3), 0 0 20px rgba(117, 83, 255, 0.4);\n    `;\n    document.body.appendChild(overlay);\n    highlightOverlay = overlay;\n    return overlay;\n  }\n\n  // Remove highlight overlay\n  function removeHighlightOverlay() {\n    if (highlightOverlay) {\n      highlightOverlay.remove();\n      highlightOverlay = null;\n    }\n  }\n\n  // Highlight element on hover\n  function highlightElement(element) {\n    if (!element || !isInspectorActive) {\n      removeHighlightOverlay();\n      return;\n    }\n\n    const rect = element.getBoundingClientRect();\n    const overlay = createHighlightOverlay();\n\n    overlay.style.left = rect.left + window.scrollX + 'px';\n    overlay.style.top = rect.top + window.scrollY + 'px';\n    overlay.style.width = rect.width + 'px';\n    overlay.style.height = rect.height + 'px';\n\n    highlightedElement = element;\n  }\n\n  // Generate unique CSS selector for element\n  function generateSelector(element) {\n    // Strategy 1: data-testid (best)\n    const testId = element.getAttribute('data-testid');\n    if (testId) {\n      return `[data-testid=\"${testId}\"]`;\n    }\n\n    // Strategy 2: ID (good)\n    if (element.id) {\n      return `#${element.id}`;\n    }\n\n    // Strategy 3: Class + tag (ok) - but skip classes with colons (Tailwind responsive)\n    const classes = Array.from(element.classList)\n      .filter(c => !c.match(/^(hover:|focus:|active:|group-|animate-|transition-)/))\n      .filter(c => !c.includes(':')) // Skip Tailwind responsive classes\n      .slice(0, 3) // Limit to first 3 classes\n      .join('.');\n\n    if (classes) {\n      const tagName = element.tagName.toLowerCase();\n\n      try {\n        // Check if unique enough\n        const selector = `${tagName}.${classes}`;\n        const matches = document.querySelectorAll(selector);\n\n        if (matches.length === 1) {\n          return selector;\n        }\n\n        // Add nth-child if multiple matches\n        const parent = element.parentElement;\n        if (parent) {\n          const siblings = Array.from(parent.children);\n          const index = siblings.indexOf(element) + 1;\n          return `${selector}:nth-child(${index})`;\n        }\n\n        return selector;\n      } catch (err) {\n        console.warn('Invalid selector, falling back to path:', err);\n      }\n    }\n\n    // Strategy 4: Full path (fallback)\n    return getFullPath(element);\n  }\n\n  // Get full CSS path to element\n  function getFullPath(element) {\n    const path = [];\n    let current = element;\n\n    while (current && current !== document.body) {\n      let selector = current.tagName.toLowerCase();\n\n      if (current.id) {\n        selector += `#${current.id}`;\n        path.unshift(selector);\n        break;\n      }\n\n      const parent = current.parentElement;\n      if (parent) {\n        const siblings = Array.from(parent.children).filter(\n          child => child.tagName === current.tagName\n        );\n\n        if (siblings.length > 1) {\n          const index = siblings.indexOf(current) + 1;\n          selector += `:nth-of-type(${index})`;\n        }\n      }\n\n      path.unshift(selector);\n      current = current.parentElement;\n    }\n\n    return path.join(' > ');\n  }\n\n  // Capture element data and click position\n  function captureElementData(element, clickEvent) {\n    const rect = element.getBoundingClientRect();\n\n    return {\n      selector: generateSelector(element),\n      tagName: element.tagName.toLowerCase(),\n      className: element.className,\n      id: element.id,\n      textContent: element.textContent?.trim().slice(0, 100),\n      innerHTML: element.innerHTML?.slice(0, 200),\n      attributes: Array.from(element.attributes).reduce((acc, attr) => {\n        acc[attr.name] = attr.value;\n        return acc;\n      }, {}),\n      boundingRect: {\n        top: rect.top,\n        left: rect.left,\n        width: rect.width,\n        height: rect.height,\n      },\n      clickPosition: {\n        x: clickEvent.clientX,\n        y: clickEvent.clientY,\n      },\n      computedStyles: {\n        backgroundColor: window.getComputedStyle(element).backgroundColor,\n        color: window.getComputedStyle(element).color,\n        fontSize: window.getComputedStyle(element).fontSize,\n        fontFamily: window.getComputedStyle(element).fontFamily,\n      }\n    };\n  }\n\n  // Mouse move handler (hover preview)\n  function handleMouseMove(e) {\n    if (!isInspectorActive) return;\n\n    const element = e.target;\n    if (element && element !== highlightedElement) {\n      highlightElement(element);\n    }\n  }\n\n  // Click handler (select element)\n  function handleClick(e) {\n    console.log('\uD83D\uDDB1\uFE0F Click detected, selection mode:', isInspectorActive);\n\n    if (!isInspectorActive) return;\n\n    e.preventDefault();\n    e.stopPropagation();\n\n    const element = e.target;\n    const data = captureElementData(element, e);\n\n    console.log('\uD83C\uDFAF Element captured:', data);\n    console.log('   Click position:', data.clickPosition);\n    console.log('\uD83D\uDCE4 Sending postMessage to parent...');\n\n    // Send to parent window\n    window.parent.postMessage({\n      type: 'sentryvibe:element-selected',\n      data,\n    }, '*');\n\n    console.log('\u2705 Message sent to parent');\n\n    // Disable selection mode after selection\n    setInspectorActive(false);\n  }\n\n  // Activate/deactivate inspector (DORMANT PATTERN)\n  function setInspectorActive(active) {\n    isInspectorActive = active;\n\n    if (active) {\n      // Add inspector styles ONLY when activated\n      if (!inspectorStyle) {\n        inspectorStyle = document.createElement('style');\n        inspectorStyle.textContent = `\n          .inspector-active * {\n            cursor: crosshair !important;\n          }\n          .inspector-highlight {\n            outline: 2px solid #7553FF !important;\n            outline-offset: -2px !important;\n            background-color: rgba(117, 83, 255, 0.1) !important;\n          }\n        `;\n        document.head.appendChild(inspectorStyle);\n      }\n\n      document.body.classList.add('inspector-active');\n\n      // Add event listeners ONLY when activated\n      if (!mouseHandler) {\n        mouseHandler = handleMouseMove;\n        clickHandler = handleClick;\n        document.addEventListener('mousemove', mouseHandler, true);\n        document.addEventListener('click', clickHandler, true);\n        console.log('\u2705 Inspector event listeners attached');\n      }\n    } else {\n      document.body.classList.remove('inspector-active');\n\n      // Remove highlight\n      if (highlightedElement) {\n        highlightedElement = null;\n      }\n      removeHighlightOverlay();\n\n      // Remove event listeners when deactivated\n      if (mouseHandler) {\n        document.removeEventListener('mousemove', mouseHandler, true);\n        document.removeEventListener('click', clickHandler, true);\n        mouseHandler = null;\n        clickHandler = null;\n        console.log('\uD83E\uDDF9 Inspector event listeners removed');\n      }\n\n      // Remove styles\n      if (inspectorStyle) {\n        inspectorStyle.remove();\n        inspectorStyle = null;\n      }\n    }\n\n    console.log('\uD83C\uDFAF Selection mode:', isInspectorActive ? 'ENABLED' : 'DISABLED');\n  }\n\n  // Listen for activation/deactivation from parent\n  window.addEventListener('message', (e) => {\n    if (e.data.type === 'sentryvibe:toggle-selection-mode') {\n      setInspectorActive(e.data.enabled);\n    }\n  });\n\n  // NO event listeners added here - script is DORMANT until activated\n  console.log('\u2705 Selection script ready (dormant, waiting for activation)');\n\n  // Announce ready to parent\n  window.parent.postMessage({ type: 'sentryvibe:ready' }, '*');\n})();\n";
/**
 * Inject selection script into iframe
 */
export declare function injectSelectionScript(iframe: HTMLIFrameElement): boolean;
/**
 * Toggle selection mode in iframe
 */
export declare function toggleSelectionMode(iframe: HTMLIFrameElement, enabled: boolean): void;
