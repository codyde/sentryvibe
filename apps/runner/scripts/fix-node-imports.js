#!/usr/bin/env node
/**
 * Post-build script to fix Node.js built-in imports
 * 
 * ESM requires the node: protocol prefix for built-in modules to avoid
 * "Dynamic require of X is not supported" errors.
 * 
 * Additionally, the __require shim generated by esbuild doesn't work in ESM
 * because `require` is not defined. We need to replace the shim with one that
 * uses `createRequire` from the `module` package.
 */

import { readdir, readFile, writeFile } from 'node:fs/promises';
import { join } from 'node:path';

const DIST_DIR = new URL('../dist', import.meta.url).pathname;

// The broken __require shim that esbuild generates
const BROKEN_REQUIRE_SHIM = `var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});`;

// Fixed shim that works in ESM by using createRequire
const FIXED_REQUIRE_SHIM = `import { createRequire as __createRequire } from 'node:module';
var __require = __createRequire(import.meta.url);`;

// Node.js built-in modules that need the node: prefix
const BUILTINS = [
  'assert', 'buffer', 'child_process', 'cluster', 'console', 'constants',
  'crypto', 'dgram', 'dns', 'domain', 'events', 'fs', 'fs/promises',
  'http', 'http2', 'https', 'inspector', 'module', 'net', 'os', 'path',
  'perf_hooks', 'process', 'punycode', 'querystring', 'readline', 'repl',
  'stream', 'string_decoder', 'sys', 'timers', 'tls', 'trace_events',
  'tty', 'url', 'util', 'v8', 'vm', 'wasi', 'worker_threads', 'zlib'
];

// Create regex patterns for different import styles
function createPatterns() {
  const patterns = [];
  
  for (const builtin of BUILTINS) {
    // Escape special regex characters in module name
    const escaped = builtin.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    
    // Static imports: import { x } from 'fs/promises' -> import { x } from 'node:fs/promises'
    patterns.push({
      regex: new RegExp(`(from\\s+['"])${escaped}(['"])`, 'g'),
      replacement: `$1node:${builtin}$2`,
      type: 'add-prefix'
    });
    
    // Dynamic imports: await import('fs/promises') -> await import('node:fs/promises')
    patterns.push({
      regex: new RegExp(`(import\\s*\\(\\s*['"])${escaped}(['"]\\s*\\))`, 'g'),
      replacement: `$1node:${builtin}$2`,
      type: 'add-prefix'
    });
    
    // __require calls with node: prefix need it REMOVED: __require("node:fs/promises") -> __require("fs/promises")
    // The __require shim doesn't support node: protocol
    patterns.push({
      regex: new RegExp(`(__require\\s*\\(\\s*['"])node:${escaped}(['"]\\s*\\))`, 'g'),
      replacement: `$1${builtin}$2`,
      type: 'remove-prefix'
    });
    
    // Also handle bare require with node: prefix
    patterns.push({
      regex: new RegExp(`(require\\s*\\(\\s*['"])node:${escaped}(['"]\\s*\\))`, 'g'),
      replacement: `$1${builtin}$2`,
      type: 'remove-prefix'
    });
  }
  
  return patterns;
}

async function processFile(filePath, patterns) {
  const content = await readFile(filePath, 'utf-8');
  let modified = content;
  let changeCount = 0;
  
  // First, fix the broken __require shim if present
  if (modified.includes('throw Error(\'Dynamic require of "\'')) {
    modified = modified.replace(BROKEN_REQUIRE_SHIM, FIXED_REQUIRE_SHIM);
    if (modified !== content) {
      changeCount++;
      console.log(`  Fixed __require shim in ${filePath.split('/').pop()}`);
    }
  }
  
  // Then apply import patterns
  for (const { regex, replacement } of patterns) {
    const before = modified;
    modified = modified.replace(regex, replacement);
    if (modified !== before) {
      // Count actual replacements
      const matches = before.match(regex);
      changeCount += matches ? matches.length : 0;
    }
  }
  
  if (modified !== content) {
    await writeFile(filePath, modified, 'utf-8');
    console.log(`  Fixed ${changeCount} items in ${filePath.split('/').pop()}`);
  }
  
  return changeCount;
}

async function getAllJsFiles(dir) {
  const files = [];
  const entries = await readdir(dir, { withFileTypes: true });
  
  for (const entry of entries) {
    const fullPath = join(dir, entry.name);
    if (entry.isDirectory()) {
      files.push(...await getAllJsFiles(fullPath));
    } else if (entry.name.endsWith('.js')) {
      files.push(fullPath);
    }
  }
  
  return files;
}

async function main() {
  console.log('Fixing Node.js built-in imports in dist/...');
  
  const patterns = createPatterns();
  const files = await getAllJsFiles(DIST_DIR);
  
  let totalChanges = 0;
  for (const file of files) {
    totalChanges += await processFile(file, patterns);
  }
  
  console.log(`Done! Fixed ${totalChanges} imports across ${files.length} files.`);
}

main().catch(err => {
  console.error('Error fixing imports:', err);
  process.exit(1);
});
