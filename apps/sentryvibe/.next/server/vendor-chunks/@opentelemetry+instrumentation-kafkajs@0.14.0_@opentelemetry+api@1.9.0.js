"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0";
exports.ids = ["vendor-chunks/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0"];
exports.modules = {

/***/ "(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/index.js":
/*!******************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/index.js ***!
  \******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors, Aspecto\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.KafkaJsInstrumentation = void 0;\nvar instrumentation_1 = __webpack_require__(/*! ./instrumentation */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/instrumentation.js\");\nObject.defineProperty(exports, \"KafkaJsInstrumentation\", ({ enumerable: true, get: function () { return instrumentation_1.KafkaJsInstrumentation; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24ta2Fma2Fqc0AwLjE0LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24ta2Fma2Fqcy9idWlsZC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsOEJBQThCO0FBQzlCLHdCQUF3QixtQkFBTyxDQUFDLHdOQUFtQjtBQUNuRCwwREFBeUQsRUFBRSxxQ0FBcUMsb0RBQW9ELEVBQUM7QUFDckoiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jb2R5ZGVhcmtsYW5kL3NlbnRyeXZpYmUvbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTQuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9ycywgQXNwZWN0b1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkthZmthSnNJbnN0cnVtZW50YXRpb24gPSB2b2lkIDA7XG52YXIgaW5zdHJ1bWVudGF0aW9uXzEgPSByZXF1aXJlKFwiLi9pbnN0cnVtZW50YXRpb25cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJLYWZrYUpzSW5zdHJ1bWVudGF0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnN0cnVtZW50YXRpb25fMS5LYWZrYUpzSW5zdHJ1bWVudGF0aW9uOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/index.js\n");

/***/ }),

/***/ "(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/instrumentation.js":
/*!****************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/instrumentation.js ***!
  \****************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval(";globalThis[\"_sentryRewritesTunnelPath\"] = undefined;globalThis[\"SENTRY_RELEASE\"] = undefined;globalThis[\"_sentryBasePath\"] = undefined;globalThis[\"_sentryNextJsVersion\"] = \"15.5.4\";globalThis[\"_sentryRewriteFramesDistDir\"] = \".next\";\n/*\n * Copyright The OpenTelemetry Authors, Aspecto\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.KafkaJsInstrumentation = void 0;\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst instrumentation_1 = __webpack_require__(/*! @opentelemetry/instrumentation */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation@0.204.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation/build/esm/index.js\");\nconst semantic_conventions_1 = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.37.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nconst internal_types_1 = __webpack_require__(/*! ./internal-types */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/internal-types.js\");\nconst propagator_1 = __webpack_require__(/*! ./propagator */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/propagator.js\");\nconst semconv_1 = __webpack_require__(/*! ./semconv */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/semconv.js\");\n/** @knipignore */\nconst version_1 = __webpack_require__(/*! ./version */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/version.js\");\nfunction prepareCounter(meter, value, attributes) {\n    return (errorType) => {\n        meter.add(value, {\n            ...attributes,\n            ...(errorType ? { [semantic_conventions_1.ATTR_ERROR_TYPE]: errorType } : {}),\n        });\n    };\n}\nfunction prepareDurationHistogram(meter, value, attributes) {\n    return (errorType) => {\n        meter.record((Date.now() - value) / 1000, {\n            ...attributes,\n            ...(errorType ? { [semantic_conventions_1.ATTR_ERROR_TYPE]: errorType } : {}),\n        });\n    };\n}\nconst HISTOGRAM_BUCKET_BOUNDARIES = [\n    0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 2.5, 5, 7.5, 10,\n];\nclass KafkaJsInstrumentation extends instrumentation_1.InstrumentationBase {\n    constructor(config = {}) {\n        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);\n    }\n    _updateMetricInstruments() {\n        this._clientDuration = this.meter.createHistogram(semconv_1.METRIC_MESSAGING_CLIENT_OPERATION_DURATION, { advice: { explicitBucketBoundaries: HISTOGRAM_BUCKET_BOUNDARIES } });\n        this._sentMessages = this.meter.createCounter(semconv_1.METRIC_MESSAGING_CLIENT_SENT_MESSAGES);\n        this._consumedMessages = this.meter.createCounter(semconv_1.METRIC_MESSAGING_CLIENT_CONSUMED_MESSAGES);\n        this._processDuration = this.meter.createHistogram(semconv_1.METRIC_MESSAGING_PROCESS_DURATION, { advice: { explicitBucketBoundaries: HISTOGRAM_BUCKET_BOUNDARIES } });\n    }\n    init() {\n        const unpatch = (moduleExports) => {\n            if ((0, instrumentation_1.isWrapped)(moduleExports?.Kafka?.prototype.producer)) {\n                this._unwrap(moduleExports.Kafka.prototype, 'producer');\n            }\n            if ((0, instrumentation_1.isWrapped)(moduleExports?.Kafka?.prototype.consumer)) {\n                this._unwrap(moduleExports.Kafka.prototype, 'consumer');\n            }\n        };\n        const module = new instrumentation_1.InstrumentationNodeModuleDefinition('kafkajs', ['>=0.3.0 <3'], (moduleExports) => {\n            unpatch(moduleExports);\n            this._wrap(moduleExports?.Kafka?.prototype, 'producer', this._getProducerPatch());\n            this._wrap(moduleExports?.Kafka?.prototype, 'consumer', this._getConsumerPatch());\n            return moduleExports;\n        }, unpatch);\n        return module;\n    }\n    _getConsumerPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function consumer(...args) {\n                const newConsumer = original.apply(this, args);\n                if ((0, instrumentation_1.isWrapped)(newConsumer.run)) {\n                    instrumentation._unwrap(newConsumer, 'run');\n                }\n                instrumentation._wrap(newConsumer, 'run', instrumentation._getConsumerRunPatch());\n                instrumentation._setKafkaEventListeners(newConsumer);\n                return newConsumer;\n            };\n        };\n    }\n    _setKafkaEventListeners(kafkaObj) {\n        if (kafkaObj[internal_types_1.EVENT_LISTENERS_SET])\n            return;\n        // The REQUEST Consumer event was added in kafkajs@1.5.0.\n        if (kafkaObj.events?.REQUEST) {\n            kafkaObj.on(kafkaObj.events.REQUEST, this._recordClientDurationMetric.bind(this));\n        }\n        kafkaObj[internal_types_1.EVENT_LISTENERS_SET] = true;\n    }\n    _recordClientDurationMetric(event) {\n        const [address, port] = event.payload.broker.split(':');\n        this._clientDuration.record(event.payload.duration / 1000, {\n            [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n            [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: `${event.payload.apiName}`,\n            [semantic_conventions_1.ATTR_SERVER_ADDRESS]: address,\n            [semantic_conventions_1.ATTR_SERVER_PORT]: Number.parseInt(port, 10),\n        });\n    }\n    _getProducerPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function consumer(...args) {\n                const newProducer = original.apply(this, args);\n                if ((0, instrumentation_1.isWrapped)(newProducer.sendBatch)) {\n                    instrumentation._unwrap(newProducer, 'sendBatch');\n                }\n                instrumentation._wrap(newProducer, 'sendBatch', instrumentation._getSendBatchPatch());\n                if ((0, instrumentation_1.isWrapped)(newProducer.send)) {\n                    instrumentation._unwrap(newProducer, 'send');\n                }\n                instrumentation._wrap(newProducer, 'send', instrumentation._getSendPatch());\n                if ((0, instrumentation_1.isWrapped)(newProducer.transaction)) {\n                    instrumentation._unwrap(newProducer, 'transaction');\n                }\n                instrumentation._wrap(newProducer, 'transaction', instrumentation._getProducerTransactionPatch());\n                instrumentation._setKafkaEventListeners(newProducer);\n                return newProducer;\n            };\n        };\n    }\n    _getConsumerRunPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function run(...args) {\n                const config = args[0];\n                if (config?.eachMessage) {\n                    if ((0, instrumentation_1.isWrapped)(config.eachMessage)) {\n                        instrumentation._unwrap(config, 'eachMessage');\n                    }\n                    instrumentation._wrap(config, 'eachMessage', instrumentation._getConsumerEachMessagePatch());\n                }\n                if (config?.eachBatch) {\n                    if ((0, instrumentation_1.isWrapped)(config.eachBatch)) {\n                        instrumentation._unwrap(config, 'eachBatch');\n                    }\n                    instrumentation._wrap(config, 'eachBatch', instrumentation._getConsumerEachBatchPatch());\n                }\n                return original.call(this, config);\n            };\n        };\n    }\n    _getConsumerEachMessagePatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function eachMessage(...args) {\n                const payload = args[0];\n                const propagatedContext = api_1.propagation.extract(api_1.ROOT_CONTEXT, payload.message.headers, propagator_1.bufferTextMapGetter);\n                const span = instrumentation._startConsumerSpan({\n                    topic: payload.topic,\n                    message: payload.message,\n                    operationType: semconv_1.MESSAGING_OPERATION_TYPE_VALUE_PROCESS,\n                    ctx: propagatedContext,\n                    attributes: {\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.partition),\n                    },\n                });\n                const pendingMetrics = [\n                    prepareDurationHistogram(instrumentation._processDuration, Date.now(), {\n                        [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                        [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'process',\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: payload.topic,\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.partition),\n                    }),\n                    prepareCounter(instrumentation._consumedMessages, 1, {\n                        [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                        [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'process',\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: payload.topic,\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.partition),\n                    }),\n                ];\n                const eachMessagePromise = api_1.context.with(api_1.trace.setSpan(propagatedContext, span), () => {\n                    return original.apply(this, args);\n                });\n                return instrumentation._endSpansOnPromise([span], pendingMetrics, eachMessagePromise);\n            };\n        };\n    }\n    _getConsumerEachBatchPatch() {\n        return (original) => {\n            const instrumentation = this;\n            return function eachBatch(...args) {\n                const payload = args[0];\n                // https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/messaging.md#topic-with-multiple-consumers\n                const receivingSpan = instrumentation._startConsumerSpan({\n                    topic: payload.batch.topic,\n                    message: undefined,\n                    operationType: semconv_1.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE,\n                    ctx: api_1.ROOT_CONTEXT,\n                    attributes: {\n                        [semconv_1.ATTR_MESSAGING_BATCH_MESSAGE_COUNT]: payload.batch.messages.length,\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.batch.partition),\n                    },\n                });\n                return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), receivingSpan), () => {\n                    const startTime = Date.now();\n                    const spans = [];\n                    const pendingMetrics = [\n                        prepareCounter(instrumentation._consumedMessages, payload.batch.messages.length, {\n                            [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                            [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'process',\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: payload.batch.topic,\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.batch.partition),\n                        }),\n                    ];\n                    payload.batch.messages.forEach(message => {\n                        const propagatedContext = api_1.propagation.extract(api_1.ROOT_CONTEXT, message.headers, propagator_1.bufferTextMapGetter);\n                        const spanContext = api_1.trace\n                            .getSpan(propagatedContext)\n                            ?.spanContext();\n                        let origSpanLink;\n                        if (spanContext) {\n                            origSpanLink = {\n                                context: spanContext,\n                            };\n                        }\n                        spans.push(instrumentation._startConsumerSpan({\n                            topic: payload.batch.topic,\n                            message,\n                            operationType: semconv_1.MESSAGING_OPERATION_TYPE_VALUE_PROCESS,\n                            link: origSpanLink,\n                            attributes: {\n                                [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.batch.partition),\n                            },\n                        }));\n                        pendingMetrics.push(prepareDurationHistogram(instrumentation._processDuration, startTime, {\n                            [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                            [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'process',\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: payload.batch.topic,\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.batch.partition),\n                        }));\n                    });\n                    const batchMessagePromise = original.apply(this, args);\n                    spans.unshift(receivingSpan);\n                    return instrumentation._endSpansOnPromise(spans, pendingMetrics, batchMessagePromise);\n                });\n            };\n        };\n    }\n    _getProducerTransactionPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function transaction(...args) {\n                const transactionSpan = instrumentation.tracer.startSpan('transaction');\n                const transactionPromise = original.apply(this, args);\n                transactionPromise\n                    .then((transaction) => {\n                    const originalSend = transaction.send;\n                    transaction.send = function send(...args) {\n                        return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), transactionSpan), () => {\n                            const patched = instrumentation._getSendPatch()(originalSend);\n                            return patched.apply(this, args).catch(err => {\n                                transactionSpan.setStatus({\n                                    code: api_1.SpanStatusCode.ERROR,\n                                    message: err?.message,\n                                });\n                                transactionSpan.recordException(err);\n                                throw err;\n                            });\n                        });\n                    };\n                    const originalSendBatch = transaction.sendBatch;\n                    transaction.sendBatch = function sendBatch(...args) {\n                        return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), transactionSpan), () => {\n                            const patched = instrumentation._getSendBatchPatch()(originalSendBatch);\n                            return patched.apply(this, args).catch(err => {\n                                transactionSpan.setStatus({\n                                    code: api_1.SpanStatusCode.ERROR,\n                                    message: err?.message,\n                                });\n                                transactionSpan.recordException(err);\n                                throw err;\n                            });\n                        });\n                    };\n                    const originalCommit = transaction.commit;\n                    transaction.commit = function commit(...args) {\n                        const originCommitPromise = originalCommit\n                            .apply(this, args)\n                            .then(() => {\n                            transactionSpan.setStatus({ code: api_1.SpanStatusCode.OK });\n                        });\n                        return instrumentation._endSpansOnPromise([transactionSpan], [], originCommitPromise);\n                    };\n                    const originalAbort = transaction.abort;\n                    transaction.abort = function abort(...args) {\n                        const originAbortPromise = originalAbort.apply(this, args);\n                        return instrumentation._endSpansOnPromise([transactionSpan], [], originAbortPromise);\n                    };\n                })\n                    .catch(err => {\n                    transactionSpan.setStatus({\n                        code: api_1.SpanStatusCode.ERROR,\n                        message: err?.message,\n                    });\n                    transactionSpan.recordException(err);\n                    transactionSpan.end();\n                });\n                return transactionPromise;\n            };\n        };\n    }\n    _getSendBatchPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function sendBatch(...args) {\n                const batch = args[0];\n                const messages = batch.topicMessages || [];\n                const spans = [];\n                const pendingMetrics = [];\n                messages.forEach(topicMessage => {\n                    topicMessage.messages.forEach(message => {\n                        spans.push(instrumentation._startProducerSpan(topicMessage.topic, message));\n                        pendingMetrics.push(prepareCounter(instrumentation._sentMessages, 1, {\n                            [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                            [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'send',\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: topicMessage.topic,\n                            ...(message.partition !== undefined\n                                ? {\n                                    [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(message.partition),\n                                }\n                                : {}),\n                        }));\n                    });\n                });\n                const origSendResult = original.apply(this, args);\n                return instrumentation._endSpansOnPromise(spans, pendingMetrics, origSendResult);\n            };\n        };\n    }\n    _getSendPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function send(...args) {\n                const record = args[0];\n                const spans = record.messages.map(message => {\n                    return instrumentation._startProducerSpan(record.topic, message);\n                });\n                const pendingMetrics = record.messages.map(m => prepareCounter(instrumentation._sentMessages, 1, {\n                    [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                    [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'send',\n                    [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: record.topic,\n                    ...(m.partition !== undefined\n                        ? {\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(m.partition),\n                        }\n                        : {}),\n                }));\n                const origSendResult = original.apply(this, args);\n                return instrumentation._endSpansOnPromise(spans, pendingMetrics, origSendResult);\n            };\n        };\n    }\n    _endSpansOnPromise(spans, pendingMetrics, sendPromise) {\n        return Promise.resolve(sendPromise)\n            .then(result => {\n            pendingMetrics.forEach(m => m());\n            return result;\n        })\n            .catch(reason => {\n            let errorMessage;\n            let errorType = semantic_conventions_1.ERROR_TYPE_VALUE_OTHER;\n            if (typeof reason === 'string' || reason === undefined) {\n                errorMessage = reason;\n            }\n            else if (typeof reason === 'object' &&\n                Object.prototype.hasOwnProperty.call(reason, 'message')) {\n                errorMessage = reason.message;\n                errorType = reason.constructor.name;\n            }\n            pendingMetrics.forEach(m => m(errorType));\n            spans.forEach(span => {\n                span.setAttribute(semantic_conventions_1.ATTR_ERROR_TYPE, errorType);\n                span.setStatus({\n                    code: api_1.SpanStatusCode.ERROR,\n                    message: errorMessage,\n                });\n            });\n            throw reason;\n        })\n            .finally(() => {\n            spans.forEach(span => span.end());\n        });\n    }\n    _startConsumerSpan({ topic, message, operationType, ctx, link, attributes, }) {\n        const operationName = operationType === semconv_1.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE\n            ? 'poll' // for batch processing spans\n            : operationType; // for individual message processing spans\n        const span = this.tracer.startSpan(`${operationName} ${topic}`, {\n            kind: operationType === semconv_1.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE\n                ? api_1.SpanKind.CLIENT\n                : api_1.SpanKind.CONSUMER,\n            attributes: {\n                ...attributes,\n                [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: topic,\n                [semconv_1.ATTR_MESSAGING_OPERATION_TYPE]: operationType,\n                [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: operationName,\n                [semconv_1.ATTR_MESSAGING_KAFKA_MESSAGE_KEY]: message?.key\n                    ? String(message.key)\n                    : undefined,\n                [semconv_1.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE]: message?.key && message.value === null ? true : undefined,\n                [semconv_1.ATTR_MESSAGING_KAFKA_OFFSET]: message?.offset,\n            },\n            links: link ? [link] : [],\n        }, ctx);\n        const { consumerHook } = this.getConfig();\n        if (consumerHook && message) {\n            (0, instrumentation_1.safeExecuteInTheMiddle)(() => consumerHook(span, { topic, message }), e => {\n                if (e)\n                    this._diag.error('consumerHook error', e);\n            }, true);\n        }\n        return span;\n    }\n    _startProducerSpan(topic, message) {\n        const span = this.tracer.startSpan(`send ${topic}`, {\n            kind: api_1.SpanKind.PRODUCER,\n            attributes: {\n                [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: topic,\n                [semconv_1.ATTR_MESSAGING_KAFKA_MESSAGE_KEY]: message.key\n                    ? String(message.key)\n                    : undefined,\n                [semconv_1.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE]: message.key && message.value === null ? true : undefined,\n                [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: message.partition !== undefined\n                    ? String(message.partition)\n                    : undefined,\n                [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'send',\n                [semconv_1.ATTR_MESSAGING_OPERATION_TYPE]: semconv_1.MESSAGING_OPERATION_TYPE_VALUE_SEND,\n            },\n        });\n        message.headers = message.headers ?? {};\n        api_1.propagation.inject(api_1.trace.setSpan(api_1.context.active(), span), message.headers);\n        const { producerHook } = this.getConfig();\n        if (producerHook) {\n            (0, instrumentation_1.safeExecuteInTheMiddle)(() => producerHook(span, { topic, message }), e => {\n                if (e)\n                    this._diag.error('producerHook error', e);\n            }, true);\n        }\n        return span;\n    }\n}\nexports.KafkaJsInstrumentation = KafkaJsInstrumentation;\n//# sourceMappingURL=instrumentation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24ta2Fma2Fqc0AwLjE0LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24ta2Fma2Fqcy9idWlsZC9zcmMvaW5zdHJ1bWVudGF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhLENBQUMsb0RBQW9ELHlDQUF5QywwQ0FBMEMsOENBQThDO0FBQ25NO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEI7QUFDOUIsY0FBYyxtQkFBTyxDQUFDLDZJQUFvQjtBQUMxQywwQkFBMEIsbUJBQU8sQ0FBQyw0TUFBZ0M7QUFDbEUsK0JBQStCLG1CQUFPLENBQUMsaU1BQXFDO0FBQzVFLHlCQUF5QixtQkFBTyxDQUFDLHNOQUFrQjtBQUNuRCxxQkFBcUIsbUJBQU8sQ0FBQyw4TUFBYztBQUMzQyxrQkFBa0IsbUJBQU8sQ0FBQyx3TUFBVztBQUNyQztBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHdNQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNEQUFzRCxJQUFJO0FBQ3hGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0RBQXNELElBQUk7QUFDeEYsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxrSEFBa0gsVUFBVSx5REFBeUQ7QUFDckw7QUFDQTtBQUNBLDBHQUEwRyxVQUFVLHlEQUF5RDtBQUM3SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxzQkFBc0I7QUFDaEY7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsK0JBQStCO0FBQ3ZGLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx5QkFBeUIsdURBQXVEO0FBQ2hGO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsOENBQThDLGVBQWUsRUFBRSxNQUFNO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1QsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQSxxRkFBcUYsZ0JBQWdCO0FBQ3JHO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsTUFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0EscUZBQXFGLGdCQUFnQjtBQUNyRztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCIiwic291cmNlcyI6WyIvVXNlcnMvY29keWRlYXJrbGFuZC9zZW50cnl2aWJlL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24ta2Fma2Fqc0AwLjE0LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24ta2Fma2Fqcy9idWlsZC9zcmMvaW5zdHJ1bWVudGF0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiOztnbG9iYWxUaGlzW1wiX3NlbnRyeVJld3JpdGVzVHVubmVsUGF0aFwiXSA9IHVuZGVmaW5lZDtnbG9iYWxUaGlzW1wiU0VOVFJZX1JFTEVBU0VcIl0gPSB1bmRlZmluZWQ7Z2xvYmFsVGhpc1tcIl9zZW50cnlCYXNlUGF0aFwiXSA9IHVuZGVmaW5lZDtnbG9iYWxUaGlzW1wiX3NlbnRyeU5leHRKc1ZlcnNpb25cIl0gPSBcIjE1LjUuNFwiO2dsb2JhbFRoaXNbXCJfc2VudHJ5UmV3cml0ZUZyYW1lc0Rpc3REaXJcIl0gPSBcIi5uZXh0XCI7XG4vKlxuICogQ29weXJpZ2h0IFRoZSBPcGVuVGVsZW1ldHJ5IEF1dGhvcnMsIEFzcGVjdG9cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5LYWZrYUpzSW5zdHJ1bWVudGF0aW9uID0gdm9pZCAwO1xuY29uc3QgYXBpXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvYXBpXCIpO1xuY29uc3QgaW5zdHJ1bWVudGF0aW9uXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uXCIpO1xuY29uc3Qgc2VtYW50aWNfY29udmVudGlvbnNfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc1wiKTtcbmNvbnN0IGludGVybmFsX3R5cGVzXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC10eXBlc1wiKTtcbmNvbnN0IHByb3BhZ2F0b3JfMSA9IHJlcXVpcmUoXCIuL3Byb3BhZ2F0b3JcIik7XG5jb25zdCBzZW1jb252XzEgPSByZXF1aXJlKFwiLi9zZW1jb252XCIpO1xuLyoqIEBrbmlwaWdub3JlICovXG5jb25zdCB2ZXJzaW9uXzEgPSByZXF1aXJlKFwiLi92ZXJzaW9uXCIpO1xuZnVuY3Rpb24gcHJlcGFyZUNvdW50ZXIobWV0ZXIsIHZhbHVlLCBhdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIChlcnJvclR5cGUpID0+IHtcbiAgICAgICAgbWV0ZXIuYWRkKHZhbHVlLCB7XG4gICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgLi4uKGVycm9yVHlwZSA/IHsgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9FUlJPUl9UWVBFXTogZXJyb3JUeXBlIH0gOiB7fSksXG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBwcmVwYXJlRHVyYXRpb25IaXN0b2dyYW0obWV0ZXIsIHZhbHVlLCBhdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIChlcnJvclR5cGUpID0+IHtcbiAgICAgICAgbWV0ZXIucmVjb3JkKChEYXRlLm5vdygpIC0gdmFsdWUpIC8gMTAwMCwge1xuICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgICAgIC4uLihlcnJvclR5cGUgPyB7IFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfRVJST1JfVFlQRV06IGVycm9yVHlwZSB9IDoge30pLFxuICAgICAgICB9KTtcbiAgICB9O1xufVxuY29uc3QgSElTVE9HUkFNX0JVQ0tFVF9CT1VOREFSSUVTID0gW1xuICAgIDAuMDA1LCAwLjAxLCAwLjAyNSwgMC4wNSwgMC4wNzUsIDAuMSwgMC4yNSwgMC41LCAwLjc1LCAxLCAyLjUsIDUsIDcuNSwgMTAsXG5dO1xuY2xhc3MgS2Fma2FKc0luc3RydW1lbnRhdGlvbiBleHRlbmRzIGluc3RydW1lbnRhdGlvbl8xLkluc3RydW1lbnRhdGlvbkJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHZlcnNpb25fMS5QQUNLQUdFX05BTUUsIHZlcnNpb25fMS5QQUNLQUdFX1ZFUlNJT04sIGNvbmZpZyk7XG4gICAgfVxuICAgIF91cGRhdGVNZXRyaWNJbnN0cnVtZW50cygpIHtcbiAgICAgICAgdGhpcy5fY2xpZW50RHVyYXRpb24gPSB0aGlzLm1ldGVyLmNyZWF0ZUhpc3RvZ3JhbShzZW1jb252XzEuTUVUUklDX01FU1NBR0lOR19DTElFTlRfT1BFUkFUSU9OX0RVUkFUSU9OLCB7IGFkdmljZTogeyBleHBsaWNpdEJ1Y2tldEJvdW5kYXJpZXM6IEhJU1RPR1JBTV9CVUNLRVRfQk9VTkRBUklFUyB9IH0pO1xuICAgICAgICB0aGlzLl9zZW50TWVzc2FnZXMgPSB0aGlzLm1ldGVyLmNyZWF0ZUNvdW50ZXIoc2VtY29udl8xLk1FVFJJQ19NRVNTQUdJTkdfQ0xJRU5UX1NFTlRfTUVTU0FHRVMpO1xuICAgICAgICB0aGlzLl9jb25zdW1lZE1lc3NhZ2VzID0gdGhpcy5tZXRlci5jcmVhdGVDb3VudGVyKHNlbWNvbnZfMS5NRVRSSUNfTUVTU0FHSU5HX0NMSUVOVF9DT05TVU1FRF9NRVNTQUdFUyk7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NEdXJhdGlvbiA9IHRoaXMubWV0ZXIuY3JlYXRlSGlzdG9ncmFtKHNlbWNvbnZfMS5NRVRSSUNfTUVTU0FHSU5HX1BST0NFU1NfRFVSQVRJT04sIHsgYWR2aWNlOiB7IGV4cGxpY2l0QnVja2V0Qm91bmRhcmllczogSElTVE9HUkFNX0JVQ0tFVF9CT1VOREFSSUVTIH0gfSk7XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIGNvbnN0IHVucGF0Y2ggPSAobW9kdWxlRXhwb3J0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHM/LkthZmthPy5wcm90b3R5cGUucHJvZHVjZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMuS2Fma2EucHJvdG90eXBlLCAncHJvZHVjZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzPy5LYWZrYT8ucHJvdG90eXBlLmNvbnN1bWVyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLkthZmthLnByb3RvdHlwZSwgJ2NvbnN1bWVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1vZHVsZSA9IG5ldyBpbnN0cnVtZW50YXRpb25fMS5JbnN0cnVtZW50YXRpb25Ob2RlTW9kdWxlRGVmaW5pdGlvbigna2Fma2FqcycsIFsnPj0wLjMuMCA8MyddLCAobW9kdWxlRXhwb3J0cykgPT4ge1xuICAgICAgICAgICAgdW5wYXRjaChtb2R1bGVFeHBvcnRzKTtcbiAgICAgICAgICAgIHRoaXMuX3dyYXAobW9kdWxlRXhwb3J0cz8uS2Fma2E/LnByb3RvdHlwZSwgJ3Byb2R1Y2VyJywgdGhpcy5fZ2V0UHJvZHVjZXJQYXRjaCgpKTtcbiAgICAgICAgICAgIHRoaXMuX3dyYXAobW9kdWxlRXhwb3J0cz8uS2Fma2E/LnByb3RvdHlwZSwgJ2NvbnN1bWVyJywgdGhpcy5fZ2V0Q29uc3VtZXJQYXRjaCgpKTtcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGVFeHBvcnRzO1xuICAgICAgICB9LCB1bnBhdGNoKTtcbiAgICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICB9XG4gICAgX2dldENvbnN1bWVyUGF0Y2goKSB7XG4gICAgICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbiA9IHRoaXM7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBjb25zdW1lciguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Q29uc3VtZXIgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobmV3Q29uc3VtZXIucnVuKSkge1xuICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX3Vud3JhcChuZXdDb25zdW1lciwgJ3J1bicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX3dyYXAobmV3Q29uc3VtZXIsICdydW4nLCBpbnN0cnVtZW50YXRpb24uX2dldENvbnN1bWVyUnVuUGF0Y2goKSk7XG4gICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl9zZXRLYWZrYUV2ZW50TGlzdGVuZXJzKG5ld0NvbnN1bWVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3Q29uc3VtZXI7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBfc2V0S2Fma2FFdmVudExpc3RlbmVycyhrYWZrYU9iaikge1xuICAgICAgICBpZiAoa2Fma2FPYmpbaW50ZXJuYWxfdHlwZXNfMS5FVkVOVF9MSVNURU5FUlNfU0VUXSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gVGhlIFJFUVVFU1QgQ29uc3VtZXIgZXZlbnQgd2FzIGFkZGVkIGluIGthZmthanNAMS41LjAuXG4gICAgICAgIGlmIChrYWZrYU9iai5ldmVudHM/LlJFUVVFU1QpIHtcbiAgICAgICAgICAgIGthZmthT2JqLm9uKGthZmthT2JqLmV2ZW50cy5SRVFVRVNULCB0aGlzLl9yZWNvcmRDbGllbnREdXJhdGlvbk1ldHJpYy5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICBrYWZrYU9ialtpbnRlcm5hbF90eXBlc18xLkVWRU5UX0xJU1RFTkVSU19TRVRdID0gdHJ1ZTtcbiAgICB9XG4gICAgX3JlY29yZENsaWVudER1cmF0aW9uTWV0cmljKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IFthZGRyZXNzLCBwb3J0XSA9IGV2ZW50LnBheWxvYWQuYnJva2VyLnNwbGl0KCc6Jyk7XG4gICAgICAgIHRoaXMuX2NsaWVudER1cmF0aW9uLnJlY29yZChldmVudC5wYXlsb2FkLmR1cmF0aW9uIC8gMTAwMCwge1xuICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19TWVNURU1dOiBzZW1jb252XzEuTUVTU0FHSU5HX1NZU1RFTV9WQUxVRV9LQUZLQSxcbiAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfT1BFUkFUSU9OX05BTUVdOiBgJHtldmVudC5wYXlsb2FkLmFwaU5hbWV9YCxcbiAgICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfU0VSVkVSX0FERFJFU1NdOiBhZGRyZXNzLFxuICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9TRVJWRVJfUE9SVF06IE51bWJlci5wYXJzZUludChwb3J0LCAxMCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0UHJvZHVjZXJQYXRjaCgpIHtcbiAgICAgICAgY29uc3QgaW5zdHJ1bWVudGF0aW9uID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChvcmlnaW5hbCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNvbnN1bWVyKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdQcm9kdWNlciA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShuZXdQcm9kdWNlci5zZW5kQmF0Y2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fdW53cmFwKG5ld1Byb2R1Y2VyLCAnc2VuZEJhdGNoJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fd3JhcChuZXdQcm9kdWNlciwgJ3NlbmRCYXRjaCcsIGluc3RydW1lbnRhdGlvbi5fZ2V0U2VuZEJhdGNoUGF0Y2goKSk7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG5ld1Byb2R1Y2VyLnNlbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fdW53cmFwKG5ld1Byb2R1Y2VyLCAnc2VuZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX3dyYXAobmV3UHJvZHVjZXIsICdzZW5kJywgaW5zdHJ1bWVudGF0aW9uLl9nZXRTZW5kUGF0Y2goKSk7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG5ld1Byb2R1Y2VyLnRyYW5zYWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX3Vud3JhcChuZXdQcm9kdWNlciwgJ3RyYW5zYWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fd3JhcChuZXdQcm9kdWNlciwgJ3RyYW5zYWN0aW9uJywgaW5zdHJ1bWVudGF0aW9uLl9nZXRQcm9kdWNlclRyYW5zYWN0aW9uUGF0Y2goKSk7XG4gICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl9zZXRLYWZrYUV2ZW50TGlzdGVuZXJzKG5ld1Byb2R1Y2VyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3UHJvZHVjZXI7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBfZ2V0Q29uc3VtZXJSdW5QYXRjaCgpIHtcbiAgICAgICAgY29uc3QgaW5zdHJ1bWVudGF0aW9uID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChvcmlnaW5hbCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJ1biguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZmlnID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnPy5lYWNoTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkoY29uZmlnLmVhY2hNZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl91bndyYXAoY29uZmlnLCAnZWFjaE1lc3NhZ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX3dyYXAoY29uZmlnLCAnZWFjaE1lc3NhZ2UnLCBpbnN0cnVtZW50YXRpb24uX2dldENvbnN1bWVyRWFjaE1lc3NhZ2VQYXRjaCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZz8uZWFjaEJhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShjb25maWcuZWFjaEJhdGNoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl91bndyYXAoY29uZmlnLCAnZWFjaEJhdGNoJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl93cmFwKGNvbmZpZywgJ2VhY2hCYXRjaCcsIGluc3RydW1lbnRhdGlvbi5fZ2V0Q29uc3VtZXJFYWNoQmF0Y2hQYXRjaCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9nZXRDb25zdW1lckVhY2hNZXNzYWdlUGF0Y2goKSB7XG4gICAgICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbiA9IHRoaXM7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBlYWNoTWVzc2FnZSguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcGFnYXRlZENvbnRleHQgPSBhcGlfMS5wcm9wYWdhdGlvbi5leHRyYWN0KGFwaV8xLlJPT1RfQ09OVEVYVCwgcGF5bG9hZC5tZXNzYWdlLmhlYWRlcnMsIHByb3BhZ2F0b3JfMS5idWZmZXJUZXh0TWFwR2V0dGVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzcGFuID0gaW5zdHJ1bWVudGF0aW9uLl9zdGFydENvbnN1bWVyU3Bhbih7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljOiBwYXlsb2FkLnRvcGljLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBwYXlsb2FkLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvblR5cGU6IHNlbWNvbnZfMS5NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEVfVkFMVUVfUFJPQ0VTUyxcbiAgICAgICAgICAgICAgICAgICAgY3R4OiBwcm9wYWdhdGVkQ29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9QQVJUSVRJT05fSURdOiBTdHJpbmcocGF5bG9hZC5wYXJ0aXRpb24pLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBlbmRpbmdNZXRyaWNzID0gW1xuICAgICAgICAgICAgICAgICAgICBwcmVwYXJlRHVyYXRpb25IaXN0b2dyYW0oaW5zdHJ1bWVudGF0aW9uLl9wcm9jZXNzRHVyYXRpb24sIERhdGUubm93KCksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfU1lTVEVNXTogc2VtY29udl8xLk1FU1NBR0lOR19TWVNURU1fVkFMVUVfS0FGS0EsXG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9OQU1FXTogJ3Byb2Nlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9OQU1FXTogcGF5bG9hZC50b3BpYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fUEFSVElUSU9OX0lEXTogU3RyaW5nKHBheWxvYWQucGFydGl0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIHByZXBhcmVDb3VudGVyKGluc3RydW1lbnRhdGlvbi5fY29uc3VtZWRNZXNzYWdlcywgMSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19TWVNURU1dOiBzZW1jb252XzEuTUVTU0FHSU5HX1NZU1RFTV9WQUxVRV9LQUZLQSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfT1BFUkFUSU9OX05BTUVdOiAncHJvY2VzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX05BTUVdOiBwYXlsb2FkLnRvcGljLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9QQVJUSVRJT05fSURdOiBTdHJpbmcocGF5bG9hZC5wYXJ0aXRpb24pLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVhY2hNZXNzYWdlUHJvbWlzZSA9IGFwaV8xLmNvbnRleHQud2l0aChhcGlfMS50cmFjZS5zZXRTcGFuKHByb3BhZ2F0ZWRDb250ZXh0LCBzcGFuKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RydW1lbnRhdGlvbi5fZW5kU3BhbnNPblByb21pc2UoW3NwYW5dLCBwZW5kaW5nTWV0cmljcywgZWFjaE1lc3NhZ2VQcm9taXNlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9nZXRDb25zdW1lckVhY2hCYXRjaFBhdGNoKCkge1xuICAgICAgICByZXR1cm4gKG9yaWdpbmFsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnN0cnVtZW50YXRpb24gPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGVhY2hCYXRjaCguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL29wZW4tdGVsZW1ldHJ5L29wZW50ZWxlbWV0cnktc3BlY2lmaWNhdGlvbi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uL3RyYWNlL3NlbWFudGljX2NvbnZlbnRpb25zL21lc3NhZ2luZy5tZCN0b3BpYy13aXRoLW11bHRpcGxlLWNvbnN1bWVyc1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlY2VpdmluZ1NwYW4gPSBpbnN0cnVtZW50YXRpb24uX3N0YXJ0Q29uc3VtZXJTcGFuKHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWM6IHBheWxvYWQuYmF0Y2gudG9waWMsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uVHlwZTogc2VtY29udl8xLk1FU1NBR0lOR19PUEVSQVRJT05fVFlQRV9WQUxVRV9SRUNFSVZFLFxuICAgICAgICAgICAgICAgICAgICBjdHg6IGFwaV8xLlJPT1RfQ09OVEVYVCxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19CQVRDSF9NRVNTQUdFX0NPVU5UXTogcGF5bG9hZC5iYXRjaC5tZXNzYWdlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX1BBUlRJVElPTl9JRF06IFN0cmluZyhwYXlsb2FkLmJhdGNoLnBhcnRpdGlvbiksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaV8xLmNvbnRleHQud2l0aChhcGlfMS50cmFjZS5zZXRTcGFuKGFwaV8xLmNvbnRleHQuYWN0aXZlKCksIHJlY2VpdmluZ1NwYW4pLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwYW5zID0gW107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBlbmRpbmdNZXRyaWNzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlcGFyZUNvdW50ZXIoaW5zdHJ1bWVudGF0aW9uLl9jb25zdW1lZE1lc3NhZ2VzLCBwYXlsb2FkLmJhdGNoLm1lc3NhZ2VzLmxlbmd0aCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfU1lTVEVNXTogc2VtY29udl8xLk1FU1NBR0lOR19TWVNURU1fVkFMVUVfS0FGS0EsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fTkFNRV06ICdwcm9jZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX05BTUVdOiBwYXlsb2FkLmJhdGNoLnRvcGljLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fUEFSVElUSU9OX0lEXTogU3RyaW5nKHBheWxvYWQuYmF0Y2gucGFydGl0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLmJhdGNoLm1lc3NhZ2VzLmZvckVhY2gobWVzc2FnZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wYWdhdGVkQ29udGV4dCA9IGFwaV8xLnByb3BhZ2F0aW9uLmV4dHJhY3QoYXBpXzEuUk9PVF9DT05URVhULCBtZXNzYWdlLmhlYWRlcnMsIHByb3BhZ2F0b3JfMS5idWZmZXJUZXh0TWFwR2V0dGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwYW5Db250ZXh0ID0gYXBpXzEudHJhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0U3Bhbihwcm9wYWdhdGVkQ29udGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/LnNwYW5Db250ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgb3JpZ1NwYW5MaW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwYW5Db250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ1NwYW5MaW5rID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBzcGFuQ29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3BhbnMucHVzaChpbnN0cnVtZW50YXRpb24uX3N0YXJ0Q29uc3VtZXJTcGFuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3BpYzogcGF5bG9hZC5iYXRjaC50b3BpYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvblR5cGU6IHNlbWNvbnZfMS5NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEVfVkFMVUVfUFJPQ0VTUyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rOiBvcmlnU3BhbkxpbmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX1BBUlRJVElPTl9JRF06IFN0cmluZyhwYXlsb2FkLmJhdGNoLnBhcnRpdGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdNZXRyaWNzLnB1c2gocHJlcGFyZUR1cmF0aW9uSGlzdG9ncmFtKGluc3RydW1lbnRhdGlvbi5fcHJvY2Vzc0R1cmF0aW9uLCBzdGFydFRpbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX1NZU1RFTV06IHNlbWNvbnZfMS5NRVNTQUdJTkdfU1lTVEVNX1ZBTFVFX0tBRktBLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfT1BFUkFUSU9OX05BTUVdOiAncHJvY2VzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9OQU1FXTogcGF5bG9hZC5iYXRjaC50b3BpYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX1BBUlRJVElPTl9JRF06IFN0cmluZyhwYXlsb2FkLmJhdGNoLnBhcnRpdGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXRjaE1lc3NhZ2VQcm9taXNlID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIHNwYW5zLnVuc2hpZnQocmVjZWl2aW5nU3Bhbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnN0cnVtZW50YXRpb24uX2VuZFNwYW5zT25Qcm9taXNlKHNwYW5zLCBwZW5kaW5nTWV0cmljcywgYmF0Y2hNZXNzYWdlUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBfZ2V0UHJvZHVjZXJUcmFuc2FjdGlvblBhdGNoKCkge1xuICAgICAgICBjb25zdCBpbnN0cnVtZW50YXRpb24gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKG9yaWdpbmFsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gdHJhbnNhY3Rpb24oLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uU3BhbiA9IGluc3RydW1lbnRhdGlvbi50cmFjZXIuc3RhcnRTcGFuKCd0cmFuc2FjdGlvbicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uUHJvbWlzZSA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uUHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAudGhlbigodHJhbnNhY3Rpb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTZW5kID0gdHJhbnNhY3Rpb24uc2VuZDtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uc2VuZCA9IGZ1bmN0aW9uIHNlbmQoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwaV8xLmNvbnRleHQud2l0aChhcGlfMS50cmFjZS5zZXRTcGFuKGFwaV8xLmNvbnRleHQuYWN0aXZlKCksIHRyYW5zYWN0aW9uU3BhbiksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRjaGVkID0gaW5zdHJ1bWVudGF0aW9uLl9nZXRTZW5kUGF0Y2goKShvcmlnaW5hbFNlbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRjaGVkLmFwcGx5KHRoaXMsIGFyZ3MpLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uU3Bhbi5zZXRTdGF0dXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogYXBpXzEuU3BhblN0YXR1c0NvZGUuRVJST1IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnI/Lm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvblNwYW4ucmVjb3JkRXhjZXB0aW9uKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFNlbmRCYXRjaCA9IHRyYW5zYWN0aW9uLnNlbmRCYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uc2VuZEJhdGNoID0gZnVuY3Rpb24gc2VuZEJhdGNoKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcGlfMS5jb250ZXh0LndpdGgoYXBpXzEudHJhY2Uuc2V0U3BhbihhcGlfMS5jb250ZXh0LmFjdGl2ZSgpLCB0cmFuc2FjdGlvblNwYW4pLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0Y2hlZCA9IGluc3RydW1lbnRhdGlvbi5fZ2V0U2VuZEJhdGNoUGF0Y2goKShvcmlnaW5hbFNlbmRCYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGNoZWQuYXBwbHkodGhpcywgYXJncykuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TcGFuLnNldFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycj8ubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uU3Bhbi5yZWNvcmRFeGNlcHRpb24oZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsQ29tbWl0ID0gdHJhbnNhY3Rpb24uY29tbWl0O1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5jb21taXQgPSBmdW5jdGlvbiBjb21taXQoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luQ29tbWl0UHJvbWlzZSA9IG9yaWdpbmFsQ29tbWl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uU3Bhbi5zZXRTdGF0dXMoeyBjb2RlOiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5PSyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RydW1lbnRhdGlvbi5fZW5kU3BhbnNPblByb21pc2UoW3RyYW5zYWN0aW9uU3Bhbl0sIFtdLCBvcmlnaW5Db21taXRQcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxBYm9ydCA9IHRyYW5zYWN0aW9uLmFib3J0O1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5hYm9ydCA9IGZ1bmN0aW9uIGFib3J0KC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbkFib3J0UHJvbWlzZSA9IG9yaWdpbmFsQWJvcnQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zdHJ1bWVudGF0aW9uLl9lbmRTcGFuc09uUHJvbWlzZShbdHJhbnNhY3Rpb25TcGFuXSwgW10sIG9yaWdpbkFib3J0UHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uU3Bhbi5zZXRTdGF0dXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogYXBpXzEuU3BhblN0YXR1c0NvZGUuRVJST1IsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnI/Lm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvblNwYW4ucmVjb3JkRXhjZXB0aW9uKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uU3Bhbi5lbmQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25Qcm9taXNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2dldFNlbmRCYXRjaFBhdGNoKCkge1xuICAgICAgICBjb25zdCBpbnN0cnVtZW50YXRpb24gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKG9yaWdpbmFsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gc2VuZEJhdGNoKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXRjaCA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBiYXRjaC50b3BpY01lc3NhZ2VzIHx8IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwYW5zID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgcGVuZGluZ01ldHJpY3MgPSBbXTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKHRvcGljTWVzc2FnZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljTWVzc2FnZS5tZXNzYWdlcy5mb3JFYWNoKG1lc3NhZ2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BhbnMucHVzaChpbnN0cnVtZW50YXRpb24uX3N0YXJ0UHJvZHVjZXJTcGFuKHRvcGljTWVzc2FnZS50b3BpYywgbWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ01ldHJpY3MucHVzaChwcmVwYXJlQ291bnRlcihpbnN0cnVtZW50YXRpb24uX3NlbnRNZXNzYWdlcywgMSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfU1lTVEVNXTogc2VtY29udl8xLk1FU1NBR0lOR19TWVNURU1fVkFMVUVfS0FGS0EsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fTkFNRV06ICdzZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX05BTUVdOiB0b3BpY01lc3NhZ2UudG9waWMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uKG1lc3NhZ2UucGFydGl0aW9uICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX1BBUlRJVElPTl9JRF06IFN0cmluZyhtZXNzYWdlLnBhcnRpdGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdTZW5kUmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RydW1lbnRhdGlvbi5fZW5kU3BhbnNPblByb21pc2Uoc3BhbnMsIHBlbmRpbmdNZXRyaWNzLCBvcmlnU2VuZFJlc3VsdCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBfZ2V0U2VuZFBhdGNoKCkge1xuICAgICAgICBjb25zdCBpbnN0cnVtZW50YXRpb24gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKG9yaWdpbmFsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gc2VuZCguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjb3JkID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzcGFucyA9IHJlY29yZC5tZXNzYWdlcy5tYXAobWVzc2FnZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnN0cnVtZW50YXRpb24uX3N0YXJ0UHJvZHVjZXJTcGFuKHJlY29yZC50b3BpYywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGVuZGluZ01ldHJpY3MgPSByZWNvcmQubWVzc2FnZXMubWFwKG0gPT4gcHJlcGFyZUNvdW50ZXIoaW5zdHJ1bWVudGF0aW9uLl9zZW50TWVzc2FnZXMsIDEsIHtcbiAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19TWVNURU1dOiBzZW1jb252XzEuTUVTU0FHSU5HX1NZU1RFTV9WQUxVRV9LQUZLQSxcbiAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fTkFNRV06ICdzZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9OQU1FXTogcmVjb3JkLnRvcGljLFxuICAgICAgICAgICAgICAgICAgICAuLi4obS5wYXJ0aXRpb24gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9QQVJUSVRJT05fSURdOiBTdHJpbmcobS5wYXJ0aXRpb24pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdTZW5kUmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RydW1lbnRhdGlvbi5fZW5kU3BhbnNPblByb21pc2Uoc3BhbnMsIHBlbmRpbmdNZXRyaWNzLCBvcmlnU2VuZFJlc3VsdCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBfZW5kU3BhbnNPblByb21pc2Uoc3BhbnMsIHBlbmRpbmdNZXRyaWNzLCBzZW5kUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNlbmRQcm9taXNlKVxuICAgICAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIHBlbmRpbmdNZXRyaWNzLmZvckVhY2gobSA9PiBtKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgICAgICAgbGV0IGVycm9yTWVzc2FnZTtcbiAgICAgICAgICAgIGxldCBlcnJvclR5cGUgPSBzZW1hbnRpY19jb252ZW50aW9uc18xLkVSUk9SX1RZUEVfVkFMVUVfT1RIRVI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlYXNvbiA9PT0gJ3N0cmluZycgfHwgcmVhc29uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSByZWFzb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcmVhc29uID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZWFzb24sICdtZXNzYWdlJykpIHtcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSByZWFzb24ubWVzc2FnZTtcbiAgICAgICAgICAgICAgICBlcnJvclR5cGUgPSByZWFzb24uY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBlbmRpbmdNZXRyaWNzLmZvckVhY2gobSA9PiBtKGVycm9yVHlwZSkpO1xuICAgICAgICAgICAgc3BhbnMuZm9yRWFjaChzcGFuID0+IHtcbiAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfRVJST1JfVFlQRSwgZXJyb3JUeXBlKTtcbiAgICAgICAgICAgICAgICBzcGFuLnNldFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGFwaV8xLlNwYW5TdGF0dXNDb2RlLkVSUk9SLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRocm93IHJlYXNvbjtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgIHNwYW5zLmZvckVhY2goc3BhbiA9PiBzcGFuLmVuZCgpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9zdGFydENvbnN1bWVyU3Bhbih7IHRvcGljLCBtZXNzYWdlLCBvcGVyYXRpb25UeXBlLCBjdHgsIGxpbmssIGF0dHJpYnV0ZXMsIH0pIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uTmFtZSA9IG9wZXJhdGlvblR5cGUgPT09IHNlbWNvbnZfMS5NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEVfVkFMVUVfUkVDRUlWRVxuICAgICAgICAgICAgPyAncG9sbCcgLy8gZm9yIGJhdGNoIHByb2Nlc3Npbmcgc3BhbnNcbiAgICAgICAgICAgIDogb3BlcmF0aW9uVHlwZTsgLy8gZm9yIGluZGl2aWR1YWwgbWVzc2FnZSBwcm9jZXNzaW5nIHNwYW5zXG4gICAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLnRyYWNlci5zdGFydFNwYW4oYCR7b3BlcmF0aW9uTmFtZX0gJHt0b3BpY31gLCB7XG4gICAgICAgICAgICBraW5kOiBvcGVyYXRpb25UeXBlID09PSBzZW1jb252XzEuTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFX1ZBTFVFX1JFQ0VJVkVcbiAgICAgICAgICAgICAgICA/IGFwaV8xLlNwYW5LaW5kLkNMSUVOVFxuICAgICAgICAgICAgICAgIDogYXBpXzEuU3BhbktpbmQuQ09OU1VNRVIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX1NZU1RFTV06IHNlbWNvbnZfMS5NRVNTQUdJTkdfU1lTVEVNX1ZBTFVFX0tBRktBLFxuICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fTkFNRV06IHRvcGljLFxuICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEVdOiBvcGVyYXRpb25UeXBlLFxuICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfT1BFUkFUSU9OX05BTUVdOiBvcGVyYXRpb25OYW1lLFxuICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfS0FGS0FfTUVTU0FHRV9LRVldOiBtZXNzYWdlPy5rZXlcbiAgICAgICAgICAgICAgICAgICAgPyBTdHJpbmcobWVzc2FnZS5rZXkpXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfS0FGS0FfTUVTU0FHRV9UT01CU1RPTkVdOiBtZXNzYWdlPy5rZXkgJiYgbWVzc2FnZS52YWx1ZSA9PT0gbnVsbCA/IHRydWUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19LQUZLQV9PRkZTRVRdOiBtZXNzYWdlPy5vZmZzZXQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGlua3M6IGxpbmsgPyBbbGlua10gOiBbXSxcbiAgICAgICAgfSwgY3R4KTtcbiAgICAgICAgY29uc3QgeyBjb25zdW1lckhvb2sgfSA9IHRoaXMuZ2V0Q29uZmlnKCk7XG4gICAgICAgIGlmIChjb25zdW1lckhvb2sgJiYgbWVzc2FnZSkge1xuICAgICAgICAgICAgKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IGNvbnN1bWVySG9vayhzcGFuLCB7IHRvcGljLCBtZXNzYWdlIH0pLCBlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlhZy5lcnJvcignY29uc3VtZXJIb29rIGVycm9yJywgZSk7XG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG4gICAgX3N0YXJ0UHJvZHVjZXJTcGFuKHRvcGljLCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLnRyYWNlci5zdGFydFNwYW4oYHNlbmQgJHt0b3BpY31gLCB7XG4gICAgICAgICAgICBraW5kOiBhcGlfMS5TcGFuS2luZC5QUk9EVUNFUixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX1NZU1RFTV06IHNlbWNvbnZfMS5NRVNTQUdJTkdfU1lTVEVNX1ZBTFVFX0tBRktBLFxuICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fTkFNRV06IHRvcGljLFxuICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfS0FGS0FfTUVTU0FHRV9LRVldOiBtZXNzYWdlLmtleVxuICAgICAgICAgICAgICAgICAgICA/IFN0cmluZyhtZXNzYWdlLmtleSlcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19LQUZLQV9NRVNTQUdFX1RPTUJTVE9ORV06IG1lc3NhZ2Uua2V5ICYmIG1lc3NhZ2UudmFsdWUgPT09IG51bGwgPyB0cnVlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fUEFSVElUSU9OX0lEXTogbWVzc2FnZS5wYXJ0aXRpb24gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IFN0cmluZyhtZXNzYWdlLnBhcnRpdGlvbilcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fTkFNRV06ICdzZW5kJyxcbiAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFXTogc2VtY29udl8xLk1FU1NBR0lOR19PUEVSQVRJT05fVFlQRV9WQUxVRV9TRU5ELFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIG1lc3NhZ2UuaGVhZGVycyA9IG1lc3NhZ2UuaGVhZGVycyA/PyB7fTtcbiAgICAgICAgYXBpXzEucHJvcGFnYXRpb24uaW5qZWN0KGFwaV8xLnRyYWNlLnNldFNwYW4oYXBpXzEuY29udGV4dC5hY3RpdmUoKSwgc3BhbiksIG1lc3NhZ2UuaGVhZGVycyk7XG4gICAgICAgIGNvbnN0IHsgcHJvZHVjZXJIb29rIH0gPSB0aGlzLmdldENvbmZpZygpO1xuICAgICAgICBpZiAocHJvZHVjZXJIb29rKSB7XG4gICAgICAgICAgICAoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4gcHJvZHVjZXJIb29rKHNwYW4sIHsgdG9waWMsIG1lc3NhZ2UgfSksIGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaWFnLmVycm9yKCdwcm9kdWNlckhvb2sgZXJyb3InLCBlKTtcbiAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbn1cbmV4cG9ydHMuS2Fma2FKc0luc3RydW1lbnRhdGlvbiA9IEthZmthSnNJbnN0cnVtZW50YXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnN0cnVtZW50YXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/instrumentation.js\n");

/***/ }),

/***/ "(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/internal-types.js":
/*!***************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/internal-types.js ***!
  \***************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors, Aspecto\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EVENT_LISTENERS_SET = void 0;\nexports.EVENT_LISTENERS_SET = Symbol('opentelemetry.instrumentation.kafkajs.eventListenersSet');\n//# sourceMappingURL=internal-types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24ta2Fma2Fqc0AwLjE0LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24ta2Fma2Fqcy9idWlsZC9zcmMvaW50ZXJuYWwtdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQiIsInNvdXJjZXMiOlsiL1VzZXJzL2NvZHlkZWFya2xhbmQvc2VudHJ5dmliZS9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWthZmthanNAMC4xNC4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWthZmthanMvYnVpbGQvc3JjL2ludGVybmFsLXR5cGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBUaGUgT3BlblRlbGVtZXRyeSBBdXRob3JzLCBBc3BlY3RvXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRVZFTlRfTElTVEVORVJTX1NFVCA9IHZvaWQgMDtcbmV4cG9ydHMuRVZFTlRfTElTVEVORVJTX1NFVCA9IFN5bWJvbCgnb3BlbnRlbGVtZXRyeS5pbnN0cnVtZW50YXRpb24ua2Fma2Fqcy5ldmVudExpc3RlbmVyc1NldCcpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJuYWwtdHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/internal-types.js\n");

/***/ }),

/***/ "(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/propagator.js":
/*!***********************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/propagator.js ***!
  \***********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bufferTextMapGetter = void 0;\n/*\nsame as open telemetry's `defaultTextMapGetter`,\nbut also handle case where header is buffer,\nadding toString() to make sure string is returned\n*/\nexports.bufferTextMapGetter = {\n    get(carrier, key) {\n        if (!carrier) {\n            return undefined;\n        }\n        const keys = Object.keys(carrier);\n        for (const carrierKey of keys) {\n            if (carrierKey === key || carrierKey.toLowerCase() === key) {\n                return carrier[carrierKey]?.toString();\n            }\n        }\n        return undefined;\n    },\n    keys(carrier) {\n        return carrier ? Object.keys(carrier) : [];\n    },\n};\n//# sourceMappingURL=propagator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24ta2Fma2Fqc0AwLjE0LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24ta2Fma2Fqcy9idWlsZC9zcmMvcHJvcGFnYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2NvZHlkZWFya2xhbmQvc2VudHJ5dmliZS9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWthZmthanNAMC4xNC4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWthZmthanMvYnVpbGQvc3JjL3Byb3BhZ2F0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJ1ZmZlclRleHRNYXBHZXR0ZXIgPSB2b2lkIDA7XG4vKlxuc2FtZSBhcyBvcGVuIHRlbGVtZXRyeSdzIGBkZWZhdWx0VGV4dE1hcEdldHRlcmAsXG5idXQgYWxzbyBoYW5kbGUgY2FzZSB3aGVyZSBoZWFkZXIgaXMgYnVmZmVyLFxuYWRkaW5nIHRvU3RyaW5nKCkgdG8gbWFrZSBzdXJlIHN0cmluZyBpcyByZXR1cm5lZFxuKi9cbmV4cG9ydHMuYnVmZmVyVGV4dE1hcEdldHRlciA9IHtcbiAgICBnZXQoY2Fycmllciwga2V5KSB7XG4gICAgICAgIGlmICghY2Fycmllcikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY2Fycmllcik7XG4gICAgICAgIGZvciAoY29uc3QgY2FycmllcktleSBvZiBrZXlzKSB7XG4gICAgICAgICAgICBpZiAoY2FycmllcktleSA9PT0ga2V5IHx8IGNhcnJpZXJLZXkudG9Mb3dlckNhc2UoKSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhcnJpZXJbY2FycmllcktleV0/LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIGtleXMoY2Fycmllcikge1xuICAgICAgICByZXR1cm4gY2FycmllciA/IE9iamVjdC5rZXlzKGNhcnJpZXIpIDogW107XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wYWdhdG9yLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/propagator.js\n");

/***/ }),

/***/ "(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/semconv.js":
/*!********************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/semconv.js ***!
  \********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.METRIC_MESSAGING_PROCESS_DURATION = exports.METRIC_MESSAGING_CLIENT_SENT_MESSAGES = exports.METRIC_MESSAGING_CLIENT_OPERATION_DURATION = exports.METRIC_MESSAGING_CLIENT_CONSUMED_MESSAGES = exports.MESSAGING_SYSTEM_VALUE_KAFKA = exports.MESSAGING_OPERATION_TYPE_VALUE_SEND = exports.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE = exports.MESSAGING_OPERATION_TYPE_VALUE_PROCESS = exports.ATTR_MESSAGING_SYSTEM = exports.ATTR_MESSAGING_OPERATION_TYPE = exports.ATTR_MESSAGING_OPERATION_NAME = exports.ATTR_MESSAGING_KAFKA_OFFSET = exports.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE = exports.ATTR_MESSAGING_KAFKA_MESSAGE_KEY = exports.ATTR_MESSAGING_DESTINATION_PARTITION_ID = exports.ATTR_MESSAGING_DESTINATION_NAME = exports.ATTR_MESSAGING_BATCH_MESSAGE_COUNT = void 0;\n/*\n * This file contains a copy of unstable semantic convention definitions\n * used by this package.\n * @see https://github.com/open-telemetry/opentelemetry-js/tree/main/semantic-conventions#unstable-semconv\n */\n/**\n * The number of messages sent, received, or processed in the scope of the batching operation.\n *\n * @example 0\n * @example 1\n * @example 2\n *\n * @note Instrumentations **SHOULD NOT** set `messaging.batch.message_count` on spans that operate with a single message. When a messaging client library supports both batch and single-message API for the same operation, instrumentations **SHOULD** use `messaging.batch.message_count` for batching APIs and **SHOULD NOT** use it for single-message APIs.\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_BATCH_MESSAGE_COUNT = 'messaging.batch.message_count';\n/**\n * The message destination name\n *\n * @example MyQueue\n * @example MyTopic\n *\n * @note Destination name **SHOULD** uniquely identify a specific queue, topic or other entity within the broker. If\n * the broker doesn't have such notion, the destination name **SHOULD** uniquely identify the broker.\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_DESTINATION_NAME = 'messaging.destination.name';\n/**\n * The identifier of the partition messages are sent to or received from, unique within the `messaging.destination.name`.\n *\n * @example \"1\"\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_DESTINATION_PARTITION_ID = 'messaging.destination.partition.id';\n/**\n * Message keys in Kafka are used for grouping alike messages to ensure they're processed on the same partition. They differ from `messaging.message.id` in that they're not unique. If the key is `null`, the attribute **MUST NOT** be set.\n *\n * @example \"myKey\"\n *\n * @note If the key type is not string, it's string representation has to be supplied for the attribute. If the key has no unambiguous, canonical string form, don't include its value.\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_KAFKA_MESSAGE_KEY = 'messaging.kafka.message.key';\n/**\n * A boolean that is true if the message is a tombstone.\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE = 'messaging.kafka.message.tombstone';\n/**\n * The offset of a record in the corresponding Kafka partition.\n *\n * @example 42\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_KAFKA_OFFSET = 'messaging.kafka.offset';\n/**\n * The system-specific name of the messaging operation.\n *\n * @example ack\n * @example nack\n * @example send\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_OPERATION_NAME = 'messaging.operation.name';\n/**\n * A string identifying the type of the messaging operation.\n *\n * @note If a custom value is used, it **MUST** be of low cardinality.\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_OPERATION_TYPE = 'messaging.operation.type';\n/**\n * The messaging system as identified by the client instrumentation.\n *\n * @note The actual messaging system may differ from the one known by the client. For example, when using Kafka client libraries to communicate with Azure Event Hubs, the `messaging.system` is set to `kafka` based on the instrumentation's best knowledge.\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_SYSTEM = 'messaging.system';\n/**\n * Enum value \"process\" for attribute {@link ATTR_MESSAGING_OPERATION_TYPE}.\n */\nexports.MESSAGING_OPERATION_TYPE_VALUE_PROCESS = 'process';\n/**\n * Enum value \"receive\" for attribute {@link ATTR_MESSAGING_OPERATION_TYPE}.\n */\nexports.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE = 'receive';\n/**\n * Enum value \"send\" for attribute {@link ATTR_MESSAGING_OPERATION_TYPE}.\n */\nexports.MESSAGING_OPERATION_TYPE_VALUE_SEND = 'send';\n/**\n * Enum value \"kafka\" for attribute {@link ATTR_MESSAGING_SYSTEM}.\n */\nexports.MESSAGING_SYSTEM_VALUE_KAFKA = 'kafka';\n/**\n * Number of messages that were delivered to the application.\n *\n * @note Records the number of messages pulled from the broker or number of messages dispatched to the application in push-based scenarios.\n * The metric **SHOULD** be reported once per message delivery. For example, if receiving and processing operations are both instrumented for a single message delivery, this counter is incremented when the message is received and not reported when it is processed.\n *\n * @experimental This metric is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.METRIC_MESSAGING_CLIENT_CONSUMED_MESSAGES = 'messaging.client.consumed.messages';\n/**\n * Duration of messaging operation initiated by a producer or consumer client.\n *\n * @note This metric **SHOULD NOT** be used to report processing duration - processing duration is reported in `messaging.process.duration` metric.\n *\n * @experimental This metric is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.METRIC_MESSAGING_CLIENT_OPERATION_DURATION = 'messaging.client.operation.duration';\n/**\n * Number of messages producer attempted to send to the broker.\n *\n * @note This metric **MUST NOT** count messages that were created but haven't yet been sent.\n *\n * @experimental This metric is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.METRIC_MESSAGING_CLIENT_SENT_MESSAGES = 'messaging.client.sent.messages';\n/**\n * Duration of processing operation.\n *\n * @note This metric **MUST** be reported for operations with `messaging.operation.type` that matches `process`.\n *\n * @experimental This metric is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.METRIC_MESSAGING_PROCESS_DURATION = 'messaging.process.duration';\n//# sourceMappingURL=semconv.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24ta2Fma2Fqc0AwLjE0LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24ta2Fma2Fqcy9idWlsZC9zcmMvc2VtY29udi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5Q0FBeUMsR0FBRyw2Q0FBNkMsR0FBRyxrREFBa0QsR0FBRyxpREFBaUQsR0FBRyxvQ0FBb0MsR0FBRywyQ0FBMkMsR0FBRyw4Q0FBOEMsR0FBRyw4Q0FBOEMsR0FBRyw2QkFBNkIsR0FBRyxxQ0FBcUMsR0FBRyxxQ0FBcUMsR0FBRyxtQ0FBbUMsR0FBRyw4Q0FBOEMsR0FBRyx3Q0FBd0MsR0FBRywrQ0FBK0MsR0FBRyx1Q0FBdUMsR0FBRywwQ0FBMEM7QUFDcHZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHVDQUF1QyxvQ0FBb0M7QUFDM0U7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSx1Q0FBdUMsb0NBQW9DO0FBQzNFO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0Esb0NBQW9DLG9DQUFvQztBQUN4RTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLHFDQUFxQyw0QkFBNEI7QUFDakU7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyIsInNvdXJjZXMiOlsiL1VzZXJzL2NvZHlkZWFya2xhbmQvc2VudHJ5dmliZS9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWthZmthanNAMC4xNC4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWthZmthanMvYnVpbGQvc3JjL3NlbWNvbnYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IFRoZSBPcGVuVGVsZW1ldHJ5IEF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NRVRSSUNfTUVTU0FHSU5HX1BST0NFU1NfRFVSQVRJT04gPSBleHBvcnRzLk1FVFJJQ19NRVNTQUdJTkdfQ0xJRU5UX1NFTlRfTUVTU0FHRVMgPSBleHBvcnRzLk1FVFJJQ19NRVNTQUdJTkdfQ0xJRU5UX09QRVJBVElPTl9EVVJBVElPTiA9IGV4cG9ydHMuTUVUUklDX01FU1NBR0lOR19DTElFTlRfQ09OU1VNRURfTUVTU0FHRVMgPSBleHBvcnRzLk1FU1NBR0lOR19TWVNURU1fVkFMVUVfS0FGS0EgPSBleHBvcnRzLk1FU1NBR0lOR19PUEVSQVRJT05fVFlQRV9WQUxVRV9TRU5EID0gZXhwb3J0cy5NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEVfVkFMVUVfUkVDRUlWRSA9IGV4cG9ydHMuTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFX1ZBTFVFX1BST0NFU1MgPSBleHBvcnRzLkFUVFJfTUVTU0FHSU5HX1NZU1RFTSA9IGV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEUgPSBleHBvcnRzLkFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9OQU1FID0gZXhwb3J0cy5BVFRSX01FU1NBR0lOR19LQUZLQV9PRkZTRVQgPSBleHBvcnRzLkFUVFJfTUVTU0FHSU5HX0tBRktBX01FU1NBR0VfVE9NQlNUT05FID0gZXhwb3J0cy5BVFRSX01FU1NBR0lOR19LQUZLQV9NRVNTQUdFX0tFWSA9IGV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fUEFSVElUSU9OX0lEID0gZXhwb3J0cy5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9OQU1FID0gZXhwb3J0cy5BVFRSX01FU1NBR0lOR19CQVRDSF9NRVNTQUdFX0NPVU5UID0gdm9pZCAwO1xuLypcbiAqIFRoaXMgZmlsZSBjb250YWlucyBhIGNvcHkgb2YgdW5zdGFibGUgc2VtYW50aWMgY29udmVudGlvbiBkZWZpbml0aW9uc1xuICogdXNlZCBieSB0aGlzIHBhY2thZ2UuXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuLXRlbGVtZXRyeS9vcGVudGVsZW1ldHJ5LWpzL3RyZWUvbWFpbi9zZW1hbnRpYy1jb252ZW50aW9ucyN1bnN0YWJsZS1zZW1jb252XG4gKi9cbi8qKlxuICogVGhlIG51bWJlciBvZiBtZXNzYWdlcyBzZW50LCByZWNlaXZlZCwgb3IgcHJvY2Vzc2VkIGluIHRoZSBzY29wZSBvZiB0aGUgYmF0Y2hpbmcgb3BlcmF0aW9uLlxuICpcbiAqIEBleGFtcGxlIDBcbiAqIEBleGFtcGxlIDFcbiAqIEBleGFtcGxlIDJcbiAqXG4gKiBAbm90ZSBJbnN0cnVtZW50YXRpb25zICoqU0hPVUxEIE5PVCoqIHNldCBgbWVzc2FnaW5nLmJhdGNoLm1lc3NhZ2VfY291bnRgIG9uIHNwYW5zIHRoYXQgb3BlcmF0ZSB3aXRoIGEgc2luZ2xlIG1lc3NhZ2UuIFdoZW4gYSBtZXNzYWdpbmcgY2xpZW50IGxpYnJhcnkgc3VwcG9ydHMgYm90aCBiYXRjaCBhbmQgc2luZ2xlLW1lc3NhZ2UgQVBJIGZvciB0aGUgc2FtZSBvcGVyYXRpb24sIGluc3RydW1lbnRhdGlvbnMgKipTSE9VTEQqKiB1c2UgYG1lc3NhZ2luZy5iYXRjaC5tZXNzYWdlX2NvdW50YCBmb3IgYmF0Y2hpbmcgQVBJcyBhbmQgKipTSE9VTEQgTk9UKiogdXNlIGl0IGZvciBzaW5nbGUtbWVzc2FnZSBBUElzLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBhdHRyaWJ1dGUgaXMgZXhwZXJpbWVudGFsIGFuZCBpcyBzdWJqZWN0IHRvIGJyZWFraW5nIGNoYW5nZXMgaW4gbWlub3IgcmVsZWFzZXMgb2YgYEBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zYC5cbiAqL1xuZXhwb3J0cy5BVFRSX01FU1NBR0lOR19CQVRDSF9NRVNTQUdFX0NPVU5UID0gJ21lc3NhZ2luZy5iYXRjaC5tZXNzYWdlX2NvdW50Jztcbi8qKlxuICogVGhlIG1lc3NhZ2UgZGVzdGluYXRpb24gbmFtZVxuICpcbiAqIEBleGFtcGxlIE15UXVldWVcbiAqIEBleGFtcGxlIE15VG9waWNcbiAqXG4gKiBAbm90ZSBEZXN0aW5hdGlvbiBuYW1lICoqU0hPVUxEKiogdW5pcXVlbHkgaWRlbnRpZnkgYSBzcGVjaWZpYyBxdWV1ZSwgdG9waWMgb3Igb3RoZXIgZW50aXR5IHdpdGhpbiB0aGUgYnJva2VyLiBJZlxuICogdGhlIGJyb2tlciBkb2Vzbid0IGhhdmUgc3VjaCBub3Rpb24sIHRoZSBkZXN0aW5hdGlvbiBuYW1lICoqU0hPVUxEKiogdW5pcXVlbHkgaWRlbnRpZnkgdGhlIGJyb2tlci5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgYXR0cmlidXRlIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXMgc3ViamVjdCB0byBicmVha2luZyBjaGFuZ2VzIGluIG1pbm9yIHJlbGVhc2VzIG9mIGBAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc2AuXG4gKi9cbmV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fTkFNRSA9ICdtZXNzYWdpbmcuZGVzdGluYXRpb24ubmFtZSc7XG4vKipcbiAqIFRoZSBpZGVudGlmaWVyIG9mIHRoZSBwYXJ0aXRpb24gbWVzc2FnZXMgYXJlIHNlbnQgdG8gb3IgcmVjZWl2ZWQgZnJvbSwgdW5pcXVlIHdpdGhpbiB0aGUgYG1lc3NhZ2luZy5kZXN0aW5hdGlvbi5uYW1lYC5cbiAqXG4gKiBAZXhhbXBsZSBcIjFcIlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBhdHRyaWJ1dGUgaXMgZXhwZXJpbWVudGFsIGFuZCBpcyBzdWJqZWN0IHRvIGJyZWFraW5nIGNoYW5nZXMgaW4gbWlub3IgcmVsZWFzZXMgb2YgYEBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zYC5cbiAqL1xuZXhwb3J0cy5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9QQVJUSVRJT05fSUQgPSAnbWVzc2FnaW5nLmRlc3RpbmF0aW9uLnBhcnRpdGlvbi5pZCc7XG4vKipcbiAqIE1lc3NhZ2Uga2V5cyBpbiBLYWZrYSBhcmUgdXNlZCBmb3IgZ3JvdXBpbmcgYWxpa2UgbWVzc2FnZXMgdG8gZW5zdXJlIHRoZXkncmUgcHJvY2Vzc2VkIG9uIHRoZSBzYW1lIHBhcnRpdGlvbi4gVGhleSBkaWZmZXIgZnJvbSBgbWVzc2FnaW5nLm1lc3NhZ2UuaWRgIGluIHRoYXQgdGhleSdyZSBub3QgdW5pcXVlLiBJZiB0aGUga2V5IGlzIGBudWxsYCwgdGhlIGF0dHJpYnV0ZSAqKk1VU1QgTk9UKiogYmUgc2V0LlxuICpcbiAqIEBleGFtcGxlIFwibXlLZXlcIlxuICpcbiAqIEBub3RlIElmIHRoZSBrZXkgdHlwZSBpcyBub3Qgc3RyaW5nLCBpdCdzIHN0cmluZyByZXByZXNlbnRhdGlvbiBoYXMgdG8gYmUgc3VwcGxpZWQgZm9yIHRoZSBhdHRyaWJ1dGUuIElmIHRoZSBrZXkgaGFzIG5vIHVuYW1iaWd1b3VzLCBjYW5vbmljYWwgc3RyaW5nIGZvcm0sIGRvbid0IGluY2x1ZGUgaXRzIHZhbHVlLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBhdHRyaWJ1dGUgaXMgZXhwZXJpbWVudGFsIGFuZCBpcyBzdWJqZWN0IHRvIGJyZWFraW5nIGNoYW5nZXMgaW4gbWlub3IgcmVsZWFzZXMgb2YgYEBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zYC5cbiAqL1xuZXhwb3J0cy5BVFRSX01FU1NBR0lOR19LQUZLQV9NRVNTQUdFX0tFWSA9ICdtZXNzYWdpbmcua2Fma2EubWVzc2FnZS5rZXknO1xuLyoqXG4gKiBBIGJvb2xlYW4gdGhhdCBpcyB0cnVlIGlmIHRoZSBtZXNzYWdlIGlzIGEgdG9tYnN0b25lLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBhdHRyaWJ1dGUgaXMgZXhwZXJpbWVudGFsIGFuZCBpcyBzdWJqZWN0IHRvIGJyZWFraW5nIGNoYW5nZXMgaW4gbWlub3IgcmVsZWFzZXMgb2YgYEBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zYC5cbiAqL1xuZXhwb3J0cy5BVFRSX01FU1NBR0lOR19LQUZLQV9NRVNTQUdFX1RPTUJTVE9ORSA9ICdtZXNzYWdpbmcua2Fma2EubWVzc2FnZS50b21ic3RvbmUnO1xuLyoqXG4gKiBUaGUgb2Zmc2V0IG9mIGEgcmVjb3JkIGluIHRoZSBjb3JyZXNwb25kaW5nIEthZmthIHBhcnRpdGlvbi5cbiAqXG4gKiBAZXhhbXBsZSA0MlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBhdHRyaWJ1dGUgaXMgZXhwZXJpbWVudGFsIGFuZCBpcyBzdWJqZWN0IHRvIGJyZWFraW5nIGNoYW5nZXMgaW4gbWlub3IgcmVsZWFzZXMgb2YgYEBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zYC5cbiAqL1xuZXhwb3J0cy5BVFRSX01FU1NBR0lOR19LQUZLQV9PRkZTRVQgPSAnbWVzc2FnaW5nLmthZmthLm9mZnNldCc7XG4vKipcbiAqIFRoZSBzeXN0ZW0tc3BlY2lmaWMgbmFtZSBvZiB0aGUgbWVzc2FnaW5nIG9wZXJhdGlvbi5cbiAqXG4gKiBAZXhhbXBsZSBhY2tcbiAqIEBleGFtcGxlIG5hY2tcbiAqIEBleGFtcGxlIHNlbmRcbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgYXR0cmlidXRlIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXMgc3ViamVjdCB0byBicmVha2luZyBjaGFuZ2VzIGluIG1pbm9yIHJlbGVhc2VzIG9mIGBAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc2AuXG4gKi9cbmV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfT1BFUkFUSU9OX05BTUUgPSAnbWVzc2FnaW5nLm9wZXJhdGlvbi5uYW1lJztcbi8qKlxuICogQSBzdHJpbmcgaWRlbnRpZnlpbmcgdGhlIHR5cGUgb2YgdGhlIG1lc3NhZ2luZyBvcGVyYXRpb24uXG4gKlxuICogQG5vdGUgSWYgYSBjdXN0b20gdmFsdWUgaXMgdXNlZCwgaXQgKipNVVNUKiogYmUgb2YgbG93IGNhcmRpbmFsaXR5LlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIGF0dHJpYnV0ZSBpcyBleHBlcmltZW50YWwgYW5kIGlzIHN1YmplY3QgdG8gYnJlYWtpbmcgY2hhbmdlcyBpbiBtaW5vciByZWxlYXNlcyBvZiBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgLlxuICovXG5leHBvcnRzLkFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFID0gJ21lc3NhZ2luZy5vcGVyYXRpb24udHlwZSc7XG4vKipcbiAqIFRoZSBtZXNzYWdpbmcgc3lzdGVtIGFzIGlkZW50aWZpZWQgYnkgdGhlIGNsaWVudCBpbnN0cnVtZW50YXRpb24uXG4gKlxuICogQG5vdGUgVGhlIGFjdHVhbCBtZXNzYWdpbmcgc3lzdGVtIG1heSBkaWZmZXIgZnJvbSB0aGUgb25lIGtub3duIGJ5IHRoZSBjbGllbnQuIEZvciBleGFtcGxlLCB3aGVuIHVzaW5nIEthZmthIGNsaWVudCBsaWJyYXJpZXMgdG8gY29tbXVuaWNhdGUgd2l0aCBBenVyZSBFdmVudCBIdWJzLCB0aGUgYG1lc3NhZ2luZy5zeXN0ZW1gIGlzIHNldCB0byBga2Fma2FgIGJhc2VkIG9uIHRoZSBpbnN0cnVtZW50YXRpb24ncyBiZXN0IGtub3dsZWRnZS5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgYXR0cmlidXRlIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXMgc3ViamVjdCB0byBicmVha2luZyBjaGFuZ2VzIGluIG1pbm9yIHJlbGVhc2VzIG9mIGBAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc2AuXG4gKi9cbmV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfU1lTVEVNID0gJ21lc3NhZ2luZy5zeXN0ZW0nO1xuLyoqXG4gKiBFbnVtIHZhbHVlIFwicHJvY2Vzc1wiIGZvciBhdHRyaWJ1dGUge0BsaW5rIEFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFfS5cbiAqL1xuZXhwb3J0cy5NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEVfVkFMVUVfUFJPQ0VTUyA9ICdwcm9jZXNzJztcbi8qKlxuICogRW51bSB2YWx1ZSBcInJlY2VpdmVcIiBmb3IgYXR0cmlidXRlIHtAbGluayBBVFRSX01FU1NBR0lOR19PUEVSQVRJT05fVFlQRX0uXG4gKi9cbmV4cG9ydHMuTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFX1ZBTFVFX1JFQ0VJVkUgPSAncmVjZWl2ZSc7XG4vKipcbiAqIEVudW0gdmFsdWUgXCJzZW5kXCIgZm9yIGF0dHJpYnV0ZSB7QGxpbmsgQVRUUl9NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEV9LlxuICovXG5leHBvcnRzLk1FU1NBR0lOR19PUEVSQVRJT05fVFlQRV9WQUxVRV9TRU5EID0gJ3NlbmQnO1xuLyoqXG4gKiBFbnVtIHZhbHVlIFwia2Fma2FcIiBmb3IgYXR0cmlidXRlIHtAbGluayBBVFRSX01FU1NBR0lOR19TWVNURU19LlxuICovXG5leHBvcnRzLk1FU1NBR0lOR19TWVNURU1fVkFMVUVfS0FGS0EgPSAna2Fma2EnO1xuLyoqXG4gKiBOdW1iZXIgb2YgbWVzc2FnZXMgdGhhdCB3ZXJlIGRlbGl2ZXJlZCB0byB0aGUgYXBwbGljYXRpb24uXG4gKlxuICogQG5vdGUgUmVjb3JkcyB0aGUgbnVtYmVyIG9mIG1lc3NhZ2VzIHB1bGxlZCBmcm9tIHRoZSBicm9rZXIgb3IgbnVtYmVyIG9mIG1lc3NhZ2VzIGRpc3BhdGNoZWQgdG8gdGhlIGFwcGxpY2F0aW9uIGluIHB1c2gtYmFzZWQgc2NlbmFyaW9zLlxuICogVGhlIG1ldHJpYyAqKlNIT1VMRCoqIGJlIHJlcG9ydGVkIG9uY2UgcGVyIG1lc3NhZ2UgZGVsaXZlcnkuIEZvciBleGFtcGxlLCBpZiByZWNlaXZpbmcgYW5kIHByb2Nlc3Npbmcgb3BlcmF0aW9ucyBhcmUgYm90aCBpbnN0cnVtZW50ZWQgZm9yIGEgc2luZ2xlIG1lc3NhZ2UgZGVsaXZlcnksIHRoaXMgY291bnRlciBpcyBpbmNyZW1lbnRlZCB3aGVuIHRoZSBtZXNzYWdlIGlzIHJlY2VpdmVkIGFuZCBub3QgcmVwb3J0ZWQgd2hlbiBpdCBpcyBwcm9jZXNzZWQuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIG1ldHJpYyBpcyBleHBlcmltZW50YWwgYW5kIGlzIHN1YmplY3QgdG8gYnJlYWtpbmcgY2hhbmdlcyBpbiBtaW5vciByZWxlYXNlcyBvZiBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgLlxuICovXG5leHBvcnRzLk1FVFJJQ19NRVNTQUdJTkdfQ0xJRU5UX0NPTlNVTUVEX01FU1NBR0VTID0gJ21lc3NhZ2luZy5jbGllbnQuY29uc3VtZWQubWVzc2FnZXMnO1xuLyoqXG4gKiBEdXJhdGlvbiBvZiBtZXNzYWdpbmcgb3BlcmF0aW9uIGluaXRpYXRlZCBieSBhIHByb2R1Y2VyIG9yIGNvbnN1bWVyIGNsaWVudC5cbiAqXG4gKiBAbm90ZSBUaGlzIG1ldHJpYyAqKlNIT1VMRCBOT1QqKiBiZSB1c2VkIHRvIHJlcG9ydCBwcm9jZXNzaW5nIGR1cmF0aW9uIC0gcHJvY2Vzc2luZyBkdXJhdGlvbiBpcyByZXBvcnRlZCBpbiBgbWVzc2FnaW5nLnByb2Nlc3MuZHVyYXRpb25gIG1ldHJpYy5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgbWV0cmljIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXMgc3ViamVjdCB0byBicmVha2luZyBjaGFuZ2VzIGluIG1pbm9yIHJlbGVhc2VzIG9mIGBAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc2AuXG4gKi9cbmV4cG9ydHMuTUVUUklDX01FU1NBR0lOR19DTElFTlRfT1BFUkFUSU9OX0RVUkFUSU9OID0gJ21lc3NhZ2luZy5jbGllbnQub3BlcmF0aW9uLmR1cmF0aW9uJztcbi8qKlxuICogTnVtYmVyIG9mIG1lc3NhZ2VzIHByb2R1Y2VyIGF0dGVtcHRlZCB0byBzZW5kIHRvIHRoZSBicm9rZXIuXG4gKlxuICogQG5vdGUgVGhpcyBtZXRyaWMgKipNVVNUIE5PVCoqIGNvdW50IG1lc3NhZ2VzIHRoYXQgd2VyZSBjcmVhdGVkIGJ1dCBoYXZlbid0IHlldCBiZWVuIHNlbnQuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIG1ldHJpYyBpcyBleHBlcmltZW50YWwgYW5kIGlzIHN1YmplY3QgdG8gYnJlYWtpbmcgY2hhbmdlcyBpbiBtaW5vciByZWxlYXNlcyBvZiBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgLlxuICovXG5leHBvcnRzLk1FVFJJQ19NRVNTQUdJTkdfQ0xJRU5UX1NFTlRfTUVTU0FHRVMgPSAnbWVzc2FnaW5nLmNsaWVudC5zZW50Lm1lc3NhZ2VzJztcbi8qKlxuICogRHVyYXRpb24gb2YgcHJvY2Vzc2luZyBvcGVyYXRpb24uXG4gKlxuICogQG5vdGUgVGhpcyBtZXRyaWMgKipNVVNUKiogYmUgcmVwb3J0ZWQgZm9yIG9wZXJhdGlvbnMgd2l0aCBgbWVzc2FnaW5nLm9wZXJhdGlvbi50eXBlYCB0aGF0IG1hdGNoZXMgYHByb2Nlc3NgLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBtZXRyaWMgaXMgZXhwZXJpbWVudGFsIGFuZCBpcyBzdWJqZWN0IHRvIGJyZWFraW5nIGNoYW5nZXMgaW4gbWlub3IgcmVsZWFzZXMgb2YgYEBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zYC5cbiAqL1xuZXhwb3J0cy5NRVRSSUNfTUVTU0FHSU5HX1BST0NFU1NfRFVSQVRJT04gPSAnbWVzc2FnaW5nLnByb2Nlc3MuZHVyYXRpb24nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VtY29udi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/semconv.js\n");

/***/ }),

/***/ "(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/version.js":
/*!********************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/version.js ***!
  \********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;\n// this is autogenerated file, see scripts/version-update.js\nexports.PACKAGE_VERSION = '0.14.0';\nexports.PACKAGE_NAME = '@opentelemetry/instrumentation-kafkajs';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24ta2Fma2Fqc0AwLjE0LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24ta2Fma2Fqcy9idWlsZC9zcmMvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyx1QkFBdUI7QUFDOUM7QUFDQSx1QkFBdUI7QUFDdkIsb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyIvVXNlcnMvY29keWRlYXJrbGFuZC9zZW50cnl2aWJlL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24ta2Fma2Fqc0AwLjE0LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24ta2Fma2Fqcy9idWlsZC9zcmMvdmVyc2lvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBBQ0tBR0VfTkFNRSA9IGV4cG9ydHMuUEFDS0FHRV9WRVJTSU9OID0gdm9pZCAwO1xuLy8gdGhpcyBpcyBhdXRvZ2VuZXJhdGVkIGZpbGUsIHNlZSBzY3JpcHRzL3ZlcnNpb24tdXBkYXRlLmpzXG5leHBvcnRzLlBBQ0tBR0VfVkVSU0lPTiA9ICcwLjE0LjAnO1xuZXhwb3J0cy5QQUNLQUdFX05BTUUgPSAnQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWthZmthanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/version.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/index.js":
/*!******************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/index.js ***!
  \******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors, Aspecto\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.KafkaJsInstrumentation = void 0;\nvar instrumentation_1 = __webpack_require__(/*! ./instrumentation */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/instrumentation.js\");\nObject.defineProperty(exports, \"KafkaJsInstrumentation\", ({ enumerable: true, get: function () { return instrumentation_1.KafkaJsInstrumentation; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTQuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEI7QUFDOUIsd0JBQXdCLG1CQUFPLENBQUMsaU5BQW1CO0FBQ25ELDBEQUF5RCxFQUFFLHFDQUFxQyxvREFBb0QsRUFBQztBQUNySiIsInNvdXJjZXMiOlsiL1VzZXJzL2NvZHlkZWFya2xhbmQvc2VudHJ5dmliZS9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWthZmthanNAMC4xNC4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWthZmthanMvYnVpbGQvc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBUaGUgT3BlblRlbGVtZXRyeSBBdXRob3JzLCBBc3BlY3RvXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuS2Fma2FKc0luc3RydW1lbnRhdGlvbiA9IHZvaWQgMDtcbnZhciBpbnN0cnVtZW50YXRpb25fMSA9IHJlcXVpcmUoXCIuL2luc3RydW1lbnRhdGlvblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkthZmthSnNJbnN0cnVtZW50YXRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluc3RydW1lbnRhdGlvbl8xLkthZmthSnNJbnN0cnVtZW50YXRpb247IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/instrumentation.js":
/*!****************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/instrumentation.js ***!
  \****************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval(";globalThis[\"_sentryRewritesTunnelPath\"] = undefined;globalThis[\"SENTRY_RELEASE\"] = undefined;globalThis[\"_sentryBasePath\"] = undefined;globalThis[\"_sentryNextJsVersion\"] = \"15.5.4\";globalThis[\"_sentryRewriteFramesDistDir\"] = \".next\";\n/*\n * Copyright The OpenTelemetry Authors, Aspecto\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.KafkaJsInstrumentation = void 0;\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst instrumentation_1 = __webpack_require__(/*! @opentelemetry/instrumentation */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation@0.204.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation/build/esm/index.js\");\nconst semantic_conventions_1 = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.37.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nconst internal_types_1 = __webpack_require__(/*! ./internal-types */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/internal-types.js\");\nconst propagator_1 = __webpack_require__(/*! ./propagator */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/propagator.js\");\nconst semconv_1 = __webpack_require__(/*! ./semconv */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/semconv.js\");\n/** @knipignore */\nconst version_1 = __webpack_require__(/*! ./version */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/version.js\");\nfunction prepareCounter(meter, value, attributes) {\n    return (errorType) => {\n        meter.add(value, {\n            ...attributes,\n            ...(errorType ? { [semantic_conventions_1.ATTR_ERROR_TYPE]: errorType } : {}),\n        });\n    };\n}\nfunction prepareDurationHistogram(meter, value, attributes) {\n    return (errorType) => {\n        meter.record((Date.now() - value) / 1000, {\n            ...attributes,\n            ...(errorType ? { [semantic_conventions_1.ATTR_ERROR_TYPE]: errorType } : {}),\n        });\n    };\n}\nconst HISTOGRAM_BUCKET_BOUNDARIES = [\n    0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 2.5, 5, 7.5, 10,\n];\nclass KafkaJsInstrumentation extends instrumentation_1.InstrumentationBase {\n    constructor(config = {}) {\n        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);\n    }\n    _updateMetricInstruments() {\n        this._clientDuration = this.meter.createHistogram(semconv_1.METRIC_MESSAGING_CLIENT_OPERATION_DURATION, { advice: { explicitBucketBoundaries: HISTOGRAM_BUCKET_BOUNDARIES } });\n        this._sentMessages = this.meter.createCounter(semconv_1.METRIC_MESSAGING_CLIENT_SENT_MESSAGES);\n        this._consumedMessages = this.meter.createCounter(semconv_1.METRIC_MESSAGING_CLIENT_CONSUMED_MESSAGES);\n        this._processDuration = this.meter.createHistogram(semconv_1.METRIC_MESSAGING_PROCESS_DURATION, { advice: { explicitBucketBoundaries: HISTOGRAM_BUCKET_BOUNDARIES } });\n    }\n    init() {\n        const unpatch = (moduleExports) => {\n            if ((0, instrumentation_1.isWrapped)(moduleExports?.Kafka?.prototype.producer)) {\n                this._unwrap(moduleExports.Kafka.prototype, 'producer');\n            }\n            if ((0, instrumentation_1.isWrapped)(moduleExports?.Kafka?.prototype.consumer)) {\n                this._unwrap(moduleExports.Kafka.prototype, 'consumer');\n            }\n        };\n        const module = new instrumentation_1.InstrumentationNodeModuleDefinition('kafkajs', ['>=0.3.0 <3'], (moduleExports) => {\n            unpatch(moduleExports);\n            this._wrap(moduleExports?.Kafka?.prototype, 'producer', this._getProducerPatch());\n            this._wrap(moduleExports?.Kafka?.prototype, 'consumer', this._getConsumerPatch());\n            return moduleExports;\n        }, unpatch);\n        return module;\n    }\n    _getConsumerPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function consumer(...args) {\n                const newConsumer = original.apply(this, args);\n                if ((0, instrumentation_1.isWrapped)(newConsumer.run)) {\n                    instrumentation._unwrap(newConsumer, 'run');\n                }\n                instrumentation._wrap(newConsumer, 'run', instrumentation._getConsumerRunPatch());\n                instrumentation._setKafkaEventListeners(newConsumer);\n                return newConsumer;\n            };\n        };\n    }\n    _setKafkaEventListeners(kafkaObj) {\n        if (kafkaObj[internal_types_1.EVENT_LISTENERS_SET])\n            return;\n        // The REQUEST Consumer event was added in kafkajs@1.5.0.\n        if (kafkaObj.events?.REQUEST) {\n            kafkaObj.on(kafkaObj.events.REQUEST, this._recordClientDurationMetric.bind(this));\n        }\n        kafkaObj[internal_types_1.EVENT_LISTENERS_SET] = true;\n    }\n    _recordClientDurationMetric(event) {\n        const [address, port] = event.payload.broker.split(':');\n        this._clientDuration.record(event.payload.duration / 1000, {\n            [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n            [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: `${event.payload.apiName}`,\n            [semantic_conventions_1.ATTR_SERVER_ADDRESS]: address,\n            [semantic_conventions_1.ATTR_SERVER_PORT]: Number.parseInt(port, 10),\n        });\n    }\n    _getProducerPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function consumer(...args) {\n                const newProducer = original.apply(this, args);\n                if ((0, instrumentation_1.isWrapped)(newProducer.sendBatch)) {\n                    instrumentation._unwrap(newProducer, 'sendBatch');\n                }\n                instrumentation._wrap(newProducer, 'sendBatch', instrumentation._getSendBatchPatch());\n                if ((0, instrumentation_1.isWrapped)(newProducer.send)) {\n                    instrumentation._unwrap(newProducer, 'send');\n                }\n                instrumentation._wrap(newProducer, 'send', instrumentation._getSendPatch());\n                if ((0, instrumentation_1.isWrapped)(newProducer.transaction)) {\n                    instrumentation._unwrap(newProducer, 'transaction');\n                }\n                instrumentation._wrap(newProducer, 'transaction', instrumentation._getProducerTransactionPatch());\n                instrumentation._setKafkaEventListeners(newProducer);\n                return newProducer;\n            };\n        };\n    }\n    _getConsumerRunPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function run(...args) {\n                const config = args[0];\n                if (config?.eachMessage) {\n                    if ((0, instrumentation_1.isWrapped)(config.eachMessage)) {\n                        instrumentation._unwrap(config, 'eachMessage');\n                    }\n                    instrumentation._wrap(config, 'eachMessage', instrumentation._getConsumerEachMessagePatch());\n                }\n                if (config?.eachBatch) {\n                    if ((0, instrumentation_1.isWrapped)(config.eachBatch)) {\n                        instrumentation._unwrap(config, 'eachBatch');\n                    }\n                    instrumentation._wrap(config, 'eachBatch', instrumentation._getConsumerEachBatchPatch());\n                }\n                return original.call(this, config);\n            };\n        };\n    }\n    _getConsumerEachMessagePatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function eachMessage(...args) {\n                const payload = args[0];\n                const propagatedContext = api_1.propagation.extract(api_1.ROOT_CONTEXT, payload.message.headers, propagator_1.bufferTextMapGetter);\n                const span = instrumentation._startConsumerSpan({\n                    topic: payload.topic,\n                    message: payload.message,\n                    operationType: semconv_1.MESSAGING_OPERATION_TYPE_VALUE_PROCESS,\n                    ctx: propagatedContext,\n                    attributes: {\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.partition),\n                    },\n                });\n                const pendingMetrics = [\n                    prepareDurationHistogram(instrumentation._processDuration, Date.now(), {\n                        [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                        [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'process',\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: payload.topic,\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.partition),\n                    }),\n                    prepareCounter(instrumentation._consumedMessages, 1, {\n                        [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                        [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'process',\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: payload.topic,\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.partition),\n                    }),\n                ];\n                const eachMessagePromise = api_1.context.with(api_1.trace.setSpan(propagatedContext, span), () => {\n                    return original.apply(this, args);\n                });\n                return instrumentation._endSpansOnPromise([span], pendingMetrics, eachMessagePromise);\n            };\n        };\n    }\n    _getConsumerEachBatchPatch() {\n        return (original) => {\n            const instrumentation = this;\n            return function eachBatch(...args) {\n                const payload = args[0];\n                // https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/messaging.md#topic-with-multiple-consumers\n                const receivingSpan = instrumentation._startConsumerSpan({\n                    topic: payload.batch.topic,\n                    message: undefined,\n                    operationType: semconv_1.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE,\n                    ctx: api_1.ROOT_CONTEXT,\n                    attributes: {\n                        [semconv_1.ATTR_MESSAGING_BATCH_MESSAGE_COUNT]: payload.batch.messages.length,\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.batch.partition),\n                    },\n                });\n                return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), receivingSpan), () => {\n                    const startTime = Date.now();\n                    const spans = [];\n                    const pendingMetrics = [\n                        prepareCounter(instrumentation._consumedMessages, payload.batch.messages.length, {\n                            [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                            [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'process',\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: payload.batch.topic,\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.batch.partition),\n                        }),\n                    ];\n                    payload.batch.messages.forEach(message => {\n                        const propagatedContext = api_1.propagation.extract(api_1.ROOT_CONTEXT, message.headers, propagator_1.bufferTextMapGetter);\n                        const spanContext = api_1.trace\n                            .getSpan(propagatedContext)\n                            ?.spanContext();\n                        let origSpanLink;\n                        if (spanContext) {\n                            origSpanLink = {\n                                context: spanContext,\n                            };\n                        }\n                        spans.push(instrumentation._startConsumerSpan({\n                            topic: payload.batch.topic,\n                            message,\n                            operationType: semconv_1.MESSAGING_OPERATION_TYPE_VALUE_PROCESS,\n                            link: origSpanLink,\n                            attributes: {\n                                [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.batch.partition),\n                            },\n                        }));\n                        pendingMetrics.push(prepareDurationHistogram(instrumentation._processDuration, startTime, {\n                            [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                            [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'process',\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: payload.batch.topic,\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.batch.partition),\n                        }));\n                    });\n                    const batchMessagePromise = original.apply(this, args);\n                    spans.unshift(receivingSpan);\n                    return instrumentation._endSpansOnPromise(spans, pendingMetrics, batchMessagePromise);\n                });\n            };\n        };\n    }\n    _getProducerTransactionPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function transaction(...args) {\n                const transactionSpan = instrumentation.tracer.startSpan('transaction');\n                const transactionPromise = original.apply(this, args);\n                transactionPromise\n                    .then((transaction) => {\n                    const originalSend = transaction.send;\n                    transaction.send = function send(...args) {\n                        return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), transactionSpan), () => {\n                            const patched = instrumentation._getSendPatch()(originalSend);\n                            return patched.apply(this, args).catch(err => {\n                                transactionSpan.setStatus({\n                                    code: api_1.SpanStatusCode.ERROR,\n                                    message: err?.message,\n                                });\n                                transactionSpan.recordException(err);\n                                throw err;\n                            });\n                        });\n                    };\n                    const originalSendBatch = transaction.sendBatch;\n                    transaction.sendBatch = function sendBatch(...args) {\n                        return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), transactionSpan), () => {\n                            const patched = instrumentation._getSendBatchPatch()(originalSendBatch);\n                            return patched.apply(this, args).catch(err => {\n                                transactionSpan.setStatus({\n                                    code: api_1.SpanStatusCode.ERROR,\n                                    message: err?.message,\n                                });\n                                transactionSpan.recordException(err);\n                                throw err;\n                            });\n                        });\n                    };\n                    const originalCommit = transaction.commit;\n                    transaction.commit = function commit(...args) {\n                        const originCommitPromise = originalCommit\n                            .apply(this, args)\n                            .then(() => {\n                            transactionSpan.setStatus({ code: api_1.SpanStatusCode.OK });\n                        });\n                        return instrumentation._endSpansOnPromise([transactionSpan], [], originCommitPromise);\n                    };\n                    const originalAbort = transaction.abort;\n                    transaction.abort = function abort(...args) {\n                        const originAbortPromise = originalAbort.apply(this, args);\n                        return instrumentation._endSpansOnPromise([transactionSpan], [], originAbortPromise);\n                    };\n                })\n                    .catch(err => {\n                    transactionSpan.setStatus({\n                        code: api_1.SpanStatusCode.ERROR,\n                        message: err?.message,\n                    });\n                    transactionSpan.recordException(err);\n                    transactionSpan.end();\n                });\n                return transactionPromise;\n            };\n        };\n    }\n    _getSendBatchPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function sendBatch(...args) {\n                const batch = args[0];\n                const messages = batch.topicMessages || [];\n                const spans = [];\n                const pendingMetrics = [];\n                messages.forEach(topicMessage => {\n                    topicMessage.messages.forEach(message => {\n                        spans.push(instrumentation._startProducerSpan(topicMessage.topic, message));\n                        pendingMetrics.push(prepareCounter(instrumentation._sentMessages, 1, {\n                            [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                            [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'send',\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: topicMessage.topic,\n                            ...(message.partition !== undefined\n                                ? {\n                                    [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(message.partition),\n                                }\n                                : {}),\n                        }));\n                    });\n                });\n                const origSendResult = original.apply(this, args);\n                return instrumentation._endSpansOnPromise(spans, pendingMetrics, origSendResult);\n            };\n        };\n    }\n    _getSendPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function send(...args) {\n                const record = args[0];\n                const spans = record.messages.map(message => {\n                    return instrumentation._startProducerSpan(record.topic, message);\n                });\n                const pendingMetrics = record.messages.map(m => prepareCounter(instrumentation._sentMessages, 1, {\n                    [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                    [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'send',\n                    [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: record.topic,\n                    ...(m.partition !== undefined\n                        ? {\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(m.partition),\n                        }\n                        : {}),\n                }));\n                const origSendResult = original.apply(this, args);\n                return instrumentation._endSpansOnPromise(spans, pendingMetrics, origSendResult);\n            };\n        };\n    }\n    _endSpansOnPromise(spans, pendingMetrics, sendPromise) {\n        return Promise.resolve(sendPromise)\n            .then(result => {\n            pendingMetrics.forEach(m => m());\n            return result;\n        })\n            .catch(reason => {\n            let errorMessage;\n            let errorType = semantic_conventions_1.ERROR_TYPE_VALUE_OTHER;\n            if (typeof reason === 'string' || reason === undefined) {\n                errorMessage = reason;\n            }\n            else if (typeof reason === 'object' &&\n                Object.prototype.hasOwnProperty.call(reason, 'message')) {\n                errorMessage = reason.message;\n                errorType = reason.constructor.name;\n            }\n            pendingMetrics.forEach(m => m(errorType));\n            spans.forEach(span => {\n                span.setAttribute(semantic_conventions_1.ATTR_ERROR_TYPE, errorType);\n                span.setStatus({\n                    code: api_1.SpanStatusCode.ERROR,\n                    message: errorMessage,\n                });\n            });\n            throw reason;\n        })\n            .finally(() => {\n            spans.forEach(span => span.end());\n        });\n    }\n    _startConsumerSpan({ topic, message, operationType, ctx, link, attributes, }) {\n        const operationName = operationType === semconv_1.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE\n            ? 'poll' // for batch processing spans\n            : operationType; // for individual message processing spans\n        const span = this.tracer.startSpan(`${operationName} ${topic}`, {\n            kind: operationType === semconv_1.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE\n                ? api_1.SpanKind.CLIENT\n                : api_1.SpanKind.CONSUMER,\n            attributes: {\n                ...attributes,\n                [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: topic,\n                [semconv_1.ATTR_MESSAGING_OPERATION_TYPE]: operationType,\n                [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: operationName,\n                [semconv_1.ATTR_MESSAGING_KAFKA_MESSAGE_KEY]: message?.key\n                    ? String(message.key)\n                    : undefined,\n                [semconv_1.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE]: message?.key && message.value === null ? true : undefined,\n                [semconv_1.ATTR_MESSAGING_KAFKA_OFFSET]: message?.offset,\n            },\n            links: link ? [link] : [],\n        }, ctx);\n        const { consumerHook } = this.getConfig();\n        if (consumerHook && message) {\n            (0, instrumentation_1.safeExecuteInTheMiddle)(() => consumerHook(span, { topic, message }), e => {\n                if (e)\n                    this._diag.error('consumerHook error', e);\n            }, true);\n        }\n        return span;\n    }\n    _startProducerSpan(topic, message) {\n        const span = this.tracer.startSpan(`send ${topic}`, {\n            kind: api_1.SpanKind.PRODUCER,\n            attributes: {\n                [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: topic,\n                [semconv_1.ATTR_MESSAGING_KAFKA_MESSAGE_KEY]: message.key\n                    ? String(message.key)\n                    : undefined,\n                [semconv_1.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE]: message.key && message.value === null ? true : undefined,\n                [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: message.partition !== undefined\n                    ? String(message.partition)\n                    : undefined,\n                [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'send',\n                [semconv_1.ATTR_MESSAGING_OPERATION_TYPE]: semconv_1.MESSAGING_OPERATION_TYPE_VALUE_SEND,\n            },\n        });\n        message.headers = message.headers ?? {};\n        api_1.propagation.inject(api_1.trace.setSpan(api_1.context.active(), span), message.headers);\n        const { producerHook } = this.getConfig();\n        if (producerHook) {\n            (0, instrumentation_1.safeExecuteInTheMiddle)(() => producerHook(span, { topic, message }), e => {\n                if (e)\n                    this._diag.error('producerHook error', e);\n            }, true);\n        }\n        return span;\n    }\n}\nexports.KafkaJsInstrumentation = KafkaJsInstrumentation;\n//# sourceMappingURL=instrumentation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTQuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy9pbnN0cnVtZW50YXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWEsQ0FBQyxvREFBb0QseUNBQXlDLDBDQUEwQyw4Q0FBOEM7QUFDbk07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QjtBQUM5QixjQUFjLG1CQUFPLENBQUMsc0lBQW9CO0FBQzFDLDBCQUEwQixtQkFBTyxDQUFDLHFNQUFnQztBQUNsRSwrQkFBK0IsbUJBQU8sQ0FBQywwTEFBcUM7QUFDNUUseUJBQXlCLG1CQUFPLENBQUMsK01BQWtCO0FBQ25ELHFCQUFxQixtQkFBTyxDQUFDLHVNQUFjO0FBQzNDLGtCQUFrQixtQkFBTyxDQUFDLGlNQUFXO0FBQ3JDO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsaU1BQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0RBQXNELElBQUk7QUFDeEYsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzREFBc0QsSUFBSTtBQUN4RixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGtIQUFrSCxVQUFVLHlEQUF5RDtBQUNyTDtBQUNBO0FBQ0EsMEdBQTBHLFVBQVUseURBQXlEO0FBQzdLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHNCQUFzQjtBQUNoRjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCwrQkFBK0I7QUFDdkYseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHlCQUF5Qix1REFBdUQ7QUFDaEY7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qiw4Q0FBOEMsZUFBZSxFQUFFLE1BQU07QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBLHFGQUFxRixnQkFBZ0I7QUFDckc7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxNQUFNO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQSxxRkFBcUYsZ0JBQWdCO0FBQ3JHO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jb2R5ZGVhcmtsYW5kL3NlbnRyeXZpYmUvbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTQuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy9pbnN0cnVtZW50YXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7O2dsb2JhbFRoaXNbXCJfc2VudHJ5UmV3cml0ZXNUdW5uZWxQYXRoXCJdID0gdW5kZWZpbmVkO2dsb2JhbFRoaXNbXCJTRU5UUllfUkVMRUFTRVwiXSA9IHVuZGVmaW5lZDtnbG9iYWxUaGlzW1wiX3NlbnRyeUJhc2VQYXRoXCJdID0gdW5kZWZpbmVkO2dsb2JhbFRoaXNbXCJfc2VudHJ5TmV4dEpzVmVyc2lvblwiXSA9IFwiMTUuNS40XCI7Z2xvYmFsVGhpc1tcIl9zZW50cnlSZXdyaXRlRnJhbWVzRGlzdERpclwiXSA9IFwiLm5leHRcIjtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9ycywgQXNwZWN0b1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkthZmthSnNJbnN0cnVtZW50YXRpb24gPSB2b2lkIDA7XG5jb25zdCBhcGlfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9hcGlcIik7XG5jb25zdCBpbnN0cnVtZW50YXRpb25fMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb25cIik7XG5jb25zdCBzZW1hbnRpY19jb252ZW50aW9uc18xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zXCIpO1xuY29uc3QgaW50ZXJuYWxfdHlwZXNfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsLXR5cGVzXCIpO1xuY29uc3QgcHJvcGFnYXRvcl8xID0gcmVxdWlyZShcIi4vcHJvcGFnYXRvclwiKTtcbmNvbnN0IHNlbWNvbnZfMSA9IHJlcXVpcmUoXCIuL3NlbWNvbnZcIik7XG4vKiogQGtuaXBpZ25vcmUgKi9cbmNvbnN0IHZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL3ZlcnNpb25cIik7XG5mdW5jdGlvbiBwcmVwYXJlQ291bnRlcihtZXRlciwgdmFsdWUsIGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gKGVycm9yVHlwZSkgPT4ge1xuICAgICAgICBtZXRlci5hZGQodmFsdWUsIHtcbiAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAuLi4oZXJyb3JUeXBlID8geyBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0VSUk9SX1RZUEVdOiBlcnJvclR5cGUgfSA6IHt9KSxcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVEdXJhdGlvbkhpc3RvZ3JhbShtZXRlciwgdmFsdWUsIGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gKGVycm9yVHlwZSkgPT4ge1xuICAgICAgICBtZXRlci5yZWNvcmQoKERhdGUubm93KCkgLSB2YWx1ZSkgLyAxMDAwLCB7XG4gICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgLi4uKGVycm9yVHlwZSA/IHsgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9FUlJPUl9UWVBFXTogZXJyb3JUeXBlIH0gOiB7fSksXG4gICAgICAgIH0pO1xuICAgIH07XG59XG5jb25zdCBISVNUT0dSQU1fQlVDS0VUX0JPVU5EQVJJRVMgPSBbXG4gICAgMC4wMDUsIDAuMDEsIDAuMDI1LCAwLjA1LCAwLjA3NSwgMC4xLCAwLjI1LCAwLjUsIDAuNzUsIDEsIDIuNSwgNSwgNy41LCAxMCxcbl07XG5jbGFzcyBLYWZrYUpzSW5zdHJ1bWVudGF0aW9uIGV4dGVuZHMgaW5zdHJ1bWVudGF0aW9uXzEuSW5zdHJ1bWVudGF0aW9uQmFzZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgc3VwZXIodmVyc2lvbl8xLlBBQ0tBR0VfTkFNRSwgdmVyc2lvbl8xLlBBQ0tBR0VfVkVSU0lPTiwgY29uZmlnKTtcbiAgICB9XG4gICAgX3VwZGF0ZU1ldHJpY0luc3RydW1lbnRzKCkge1xuICAgICAgICB0aGlzLl9jbGllbnREdXJhdGlvbiA9IHRoaXMubWV0ZXIuY3JlYXRlSGlzdG9ncmFtKHNlbWNvbnZfMS5NRVRSSUNfTUVTU0FHSU5HX0NMSUVOVF9PUEVSQVRJT05fRFVSQVRJT04sIHsgYWR2aWNlOiB7IGV4cGxpY2l0QnVja2V0Qm91bmRhcmllczogSElTVE9HUkFNX0JVQ0tFVF9CT1VOREFSSUVTIH0gfSk7XG4gICAgICAgIHRoaXMuX3NlbnRNZXNzYWdlcyA9IHRoaXMubWV0ZXIuY3JlYXRlQ291bnRlcihzZW1jb252XzEuTUVUUklDX01FU1NBR0lOR19DTElFTlRfU0VOVF9NRVNTQUdFUyk7XG4gICAgICAgIHRoaXMuX2NvbnN1bWVkTWVzc2FnZXMgPSB0aGlzLm1ldGVyLmNyZWF0ZUNvdW50ZXIoc2VtY29udl8xLk1FVFJJQ19NRVNTQUdJTkdfQ0xJRU5UX0NPTlNVTUVEX01FU1NBR0VTKTtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc0R1cmF0aW9uID0gdGhpcy5tZXRlci5jcmVhdGVIaXN0b2dyYW0oc2VtY29udl8xLk1FVFJJQ19NRVNTQUdJTkdfUFJPQ0VTU19EVVJBVElPTiwgeyBhZHZpY2U6IHsgZXhwbGljaXRCdWNrZXRCb3VuZGFyaWVzOiBISVNUT0dSQU1fQlVDS0VUX0JPVU5EQVJJRVMgfSB9KTtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgY29uc3QgdW5wYXRjaCA9IChtb2R1bGVFeHBvcnRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cz8uS2Fma2E/LnByb3RvdHlwZS5wcm9kdWNlcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5LYWZrYS5wcm90b3R5cGUsICdwcm9kdWNlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHM/LkthZmthPy5wcm90b3R5cGUuY29uc3VtZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMuS2Fma2EucHJvdG90eXBlLCAnY29uc3VtZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbW9kdWxlID0gbmV3IGluc3RydW1lbnRhdGlvbl8xLkluc3RydW1lbnRhdGlvbk5vZGVNb2R1bGVEZWZpbml0aW9uKCdrYWZrYWpzJywgWyc+PTAuMy4wIDwzJ10sIChtb2R1bGVFeHBvcnRzKSA9PiB7XG4gICAgICAgICAgICB1bnBhdGNoKG1vZHVsZUV4cG9ydHMpO1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzPy5LYWZrYT8ucHJvdG90eXBlLCAncHJvZHVjZXInLCB0aGlzLl9nZXRQcm9kdWNlclBhdGNoKCkpO1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzPy5LYWZrYT8ucHJvdG90eXBlLCAnY29uc3VtZXInLCB0aGlzLl9nZXRDb25zdW1lclBhdGNoKCkpO1xuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZUV4cG9ydHM7XG4gICAgICAgIH0sIHVucGF0Y2gpO1xuICAgICAgICByZXR1cm4gbW9kdWxlO1xuICAgIH1cbiAgICBfZ2V0Q29uc3VtZXJQYXRjaCgpIHtcbiAgICAgICAgY29uc3QgaW5zdHJ1bWVudGF0aW9uID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChvcmlnaW5hbCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNvbnN1bWVyKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDb25zdW1lciA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShuZXdDb25zdW1lci5ydW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fdW53cmFwKG5ld0NvbnN1bWVyLCAncnVuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fd3JhcChuZXdDb25zdW1lciwgJ3J1bicsIGluc3RydW1lbnRhdGlvbi5fZ2V0Q29uc3VtZXJSdW5QYXRjaCgpKTtcbiAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX3NldEthZmthRXZlbnRMaXN0ZW5lcnMobmV3Q29uc3VtZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdDb25zdW1lcjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9zZXRLYWZrYUV2ZW50TGlzdGVuZXJzKGthZmthT2JqKSB7XG4gICAgICAgIGlmIChrYWZrYU9ialtpbnRlcm5hbF90eXBlc18xLkVWRU5UX0xJU1RFTkVSU19TRVRdKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBUaGUgUkVRVUVTVCBDb25zdW1lciBldmVudCB3YXMgYWRkZWQgaW4ga2Fma2Fqc0AxLjUuMC5cbiAgICAgICAgaWYgKGthZmthT2JqLmV2ZW50cz8uUkVRVUVTVCkge1xuICAgICAgICAgICAga2Fma2FPYmoub24oa2Fma2FPYmouZXZlbnRzLlJFUVVFU1QsIHRoaXMuX3JlY29yZENsaWVudER1cmF0aW9uTWV0cmljLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIGthZmthT2JqW2ludGVybmFsX3R5cGVzXzEuRVZFTlRfTElTVEVORVJTX1NFVF0gPSB0cnVlO1xuICAgIH1cbiAgICBfcmVjb3JkQ2xpZW50RHVyYXRpb25NZXRyaWMoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgW2FkZHJlc3MsIHBvcnRdID0gZXZlbnQucGF5bG9hZC5icm9rZXIuc3BsaXQoJzonKTtcbiAgICAgICAgdGhpcy5fY2xpZW50RHVyYXRpb24ucmVjb3JkKGV2ZW50LnBheWxvYWQuZHVyYXRpb24gLyAxMDAwLCB7XG4gICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX1NZU1RFTV06IHNlbWNvbnZfMS5NRVNTQUdJTkdfU1lTVEVNX1ZBTFVFX0tBRktBLFxuICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fTkFNRV06IGAke2V2ZW50LnBheWxvYWQuYXBpTmFtZX1gLFxuICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9TRVJWRVJfQUREUkVTU106IGFkZHJlc3MsXG4gICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1NFUlZFUl9QT1JUXTogTnVtYmVyLnBhcnNlSW50KHBvcnQsIDEwKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRQcm9kdWNlclBhdGNoKCkge1xuICAgICAgICBjb25zdCBpbnN0cnVtZW50YXRpb24gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKG9yaWdpbmFsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY29uc3VtZXIoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Byb2R1Y2VyID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG5ld1Byb2R1Y2VyLnNlbmRCYXRjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl91bndyYXAobmV3UHJvZHVjZXIsICdzZW5kQmF0Y2gnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl93cmFwKG5ld1Byb2R1Y2VyLCAnc2VuZEJhdGNoJywgaW5zdHJ1bWVudGF0aW9uLl9nZXRTZW5kQmF0Y2hQYXRjaCgpKTtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobmV3UHJvZHVjZXIuc2VuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl91bndyYXAobmV3UHJvZHVjZXIsICdzZW5kJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fd3JhcChuZXdQcm9kdWNlciwgJ3NlbmQnLCBpbnN0cnVtZW50YXRpb24uX2dldFNlbmRQYXRjaCgpKTtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobmV3UHJvZHVjZXIudHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fdW53cmFwKG5ld1Byb2R1Y2VyLCAndHJhbnNhY3Rpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl93cmFwKG5ld1Byb2R1Y2VyLCAndHJhbnNhY3Rpb24nLCBpbnN0cnVtZW50YXRpb24uX2dldFByb2R1Y2VyVHJhbnNhY3Rpb25QYXRjaCgpKTtcbiAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX3NldEthZmthRXZlbnRMaXN0ZW5lcnMobmV3UHJvZHVjZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdQcm9kdWNlcjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9nZXRDb25zdW1lclJ1blBhdGNoKCkge1xuICAgICAgICBjb25zdCBpbnN0cnVtZW50YXRpb24gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKG9yaWdpbmFsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gcnVuKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25maWcgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIGlmIChjb25maWc/LmVhY2hNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShjb25maWcuZWFjaE1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX3Vud3JhcChjb25maWcsICdlYWNoTWVzc2FnZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fd3JhcChjb25maWcsICdlYWNoTWVzc2FnZScsIGluc3RydW1lbnRhdGlvbi5fZ2V0Q29uc3VtZXJFYWNoTWVzc2FnZVBhdGNoKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnPy5lYWNoQmF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKGNvbmZpZy5lYWNoQmF0Y2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX3Vud3JhcChjb25maWcsICdlYWNoQmF0Y2gnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX3dyYXAoY29uZmlnLCAnZWFjaEJhdGNoJywgaW5zdHJ1bWVudGF0aW9uLl9nZXRDb25zdW1lckVhY2hCYXRjaFBhdGNoKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2dldENvbnN1bWVyRWFjaE1lc3NhZ2VQYXRjaCgpIHtcbiAgICAgICAgY29uc3QgaW5zdHJ1bWVudGF0aW9uID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChvcmlnaW5hbCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGVhY2hNZXNzYWdlKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wYWdhdGVkQ29udGV4dCA9IGFwaV8xLnByb3BhZ2F0aW9uLmV4dHJhY3QoYXBpXzEuUk9PVF9DT05URVhULCBwYXlsb2FkLm1lc3NhZ2UuaGVhZGVycywgcHJvcGFnYXRvcl8xLmJ1ZmZlclRleHRNYXBHZXR0ZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwYW4gPSBpbnN0cnVtZW50YXRpb24uX3N0YXJ0Q29uc3VtZXJTcGFuKHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWM6IHBheWxvYWQudG9waWMsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHBheWxvYWQubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uVHlwZTogc2VtY29udl8xLk1FU1NBR0lOR19PUEVSQVRJT05fVFlQRV9WQUxVRV9QUk9DRVNTLFxuICAgICAgICAgICAgICAgICAgICBjdHg6IHByb3BhZ2F0ZWRDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX1BBUlRJVElPTl9JRF06IFN0cmluZyhwYXlsb2FkLnBhcnRpdGlvbiksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGVuZGluZ01ldHJpY3MgPSBbXG4gICAgICAgICAgICAgICAgICAgIHByZXBhcmVEdXJhdGlvbkhpc3RvZ3JhbShpbnN0cnVtZW50YXRpb24uX3Byb2Nlc3NEdXJhdGlvbiwgRGF0ZS5ub3coKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19TWVNURU1dOiBzZW1jb252XzEuTUVTU0FHSU5HX1NZU1RFTV9WQUxVRV9LQUZLQSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfT1BFUkFUSU9OX05BTUVdOiAncHJvY2VzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX05BTUVdOiBwYXlsb2FkLnRvcGljLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9QQVJUSVRJT05fSURdOiBTdHJpbmcocGF5bG9hZC5wYXJ0aXRpb24pLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgcHJlcGFyZUNvdW50ZXIoaW5zdHJ1bWVudGF0aW9uLl9jb25zdW1lZE1lc3NhZ2VzLCAxLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX1NZU1RFTV06IHNlbWNvbnZfMS5NRVNTQUdJTkdfU1lTVEVNX1ZBTFVFX0tBRktBLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fTkFNRV06ICdwcm9jZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fTkFNRV06IHBheWxvYWQudG9waWMsXG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX1BBUlRJVElPTl9JRF06IFN0cmluZyhwYXlsb2FkLnBhcnRpdGlvbiksXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgY29uc3QgZWFjaE1lc3NhZ2VQcm9taXNlID0gYXBpXzEuY29udGV4dC53aXRoKGFwaV8xLnRyYWNlLnNldFNwYW4ocHJvcGFnYXRlZENvbnRleHQsIHNwYW4pLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdHJ1bWVudGF0aW9uLl9lbmRTcGFuc09uUHJvbWlzZShbc3Bhbl0sIHBlbmRpbmdNZXRyaWNzLCBlYWNoTWVzc2FnZVByb21pc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2dldENvbnN1bWVyRWFjaEJhdGNoUGF0Y2goKSB7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbiA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gZWFjaEJhdGNoKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vb3Blbi10ZWxlbWV0cnkvb3BlbnRlbGVtZXRyeS1zcGVjaWZpY2F0aW9uL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vdHJhY2Uvc2VtYW50aWNfY29udmVudGlvbnMvbWVzc2FnaW5nLm1kI3RvcGljLXdpdGgtbXVsdGlwbGUtY29uc3VtZXJzXG4gICAgICAgICAgICAgICAgY29uc3QgcmVjZWl2aW5nU3BhbiA9IGluc3RydW1lbnRhdGlvbi5fc3RhcnRDb25zdW1lclNwYW4oe1xuICAgICAgICAgICAgICAgICAgICB0b3BpYzogcGF5bG9hZC5iYXRjaC50b3BpYyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25UeXBlOiBzZW1jb252XzEuTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFX1ZBTFVFX1JFQ0VJVkUsXG4gICAgICAgICAgICAgICAgICAgIGN0eDogYXBpXzEuUk9PVF9DT05URVhULFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0JBVENIX01FU1NBR0VfQ09VTlRdOiBwYXlsb2FkLmJhdGNoLm1lc3NhZ2VzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fUEFSVElUSU9OX0lEXTogU3RyaW5nKHBheWxvYWQuYmF0Y2gucGFydGl0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBpXzEuY29udGV4dC53aXRoKGFwaV8xLnRyYWNlLnNldFNwYW4oYXBpXzEuY29udGV4dC5hY3RpdmUoKSwgcmVjZWl2aW5nU3BhbiksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BhbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVuZGluZ01ldHJpY3MgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVwYXJlQ291bnRlcihpbnN0cnVtZW50YXRpb24uX2NvbnN1bWVkTWVzc2FnZXMsIHBheWxvYWQuYmF0Y2gubWVzc2FnZXMubGVuZ3RoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19TWVNURU1dOiBzZW1jb252XzEuTUVTU0FHSU5HX1NZU1RFTV9WQUxVRV9LQUZLQSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9OQU1FXTogJ3Byb2Nlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fTkFNRV06IHBheWxvYWQuYmF0Y2gudG9waWMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9QQVJUSVRJT05fSURdOiBTdHJpbmcocGF5bG9hZC5iYXRjaC5wYXJ0aXRpb24pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQuYmF0Y2gubWVzc2FnZXMuZm9yRWFjaChtZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BhZ2F0ZWRDb250ZXh0ID0gYXBpXzEucHJvcGFnYXRpb24uZXh0cmFjdChhcGlfMS5ST09UX0NPTlRFWFQsIG1lc3NhZ2UuaGVhZGVycywgcHJvcGFnYXRvcl8xLmJ1ZmZlclRleHRNYXBHZXR0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BhbkNvbnRleHQgPSBhcGlfMS50cmFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRTcGFuKHByb3BhZ2F0ZWRDb250ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8uc3BhbkNvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvcmlnU3Bhbkxpbms7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BhbkNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnU3BhbkxpbmsgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHNwYW5Db250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFucy5wdXNoKGluc3RydW1lbnRhdGlvbi5fc3RhcnRDb25zdW1lclNwYW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcGljOiBwYXlsb2FkLmJhdGNoLnRvcGljLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uVHlwZTogc2VtY29udl8xLk1FU1NBR0lOR19PUEVSQVRJT05fVFlQRV9WQUxVRV9QUk9DRVNTLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbms6IG9yaWdTcGFuTGluayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fUEFSVElUSU9OX0lEXTogU3RyaW5nKHBheWxvYWQuYmF0Y2gucGFydGl0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ01ldHJpY3MucHVzaChwcmVwYXJlRHVyYXRpb25IaXN0b2dyYW0oaW5zdHJ1bWVudGF0aW9uLl9wcm9jZXNzRHVyYXRpb24sIHN0YXJ0VGltZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfU1lTVEVNXTogc2VtY29udl8xLk1FU1NBR0lOR19TWVNURU1fVkFMVUVfS0FGS0EsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fTkFNRV06ICdwcm9jZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX05BTUVdOiBwYXlsb2FkLmJhdGNoLnRvcGljLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fUEFSVElUSU9OX0lEXTogU3RyaW5nKHBheWxvYWQuYmF0Y2gucGFydGl0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoTWVzc2FnZVByb21pc2UgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgc3BhbnMudW5zaGlmdChyZWNlaXZpbmdTcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RydW1lbnRhdGlvbi5fZW5kU3BhbnNPblByb21pc2Uoc3BhbnMsIHBlbmRpbmdNZXRyaWNzLCBiYXRjaE1lc3NhZ2VQcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9nZXRQcm9kdWNlclRyYW5zYWN0aW9uUGF0Y2goKSB7XG4gICAgICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbiA9IHRoaXM7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiB0cmFuc2FjdGlvbiguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25TcGFuID0gaW5zdHJ1bWVudGF0aW9uLnRyYWNlci5zdGFydFNwYW4oJ3RyYW5zYWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25Qcm9taXNlID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25Qcm9taXNlXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCh0cmFuc2FjdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFNlbmQgPSB0cmFuc2FjdGlvbi5zZW5kO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5zZW5kID0gZnVuY3Rpb24gc2VuZCguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXBpXzEuY29udGV4dC53aXRoKGFwaV8xLnRyYWNlLnNldFNwYW4oYXBpXzEuY29udGV4dC5hY3RpdmUoKSwgdHJhbnNhY3Rpb25TcGFuKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGNoZWQgPSBpbnN0cnVtZW50YXRpb24uX2dldFNlbmRQYXRjaCgpKG9yaWdpbmFsU2VuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGNoZWQuYXBwbHkodGhpcywgYXJncykuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TcGFuLnNldFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycj8ubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uU3Bhbi5yZWNvcmRFeGNlcHRpb24oZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU2VuZEJhdGNoID0gdHJhbnNhY3Rpb24uc2VuZEJhdGNoO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5zZW5kQmF0Y2ggPSBmdW5jdGlvbiBzZW5kQmF0Y2goLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwaV8xLmNvbnRleHQud2l0aChhcGlfMS50cmFjZS5zZXRTcGFuKGFwaV8xLmNvbnRleHQuYWN0aXZlKCksIHRyYW5zYWN0aW9uU3BhbiksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRjaGVkID0gaW5zdHJ1bWVudGF0aW9uLl9nZXRTZW5kQmF0Y2hQYXRjaCgpKG9yaWdpbmFsU2VuZEJhdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0Y2hlZC5hcHBseSh0aGlzLCBhcmdzKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvblNwYW4uc2V0U3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGFwaV8xLlNwYW5TdGF0dXNDb2RlLkVSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyPy5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TcGFuLnJlY29yZEV4Y2VwdGlvbihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxDb21taXQgPSB0cmFuc2FjdGlvbi5jb21taXQ7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmNvbW1pdCA9IGZ1bmN0aW9uIGNvbW1pdCguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5Db21taXRQcm9taXNlID0gb3JpZ2luYWxDb21taXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwbHkodGhpcywgYXJncylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TcGFuLnNldFN0YXR1cyh7IGNvZGU6IGFwaV8xLlNwYW5TdGF0dXNDb2RlLk9LIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zdHJ1bWVudGF0aW9uLl9lbmRTcGFuc09uUHJvbWlzZShbdHJhbnNhY3Rpb25TcGFuXSwgW10sIG9yaWdpbkNvbW1pdFByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbEFib3J0ID0gdHJhbnNhY3Rpb24uYWJvcnQ7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luQWJvcnRQcm9taXNlID0gb3JpZ2luYWxBYm9ydC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnN0cnVtZW50YXRpb24uX2VuZFNwYW5zT25Qcm9taXNlKFt0cmFuc2FjdGlvblNwYW5dLCBbXSwgb3JpZ2luQWJvcnRQcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TcGFuLnNldFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycj8ubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uU3Bhbi5yZWNvcmRFeGNlcHRpb24oZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TcGFuLmVuZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvblByb21pc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBfZ2V0U2VuZEJhdGNoUGF0Y2goKSB7XG4gICAgICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbiA9IHRoaXM7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBzZW5kQmF0Y2goLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlcyA9IGJhdGNoLnRvcGljTWVzc2FnZXMgfHwgW107XG4gICAgICAgICAgICAgICAgY29uc3Qgc3BhbnMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwZW5kaW5nTWV0cmljcyA9IFtdO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VzLmZvckVhY2godG9waWNNZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNNZXNzYWdlLm1lc3NhZ2VzLmZvckVhY2gobWVzc2FnZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFucy5wdXNoKGluc3RydW1lbnRhdGlvbi5fc3RhcnRQcm9kdWNlclNwYW4odG9waWNNZXNzYWdlLnRvcGljLCBtZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nTWV0cmljcy5wdXNoKHByZXBhcmVDb3VudGVyKGluc3RydW1lbnRhdGlvbi5fc2VudE1lc3NhZ2VzLCAxLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19TWVNURU1dOiBzZW1jb252XzEuTUVTU0FHSU5HX1NZU1RFTV9WQUxVRV9LQUZLQSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9OQU1FXTogJ3NlbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fTkFNRV06IHRvcGljTWVzc2FnZS50b3BpYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4obWVzc2FnZS5wYXJ0aXRpb24gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fUEFSVElUSU9OX0lEXTogU3RyaW5nKG1lc3NhZ2UucGFydGl0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ1NlbmRSZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdHJ1bWVudGF0aW9uLl9lbmRTcGFuc09uUHJvbWlzZShzcGFucywgcGVuZGluZ01ldHJpY3MsIG9yaWdTZW5kUmVzdWx0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9nZXRTZW5kUGF0Y2goKSB7XG4gICAgICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbiA9IHRoaXM7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBzZW5kKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWNvcmQgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwYW5zID0gcmVjb3JkLm1lc3NhZ2VzLm1hcChtZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RydW1lbnRhdGlvbi5fc3RhcnRQcm9kdWNlclNwYW4ocmVjb3JkLnRvcGljLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwZW5kaW5nTWV0cmljcyA9IHJlY29yZC5tZXNzYWdlcy5tYXAobSA9PiBwcmVwYXJlQ291bnRlcihpbnN0cnVtZW50YXRpb24uX3NlbnRNZXNzYWdlcywgMSwge1xuICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX1NZU1RFTV06IHNlbWNvbnZfMS5NRVNTQUdJTkdfU1lTVEVNX1ZBTFVFX0tBRktBLFxuICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9OQU1FXTogJ3NlbmQnLFxuICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX05BTUVdOiByZWNvcmQudG9waWMsXG4gICAgICAgICAgICAgICAgICAgIC4uLihtLnBhcnRpdGlvbiAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX1BBUlRJVElPTl9JRF06IFN0cmluZyhtLnBhcnRpdGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ1NlbmRSZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdHJ1bWVudGF0aW9uLl9lbmRTcGFuc09uUHJvbWlzZShzcGFucywgcGVuZGluZ01ldHJpY3MsIG9yaWdTZW5kUmVzdWx0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9lbmRTcGFuc09uUHJvbWlzZShzcGFucywgcGVuZGluZ01ldHJpY3MsIHNlbmRQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2VuZFByb21pc2UpXG4gICAgICAgICAgICAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgcGVuZGluZ01ldHJpY3MuZm9yRWFjaChtID0+IG0oKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICAgICAgICBsZXQgZXJyb3JNZXNzYWdlO1xuICAgICAgICAgICAgbGV0IGVycm9yVHlwZSA9IHNlbWFudGljX2NvbnZlbnRpb25zXzEuRVJST1JfVFlQRV9WQUxVRV9PVEhFUjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVhc29uID09PSAnc3RyaW5nJyB8fCByZWFzb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IHJlYXNvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiByZWFzb24gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlYXNvbiwgJ21lc3NhZ2UnKSkge1xuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IHJlYXNvbi5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIGVycm9yVHlwZSA9IHJlYXNvbi5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGVuZGluZ01ldHJpY3MuZm9yRWFjaChtID0+IG0oZXJyb3JUeXBlKSk7XG4gICAgICAgICAgICBzcGFucy5mb3JFYWNoKHNwYW4gPT4ge1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKHNlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9FUlJPUl9UWVBFLCBlcnJvclR5cGUpO1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogYXBpXzEuU3BhblN0YXR1c0NvZGUuRVJST1IsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yTWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgc3BhbnMuZm9yRWFjaChzcGFuID0+IHNwYW4uZW5kKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3N0YXJ0Q29uc3VtZXJTcGFuKHsgdG9waWMsIG1lc3NhZ2UsIG9wZXJhdGlvblR5cGUsIGN0eCwgbGluaywgYXR0cmlidXRlcywgfSkge1xuICAgICAgICBjb25zdCBvcGVyYXRpb25OYW1lID0gb3BlcmF0aW9uVHlwZSA9PT0gc2VtY29udl8xLk1FU1NBR0lOR19PUEVSQVRJT05fVFlQRV9WQUxVRV9SRUNFSVZFXG4gICAgICAgICAgICA/ICdwb2xsJyAvLyBmb3IgYmF0Y2ggcHJvY2Vzc2luZyBzcGFuc1xuICAgICAgICAgICAgOiBvcGVyYXRpb25UeXBlOyAvLyBmb3IgaW5kaXZpZHVhbCBtZXNzYWdlIHByb2Nlc3Npbmcgc3BhbnNcbiAgICAgICAgY29uc3Qgc3BhbiA9IHRoaXMudHJhY2VyLnN0YXJ0U3BhbihgJHtvcGVyYXRpb25OYW1lfSAke3RvcGljfWAsIHtcbiAgICAgICAgICAgIGtpbmQ6IG9wZXJhdGlvblR5cGUgPT09IHNlbWNvbnZfMS5NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEVfVkFMVUVfUkVDRUlWRVxuICAgICAgICAgICAgICAgID8gYXBpXzEuU3BhbktpbmQuQ0xJRU5UXG4gICAgICAgICAgICAgICAgOiBhcGlfMS5TcGFuS2luZC5DT05TVU1FUixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfU1lTVEVNXTogc2VtY29udl8xLk1FU1NBR0lOR19TWVNURU1fVkFMVUVfS0FGS0EsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9OQU1FXTogdG9waWMsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fVFlQRV06IG9wZXJhdGlvblR5cGUsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fTkFNRV06IG9wZXJhdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19LQUZLQV9NRVNTQUdFX0tFWV06IG1lc3NhZ2U/LmtleVxuICAgICAgICAgICAgICAgICAgICA/IFN0cmluZyhtZXNzYWdlLmtleSlcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19LQUZLQV9NRVNTQUdFX1RPTUJTVE9ORV06IG1lc3NhZ2U/LmtleSAmJiBtZXNzYWdlLnZhbHVlID09PSBudWxsID8gdHJ1ZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0tBRktBX09GRlNFVF06IG1lc3NhZ2U/Lm9mZnNldCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5rczogbGluayA/IFtsaW5rXSA6IFtdLFxuICAgICAgICB9LCBjdHgpO1xuICAgICAgICBjb25zdCB7IGNvbnN1bWVySG9vayB9ID0gdGhpcy5nZXRDb25maWcoKTtcbiAgICAgICAgaWYgKGNvbnN1bWVySG9vayAmJiBtZXNzYWdlKSB7XG4gICAgICAgICAgICAoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4gY29uc3VtZXJIb29rKHNwYW4sIHsgdG9waWMsIG1lc3NhZ2UgfSksIGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaWFnLmVycm9yKCdjb25zdW1lckhvb2sgZXJyb3InLCBlKTtcbiAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbiAgICBfc3RhcnRQcm9kdWNlclNwYW4odG9waWMsIG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgc3BhbiA9IHRoaXMudHJhY2VyLnN0YXJ0U3Bhbihgc2VuZCAke3RvcGljfWAsIHtcbiAgICAgICAgICAgIGtpbmQ6IGFwaV8xLlNwYW5LaW5kLlBST0RVQ0VSLFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfU1lTVEVNXTogc2VtY29udl8xLk1FU1NBR0lOR19TWVNURU1fVkFMVUVfS0FGS0EsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9OQU1FXTogdG9waWMsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19LQUZLQV9NRVNTQUdFX0tFWV06IG1lc3NhZ2Uua2V5XG4gICAgICAgICAgICAgICAgICAgID8gU3RyaW5nKG1lc3NhZ2Uua2V5KVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0tBRktBX01FU1NBR0VfVE9NQlNUT05FXTogbWVzc2FnZS5rZXkgJiYgbWVzc2FnZS52YWx1ZSA9PT0gbnVsbCA/IHRydWUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9QQVJUSVRJT05fSURdOiBtZXNzYWdlLnBhcnRpdGlvbiAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gU3RyaW5nKG1lc3NhZ2UucGFydGl0aW9uKVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9OQU1FXTogJ3NlbmQnLFxuICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEVdOiBzZW1jb252XzEuTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFX1ZBTFVFX1NFTkQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgbWVzc2FnZS5oZWFkZXJzID0gbWVzc2FnZS5oZWFkZXJzID8/IHt9O1xuICAgICAgICBhcGlfMS5wcm9wYWdhdGlvbi5pbmplY3QoYXBpXzEudHJhY2Uuc2V0U3BhbihhcGlfMS5jb250ZXh0LmFjdGl2ZSgpLCBzcGFuKSwgbWVzc2FnZS5oZWFkZXJzKTtcbiAgICAgICAgY29uc3QgeyBwcm9kdWNlckhvb2sgfSA9IHRoaXMuZ2V0Q29uZmlnKCk7XG4gICAgICAgIGlmIChwcm9kdWNlckhvb2spIHtcbiAgICAgICAgICAgICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiBwcm9kdWNlckhvb2soc3BhbiwgeyB0b3BpYywgbWVzc2FnZSB9KSwgZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpYWcuZXJyb3IoJ3Byb2R1Y2VySG9vayBlcnJvcicsIGUpO1xuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxufVxuZXhwb3J0cy5LYWZrYUpzSW5zdHJ1bWVudGF0aW9uID0gS2Fma2FKc0luc3RydW1lbnRhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluc3RydW1lbnRhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/instrumentation.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/internal-types.js":
/*!***************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/internal-types.js ***!
  \***************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors, Aspecto\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EVENT_LISTENERS_SET = void 0;\nexports.EVENT_LISTENERS_SET = Symbol('opentelemetry.instrumentation.kafkajs.eventListenersSet');\n//# sourceMappingURL=internal-types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTQuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy9pbnRlcm5hbC10eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyIvVXNlcnMvY29keWRlYXJrbGFuZC9zZW50cnl2aWJlL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24ta2Fma2Fqc0AwLjE0LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24ta2Fma2Fqcy9idWlsZC9zcmMvaW50ZXJuYWwtdHlwZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IFRoZSBPcGVuVGVsZW1ldHJ5IEF1dGhvcnMsIEFzcGVjdG9cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FVkVOVF9MSVNURU5FUlNfU0VUID0gdm9pZCAwO1xuZXhwb3J0cy5FVkVOVF9MSVNURU5FUlNfU0VUID0gU3ltYm9sKCdvcGVudGVsZW1ldHJ5Lmluc3RydW1lbnRhdGlvbi5rYWZrYWpzLmV2ZW50TGlzdGVuZXJzU2V0Jyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcm5hbC10eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/internal-types.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/propagator.js":
/*!***********************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/propagator.js ***!
  \***********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bufferTextMapGetter = void 0;\n/*\nsame as open telemetry's `defaultTextMapGetter`,\nbut also handle case where header is buffer,\nadding toString() to make sure string is returned\n*/\nexports.bufferTextMapGetter = {\n    get(carrier, key) {\n        if (!carrier) {\n            return undefined;\n        }\n        const keys = Object.keys(carrier);\n        for (const carrierKey of keys) {\n            if (carrierKey === key || carrierKey.toLowerCase() === key) {\n                return carrier[carrierKey]?.toString();\n            }\n        }\n        return undefined;\n    },\n    keys(carrier) {\n        return carrier ? Object.keys(carrier) : [];\n    },\n};\n//# sourceMappingURL=propagator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTQuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy9wcm9wYWdhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvY29keWRlYXJrbGFuZC9zZW50cnl2aWJlL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24ta2Fma2Fqc0AwLjE0LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24ta2Fma2Fqcy9idWlsZC9zcmMvcHJvcGFnYXRvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYnVmZmVyVGV4dE1hcEdldHRlciA9IHZvaWQgMDtcbi8qXG5zYW1lIGFzIG9wZW4gdGVsZW1ldHJ5J3MgYGRlZmF1bHRUZXh0TWFwR2V0dGVyYCxcbmJ1dCBhbHNvIGhhbmRsZSBjYXNlIHdoZXJlIGhlYWRlciBpcyBidWZmZXIsXG5hZGRpbmcgdG9TdHJpbmcoKSB0byBtYWtlIHN1cmUgc3RyaW5nIGlzIHJldHVybmVkXG4qL1xuZXhwb3J0cy5idWZmZXJUZXh0TWFwR2V0dGVyID0ge1xuICAgIGdldChjYXJyaWVyLCBrZXkpIHtcbiAgICAgICAgaWYgKCFjYXJyaWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjYXJyaWVyKTtcbiAgICAgICAgZm9yIChjb25zdCBjYXJyaWVyS2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgIGlmIChjYXJyaWVyS2V5ID09PSBrZXkgfHwgY2FycmllcktleS50b0xvd2VyQ2FzZSgpID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FycmllcltjYXJyaWVyS2V5XT8udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAga2V5cyhjYXJyaWVyKSB7XG4gICAgICAgIHJldHVybiBjYXJyaWVyID8gT2JqZWN0LmtleXMoY2FycmllcikgOiBbXTtcbiAgICB9LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BhZ2F0b3IuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/propagator.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/semconv.js":
/*!********************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/semconv.js ***!
  \********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.METRIC_MESSAGING_PROCESS_DURATION = exports.METRIC_MESSAGING_CLIENT_SENT_MESSAGES = exports.METRIC_MESSAGING_CLIENT_OPERATION_DURATION = exports.METRIC_MESSAGING_CLIENT_CONSUMED_MESSAGES = exports.MESSAGING_SYSTEM_VALUE_KAFKA = exports.MESSAGING_OPERATION_TYPE_VALUE_SEND = exports.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE = exports.MESSAGING_OPERATION_TYPE_VALUE_PROCESS = exports.ATTR_MESSAGING_SYSTEM = exports.ATTR_MESSAGING_OPERATION_TYPE = exports.ATTR_MESSAGING_OPERATION_NAME = exports.ATTR_MESSAGING_KAFKA_OFFSET = exports.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE = exports.ATTR_MESSAGING_KAFKA_MESSAGE_KEY = exports.ATTR_MESSAGING_DESTINATION_PARTITION_ID = exports.ATTR_MESSAGING_DESTINATION_NAME = exports.ATTR_MESSAGING_BATCH_MESSAGE_COUNT = void 0;\n/*\n * This file contains a copy of unstable semantic convention definitions\n * used by this package.\n * @see https://github.com/open-telemetry/opentelemetry-js/tree/main/semantic-conventions#unstable-semconv\n */\n/**\n * The number of messages sent, received, or processed in the scope of the batching operation.\n *\n * @example 0\n * @example 1\n * @example 2\n *\n * @note Instrumentations **SHOULD NOT** set `messaging.batch.message_count` on spans that operate with a single message. When a messaging client library supports both batch and single-message API for the same operation, instrumentations **SHOULD** use `messaging.batch.message_count` for batching APIs and **SHOULD NOT** use it for single-message APIs.\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_BATCH_MESSAGE_COUNT = 'messaging.batch.message_count';\n/**\n * The message destination name\n *\n * @example MyQueue\n * @example MyTopic\n *\n * @note Destination name **SHOULD** uniquely identify a specific queue, topic or other entity within the broker. If\n * the broker doesn't have such notion, the destination name **SHOULD** uniquely identify the broker.\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_DESTINATION_NAME = 'messaging.destination.name';\n/**\n * The identifier of the partition messages are sent to or received from, unique within the `messaging.destination.name`.\n *\n * @example \"1\"\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_DESTINATION_PARTITION_ID = 'messaging.destination.partition.id';\n/**\n * Message keys in Kafka are used for grouping alike messages to ensure they're processed on the same partition. They differ from `messaging.message.id` in that they're not unique. If the key is `null`, the attribute **MUST NOT** be set.\n *\n * @example \"myKey\"\n *\n * @note If the key type is not string, it's string representation has to be supplied for the attribute. If the key has no unambiguous, canonical string form, don't include its value.\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_KAFKA_MESSAGE_KEY = 'messaging.kafka.message.key';\n/**\n * A boolean that is true if the message is a tombstone.\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE = 'messaging.kafka.message.tombstone';\n/**\n * The offset of a record in the corresponding Kafka partition.\n *\n * @example 42\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_KAFKA_OFFSET = 'messaging.kafka.offset';\n/**\n * The system-specific name of the messaging operation.\n *\n * @example ack\n * @example nack\n * @example send\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_OPERATION_NAME = 'messaging.operation.name';\n/**\n * A string identifying the type of the messaging operation.\n *\n * @note If a custom value is used, it **MUST** be of low cardinality.\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_OPERATION_TYPE = 'messaging.operation.type';\n/**\n * The messaging system as identified by the client instrumentation.\n *\n * @note The actual messaging system may differ from the one known by the client. For example, when using Kafka client libraries to communicate with Azure Event Hubs, the `messaging.system` is set to `kafka` based on the instrumentation's best knowledge.\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_SYSTEM = 'messaging.system';\n/**\n * Enum value \"process\" for attribute {@link ATTR_MESSAGING_OPERATION_TYPE}.\n */\nexports.MESSAGING_OPERATION_TYPE_VALUE_PROCESS = 'process';\n/**\n * Enum value \"receive\" for attribute {@link ATTR_MESSAGING_OPERATION_TYPE}.\n */\nexports.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE = 'receive';\n/**\n * Enum value \"send\" for attribute {@link ATTR_MESSAGING_OPERATION_TYPE}.\n */\nexports.MESSAGING_OPERATION_TYPE_VALUE_SEND = 'send';\n/**\n * Enum value \"kafka\" for attribute {@link ATTR_MESSAGING_SYSTEM}.\n */\nexports.MESSAGING_SYSTEM_VALUE_KAFKA = 'kafka';\n/**\n * Number of messages that were delivered to the application.\n *\n * @note Records the number of messages pulled from the broker or number of messages dispatched to the application in push-based scenarios.\n * The metric **SHOULD** be reported once per message delivery. For example, if receiving and processing operations are both instrumented for a single message delivery, this counter is incremented when the message is received and not reported when it is processed.\n *\n * @experimental This metric is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.METRIC_MESSAGING_CLIENT_CONSUMED_MESSAGES = 'messaging.client.consumed.messages';\n/**\n * Duration of messaging operation initiated by a producer or consumer client.\n *\n * @note This metric **SHOULD NOT** be used to report processing duration - processing duration is reported in `messaging.process.duration` metric.\n *\n * @experimental This metric is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.METRIC_MESSAGING_CLIENT_OPERATION_DURATION = 'messaging.client.operation.duration';\n/**\n * Number of messages producer attempted to send to the broker.\n *\n * @note This metric **MUST NOT** count messages that were created but haven't yet been sent.\n *\n * @experimental This metric is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.METRIC_MESSAGING_CLIENT_SENT_MESSAGES = 'messaging.client.sent.messages';\n/**\n * Duration of processing operation.\n *\n * @note This metric **MUST** be reported for operations with `messaging.operation.type` that matches `process`.\n *\n * @experimental This metric is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.METRIC_MESSAGING_PROCESS_DURATION = 'messaging.process.duration';\n//# sourceMappingURL=semconv.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTQuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy9zZW1jb252LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlDQUF5QyxHQUFHLDZDQUE2QyxHQUFHLGtEQUFrRCxHQUFHLGlEQUFpRCxHQUFHLG9DQUFvQyxHQUFHLDJDQUEyQyxHQUFHLDhDQUE4QyxHQUFHLDhDQUE4QyxHQUFHLDZCQUE2QixHQUFHLHFDQUFxQyxHQUFHLHFDQUFxQyxHQUFHLG1DQUFtQyxHQUFHLDhDQUE4QyxHQUFHLHdDQUF3QyxHQUFHLCtDQUErQyxHQUFHLHVDQUF1QyxHQUFHLDBDQUEwQztBQUNwdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsdUNBQXVDLG9DQUFvQztBQUMzRTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLHVDQUF1QyxvQ0FBb0M7QUFDM0U7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxvQ0FBb0Msb0NBQW9DO0FBQ3hFO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EscUNBQXFDLDRCQUE0QjtBQUNqRTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDIiwic291cmNlcyI6WyIvVXNlcnMvY29keWRlYXJrbGFuZC9zZW50cnl2aWJlL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24ta2Fma2Fqc0AwLjE0LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24ta2Fma2Fqcy9idWlsZC9zcmMvc2VtY29udi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1FVFJJQ19NRVNTQUdJTkdfUFJPQ0VTU19EVVJBVElPTiA9IGV4cG9ydHMuTUVUUklDX01FU1NBR0lOR19DTElFTlRfU0VOVF9NRVNTQUdFUyA9IGV4cG9ydHMuTUVUUklDX01FU1NBR0lOR19DTElFTlRfT1BFUkFUSU9OX0RVUkFUSU9OID0gZXhwb3J0cy5NRVRSSUNfTUVTU0FHSU5HX0NMSUVOVF9DT05TVU1FRF9NRVNTQUdFUyA9IGV4cG9ydHMuTUVTU0FHSU5HX1NZU1RFTV9WQUxVRV9LQUZLQSA9IGV4cG9ydHMuTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFX1ZBTFVFX1NFTkQgPSBleHBvcnRzLk1FU1NBR0lOR19PUEVSQVRJT05fVFlQRV9WQUxVRV9SRUNFSVZFID0gZXhwb3J0cy5NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEVfVkFMVUVfUFJPQ0VTUyA9IGV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfU1lTVEVNID0gZXhwb3J0cy5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fVFlQRSA9IGV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfT1BFUkFUSU9OX05BTUUgPSBleHBvcnRzLkFUVFJfTUVTU0FHSU5HX0tBRktBX09GRlNFVCA9IGV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfS0FGS0FfTUVTU0FHRV9UT01CU1RPTkUgPSBleHBvcnRzLkFUVFJfTUVTU0FHSU5HX0tBRktBX01FU1NBR0VfS0VZID0gZXhwb3J0cy5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9QQVJUSVRJT05fSUQgPSBleHBvcnRzLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX05BTUUgPSBleHBvcnRzLkFUVFJfTUVTU0FHSU5HX0JBVENIX01FU1NBR0VfQ09VTlQgPSB2b2lkIDA7XG4vKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGEgY29weSBvZiB1bnN0YWJsZSBzZW1hbnRpYyBjb252ZW50aW9uIGRlZmluaXRpb25zXG4gKiB1c2VkIGJ5IHRoaXMgcGFja2FnZS5cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL29wZW4tdGVsZW1ldHJ5L29wZW50ZWxlbWV0cnktanMvdHJlZS9tYWluL3NlbWFudGljLWNvbnZlbnRpb25zI3Vuc3RhYmxlLXNlbWNvbnZcbiAqL1xuLyoqXG4gKiBUaGUgbnVtYmVyIG9mIG1lc3NhZ2VzIHNlbnQsIHJlY2VpdmVkLCBvciBwcm9jZXNzZWQgaW4gdGhlIHNjb3BlIG9mIHRoZSBiYXRjaGluZyBvcGVyYXRpb24uXG4gKlxuICogQGV4YW1wbGUgMFxuICogQGV4YW1wbGUgMVxuICogQGV4YW1wbGUgMlxuICpcbiAqIEBub3RlIEluc3RydW1lbnRhdGlvbnMgKipTSE9VTEQgTk9UKiogc2V0IGBtZXNzYWdpbmcuYmF0Y2gubWVzc2FnZV9jb3VudGAgb24gc3BhbnMgdGhhdCBvcGVyYXRlIHdpdGggYSBzaW5nbGUgbWVzc2FnZS4gV2hlbiBhIG1lc3NhZ2luZyBjbGllbnQgbGlicmFyeSBzdXBwb3J0cyBib3RoIGJhdGNoIGFuZCBzaW5nbGUtbWVzc2FnZSBBUEkgZm9yIHRoZSBzYW1lIG9wZXJhdGlvbiwgaW5zdHJ1bWVudGF0aW9ucyAqKlNIT1VMRCoqIHVzZSBgbWVzc2FnaW5nLmJhdGNoLm1lc3NhZ2VfY291bnRgIGZvciBiYXRjaGluZyBBUElzIGFuZCAqKlNIT1VMRCBOT1QqKiB1c2UgaXQgZm9yIHNpbmdsZS1tZXNzYWdlIEFQSXMuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIGF0dHJpYnV0ZSBpcyBleHBlcmltZW50YWwgYW5kIGlzIHN1YmplY3QgdG8gYnJlYWtpbmcgY2hhbmdlcyBpbiBtaW5vciByZWxlYXNlcyBvZiBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgLlxuICovXG5leHBvcnRzLkFUVFJfTUVTU0FHSU5HX0JBVENIX01FU1NBR0VfQ09VTlQgPSAnbWVzc2FnaW5nLmJhdGNoLm1lc3NhZ2VfY291bnQnO1xuLyoqXG4gKiBUaGUgbWVzc2FnZSBkZXN0aW5hdGlvbiBuYW1lXG4gKlxuICogQGV4YW1wbGUgTXlRdWV1ZVxuICogQGV4YW1wbGUgTXlUb3BpY1xuICpcbiAqIEBub3RlIERlc3RpbmF0aW9uIG5hbWUgKipTSE9VTEQqKiB1bmlxdWVseSBpZGVudGlmeSBhIHNwZWNpZmljIHF1ZXVlLCB0b3BpYyBvciBvdGhlciBlbnRpdHkgd2l0aGluIHRoZSBicm9rZXIuIElmXG4gKiB0aGUgYnJva2VyIGRvZXNuJ3QgaGF2ZSBzdWNoIG5vdGlvbiwgdGhlIGRlc3RpbmF0aW9uIG5hbWUgKipTSE9VTEQqKiB1bmlxdWVseSBpZGVudGlmeSB0aGUgYnJva2VyLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBhdHRyaWJ1dGUgaXMgZXhwZXJpbWVudGFsIGFuZCBpcyBzdWJqZWN0IHRvIGJyZWFraW5nIGNoYW5nZXMgaW4gbWlub3IgcmVsZWFzZXMgb2YgYEBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zYC5cbiAqL1xuZXhwb3J0cy5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9OQU1FID0gJ21lc3NhZ2luZy5kZXN0aW5hdGlvbi5uYW1lJztcbi8qKlxuICogVGhlIGlkZW50aWZpZXIgb2YgdGhlIHBhcnRpdGlvbiBtZXNzYWdlcyBhcmUgc2VudCB0byBvciByZWNlaXZlZCBmcm9tLCB1bmlxdWUgd2l0aGluIHRoZSBgbWVzc2FnaW5nLmRlc3RpbmF0aW9uLm5hbWVgLlxuICpcbiAqIEBleGFtcGxlIFwiMVwiXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIGF0dHJpYnV0ZSBpcyBleHBlcmltZW50YWwgYW5kIGlzIHN1YmplY3QgdG8gYnJlYWtpbmcgY2hhbmdlcyBpbiBtaW5vciByZWxlYXNlcyBvZiBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgLlxuICovXG5leHBvcnRzLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX1BBUlRJVElPTl9JRCA9ICdtZXNzYWdpbmcuZGVzdGluYXRpb24ucGFydGl0aW9uLmlkJztcbi8qKlxuICogTWVzc2FnZSBrZXlzIGluIEthZmthIGFyZSB1c2VkIGZvciBncm91cGluZyBhbGlrZSBtZXNzYWdlcyB0byBlbnN1cmUgdGhleSdyZSBwcm9jZXNzZWQgb24gdGhlIHNhbWUgcGFydGl0aW9uLiBUaGV5IGRpZmZlciBmcm9tIGBtZXNzYWdpbmcubWVzc2FnZS5pZGAgaW4gdGhhdCB0aGV5J3JlIG5vdCB1bmlxdWUuIElmIHRoZSBrZXkgaXMgYG51bGxgLCB0aGUgYXR0cmlidXRlICoqTVVTVCBOT1QqKiBiZSBzZXQuXG4gKlxuICogQGV4YW1wbGUgXCJteUtleVwiXG4gKlxuICogQG5vdGUgSWYgdGhlIGtleSB0eXBlIGlzIG5vdCBzdHJpbmcsIGl0J3Mgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGhhcyB0byBiZSBzdXBwbGllZCBmb3IgdGhlIGF0dHJpYnV0ZS4gSWYgdGhlIGtleSBoYXMgbm8gdW5hbWJpZ3VvdXMsIGNhbm9uaWNhbCBzdHJpbmcgZm9ybSwgZG9uJ3QgaW5jbHVkZSBpdHMgdmFsdWUuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIGF0dHJpYnV0ZSBpcyBleHBlcmltZW50YWwgYW5kIGlzIHN1YmplY3QgdG8gYnJlYWtpbmcgY2hhbmdlcyBpbiBtaW5vciByZWxlYXNlcyBvZiBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgLlxuICovXG5leHBvcnRzLkFUVFJfTUVTU0FHSU5HX0tBRktBX01FU1NBR0VfS0VZID0gJ21lc3NhZ2luZy5rYWZrYS5tZXNzYWdlLmtleSc7XG4vKipcbiAqIEEgYm9vbGVhbiB0aGF0IGlzIHRydWUgaWYgdGhlIG1lc3NhZ2UgaXMgYSB0b21ic3RvbmUuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIGF0dHJpYnV0ZSBpcyBleHBlcmltZW50YWwgYW5kIGlzIHN1YmplY3QgdG8gYnJlYWtpbmcgY2hhbmdlcyBpbiBtaW5vciByZWxlYXNlcyBvZiBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgLlxuICovXG5leHBvcnRzLkFUVFJfTUVTU0FHSU5HX0tBRktBX01FU1NBR0VfVE9NQlNUT05FID0gJ21lc3NhZ2luZy5rYWZrYS5tZXNzYWdlLnRvbWJzdG9uZSc7XG4vKipcbiAqIFRoZSBvZmZzZXQgb2YgYSByZWNvcmQgaW4gdGhlIGNvcnJlc3BvbmRpbmcgS2Fma2EgcGFydGl0aW9uLlxuICpcbiAqIEBleGFtcGxlIDQyXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIGF0dHJpYnV0ZSBpcyBleHBlcmltZW50YWwgYW5kIGlzIHN1YmplY3QgdG8gYnJlYWtpbmcgY2hhbmdlcyBpbiBtaW5vciByZWxlYXNlcyBvZiBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgLlxuICovXG5leHBvcnRzLkFUVFJfTUVTU0FHSU5HX0tBRktBX09GRlNFVCA9ICdtZXNzYWdpbmcua2Fma2Eub2Zmc2V0Jztcbi8qKlxuICogVGhlIHN5c3RlbS1zcGVjaWZpYyBuYW1lIG9mIHRoZSBtZXNzYWdpbmcgb3BlcmF0aW9uLlxuICpcbiAqIEBleGFtcGxlIGFja1xuICogQGV4YW1wbGUgbmFja1xuICogQGV4YW1wbGUgc2VuZFxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBhdHRyaWJ1dGUgaXMgZXhwZXJpbWVudGFsIGFuZCBpcyBzdWJqZWN0IHRvIGJyZWFraW5nIGNoYW5nZXMgaW4gbWlub3IgcmVsZWFzZXMgb2YgYEBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zYC5cbiAqL1xuZXhwb3J0cy5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fTkFNRSA9ICdtZXNzYWdpbmcub3BlcmF0aW9uLm5hbWUnO1xuLyoqXG4gKiBBIHN0cmluZyBpZGVudGlmeWluZyB0aGUgdHlwZSBvZiB0aGUgbWVzc2FnaW5nIG9wZXJhdGlvbi5cbiAqXG4gKiBAbm90ZSBJZiBhIGN1c3RvbSB2YWx1ZSBpcyB1c2VkLCBpdCAqKk1VU1QqKiBiZSBvZiBsb3cgY2FyZGluYWxpdHkuXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgYXR0cmlidXRlIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXMgc3ViamVjdCB0byBicmVha2luZyBjaGFuZ2VzIGluIG1pbm9yIHJlbGVhc2VzIG9mIGBAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc2AuXG4gKi9cbmV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEUgPSAnbWVzc2FnaW5nLm9wZXJhdGlvbi50eXBlJztcbi8qKlxuICogVGhlIG1lc3NhZ2luZyBzeXN0ZW0gYXMgaWRlbnRpZmllZCBieSB0aGUgY2xpZW50IGluc3RydW1lbnRhdGlvbi5cbiAqXG4gKiBAbm90ZSBUaGUgYWN0dWFsIG1lc3NhZ2luZyBzeXN0ZW0gbWF5IGRpZmZlciBmcm9tIHRoZSBvbmUga25vd24gYnkgdGhlIGNsaWVudC4gRm9yIGV4YW1wbGUsIHdoZW4gdXNpbmcgS2Fma2EgY2xpZW50IGxpYnJhcmllcyB0byBjb21tdW5pY2F0ZSB3aXRoIEF6dXJlIEV2ZW50IEh1YnMsIHRoZSBgbWVzc2FnaW5nLnN5c3RlbWAgaXMgc2V0IHRvIGBrYWZrYWAgYmFzZWQgb24gdGhlIGluc3RydW1lbnRhdGlvbidzIGJlc3Qga25vd2xlZGdlLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBhdHRyaWJ1dGUgaXMgZXhwZXJpbWVudGFsIGFuZCBpcyBzdWJqZWN0IHRvIGJyZWFraW5nIGNoYW5nZXMgaW4gbWlub3IgcmVsZWFzZXMgb2YgYEBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zYC5cbiAqL1xuZXhwb3J0cy5BVFRSX01FU1NBR0lOR19TWVNURU0gPSAnbWVzc2FnaW5nLnN5c3RlbSc7XG4vKipcbiAqIEVudW0gdmFsdWUgXCJwcm9jZXNzXCIgZm9yIGF0dHJpYnV0ZSB7QGxpbmsgQVRUUl9NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEV9LlxuICovXG5leHBvcnRzLk1FU1NBR0lOR19PUEVSQVRJT05fVFlQRV9WQUxVRV9QUk9DRVNTID0gJ3Byb2Nlc3MnO1xuLyoqXG4gKiBFbnVtIHZhbHVlIFwicmVjZWl2ZVwiIGZvciBhdHRyaWJ1dGUge0BsaW5rIEFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFfS5cbiAqL1xuZXhwb3J0cy5NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEVfVkFMVUVfUkVDRUlWRSA9ICdyZWNlaXZlJztcbi8qKlxuICogRW51bSB2YWx1ZSBcInNlbmRcIiBmb3IgYXR0cmlidXRlIHtAbGluayBBVFRSX01FU1NBR0lOR19PUEVSQVRJT05fVFlQRX0uXG4gKi9cbmV4cG9ydHMuTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFX1ZBTFVFX1NFTkQgPSAnc2VuZCc7XG4vKipcbiAqIEVudW0gdmFsdWUgXCJrYWZrYVwiIGZvciBhdHRyaWJ1dGUge0BsaW5rIEFUVFJfTUVTU0FHSU5HX1NZU1RFTX0uXG4gKi9cbmV4cG9ydHMuTUVTU0FHSU5HX1NZU1RFTV9WQUxVRV9LQUZLQSA9ICdrYWZrYSc7XG4vKipcbiAqIE51bWJlciBvZiBtZXNzYWdlcyB0aGF0IHdlcmUgZGVsaXZlcmVkIHRvIHRoZSBhcHBsaWNhdGlvbi5cbiAqXG4gKiBAbm90ZSBSZWNvcmRzIHRoZSBudW1iZXIgb2YgbWVzc2FnZXMgcHVsbGVkIGZyb20gdGhlIGJyb2tlciBvciBudW1iZXIgb2YgbWVzc2FnZXMgZGlzcGF0Y2hlZCB0byB0aGUgYXBwbGljYXRpb24gaW4gcHVzaC1iYXNlZCBzY2VuYXJpb3MuXG4gKiBUaGUgbWV0cmljICoqU0hPVUxEKiogYmUgcmVwb3J0ZWQgb25jZSBwZXIgbWVzc2FnZSBkZWxpdmVyeS4gRm9yIGV4YW1wbGUsIGlmIHJlY2VpdmluZyBhbmQgcHJvY2Vzc2luZyBvcGVyYXRpb25zIGFyZSBib3RoIGluc3RydW1lbnRlZCBmb3IgYSBzaW5nbGUgbWVzc2FnZSBkZWxpdmVyeSwgdGhpcyBjb3VudGVyIGlzIGluY3JlbWVudGVkIHdoZW4gdGhlIG1lc3NhZ2UgaXMgcmVjZWl2ZWQgYW5kIG5vdCByZXBvcnRlZCB3aGVuIGl0IGlzIHByb2Nlc3NlZC5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgbWV0cmljIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXMgc3ViamVjdCB0byBicmVha2luZyBjaGFuZ2VzIGluIG1pbm9yIHJlbGVhc2VzIG9mIGBAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc2AuXG4gKi9cbmV4cG9ydHMuTUVUUklDX01FU1NBR0lOR19DTElFTlRfQ09OU1VNRURfTUVTU0FHRVMgPSAnbWVzc2FnaW5nLmNsaWVudC5jb25zdW1lZC5tZXNzYWdlcyc7XG4vKipcbiAqIER1cmF0aW9uIG9mIG1lc3NhZ2luZyBvcGVyYXRpb24gaW5pdGlhdGVkIGJ5IGEgcHJvZHVjZXIgb3IgY29uc3VtZXIgY2xpZW50LlxuICpcbiAqIEBub3RlIFRoaXMgbWV0cmljICoqU0hPVUxEIE5PVCoqIGJlIHVzZWQgdG8gcmVwb3J0IHByb2Nlc3NpbmcgZHVyYXRpb24gLSBwcm9jZXNzaW5nIGR1cmF0aW9uIGlzIHJlcG9ydGVkIGluIGBtZXNzYWdpbmcucHJvY2Vzcy5kdXJhdGlvbmAgbWV0cmljLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBtZXRyaWMgaXMgZXhwZXJpbWVudGFsIGFuZCBpcyBzdWJqZWN0IHRvIGJyZWFraW5nIGNoYW5nZXMgaW4gbWlub3IgcmVsZWFzZXMgb2YgYEBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zYC5cbiAqL1xuZXhwb3J0cy5NRVRSSUNfTUVTU0FHSU5HX0NMSUVOVF9PUEVSQVRJT05fRFVSQVRJT04gPSAnbWVzc2FnaW5nLmNsaWVudC5vcGVyYXRpb24uZHVyYXRpb24nO1xuLyoqXG4gKiBOdW1iZXIgb2YgbWVzc2FnZXMgcHJvZHVjZXIgYXR0ZW1wdGVkIHRvIHNlbmQgdG8gdGhlIGJyb2tlci5cbiAqXG4gKiBAbm90ZSBUaGlzIG1ldHJpYyAqKk1VU1QgTk9UKiogY291bnQgbWVzc2FnZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgYnV0IGhhdmVuJ3QgeWV0IGJlZW4gc2VudC5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgbWV0cmljIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXMgc3ViamVjdCB0byBicmVha2luZyBjaGFuZ2VzIGluIG1pbm9yIHJlbGVhc2VzIG9mIGBAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc2AuXG4gKi9cbmV4cG9ydHMuTUVUUklDX01FU1NBR0lOR19DTElFTlRfU0VOVF9NRVNTQUdFUyA9ICdtZXNzYWdpbmcuY2xpZW50LnNlbnQubWVzc2FnZXMnO1xuLyoqXG4gKiBEdXJhdGlvbiBvZiBwcm9jZXNzaW5nIG9wZXJhdGlvbi5cbiAqXG4gKiBAbm90ZSBUaGlzIG1ldHJpYyAqKk1VU1QqKiBiZSByZXBvcnRlZCBmb3Igb3BlcmF0aW9ucyB3aXRoIGBtZXNzYWdpbmcub3BlcmF0aW9uLnR5cGVgIHRoYXQgbWF0Y2hlcyBgcHJvY2Vzc2AuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIG1ldHJpYyBpcyBleHBlcmltZW50YWwgYW5kIGlzIHN1YmplY3QgdG8gYnJlYWtpbmcgY2hhbmdlcyBpbiBtaW5vciByZWxlYXNlcyBvZiBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgLlxuICovXG5leHBvcnRzLk1FVFJJQ19NRVNTQUdJTkdfUFJPQ0VTU19EVVJBVElPTiA9ICdtZXNzYWdpbmcucHJvY2Vzcy5kdXJhdGlvbic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZW1jb252LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/semconv.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/version.js":
/*!********************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/version.js ***!
  \********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;\n// this is autogenerated file, see scripts/version-update.js\nexports.PACKAGE_VERSION = '0.14.0';\nexports.PACKAGE_NAME = '@opentelemetry/instrumentation-kafkajs';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTQuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLHVCQUF1QjtBQUM5QztBQUNBLHVCQUF1QjtBQUN2QixvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jb2R5ZGVhcmtsYW5kL3NlbnRyeXZpYmUvbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTQuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy92ZXJzaW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBUaGUgT3BlblRlbGVtZXRyeSBBdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUEFDS0FHRV9OQU1FID0gZXhwb3J0cy5QQUNLQUdFX1ZFUlNJT04gPSB2b2lkIDA7XG4vLyB0aGlzIGlzIGF1dG9nZW5lcmF0ZWQgZmlsZSwgc2VlIHNjcmlwdHMvdmVyc2lvbi11cGRhdGUuanNcbmV4cG9ydHMuUEFDS0FHRV9WRVJTSU9OID0gJzAuMTQuMCc7XG5leHBvcnRzLlBBQ0tBR0VfTkFNRSA9ICdAb3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24ta2Fma2Fqcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/version.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/index.js":
/*!******************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/index.js ***!
  \******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors, Aspecto\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.KafkaJsInstrumentation = void 0;\nvar instrumentation_1 = __webpack_require__(/*! ./instrumentation */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/instrumentation.js\");\nObject.defineProperty(exports, \"KafkaJsInstrumentation\", ({ enumerable: true, get: function () { return instrumentation_1.KafkaJsInstrumentation; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTQuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEI7QUFDOUIsd0JBQXdCLG1CQUFPLENBQUMsaU5BQW1CO0FBQ25ELDBEQUF5RCxFQUFFLHFDQUFxQyxvREFBb0QsRUFBQztBQUNySiIsInNvdXJjZXMiOlsiL1VzZXJzL2NvZHlkZWFya2xhbmQvc2VudHJ5dmliZS9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWthZmthanNAMC4xNC4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWthZmthanMvYnVpbGQvc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBUaGUgT3BlblRlbGVtZXRyeSBBdXRob3JzLCBBc3BlY3RvXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuS2Fma2FKc0luc3RydW1lbnRhdGlvbiA9IHZvaWQgMDtcbnZhciBpbnN0cnVtZW50YXRpb25fMSA9IHJlcXVpcmUoXCIuL2luc3RydW1lbnRhdGlvblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkthZmthSnNJbnN0cnVtZW50YXRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluc3RydW1lbnRhdGlvbl8xLkthZmthSnNJbnN0cnVtZW50YXRpb247IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/instrumentation.js":
/*!****************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/instrumentation.js ***!
  \****************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval(";globalThis[\"_sentryRewritesTunnelPath\"] = undefined;globalThis[\"SENTRY_RELEASE\"] = undefined;globalThis[\"_sentryBasePath\"] = undefined;globalThis[\"_sentryNextJsVersion\"] = \"15.5.4\";globalThis[\"_sentryRewriteFramesDistDir\"] = \".next\";\n/*\n * Copyright The OpenTelemetry Authors, Aspecto\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.KafkaJsInstrumentation = void 0;\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst instrumentation_1 = __webpack_require__(/*! @opentelemetry/instrumentation */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation@0.204.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation/build/esm/index.js\");\nconst semantic_conventions_1 = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.37.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nconst internal_types_1 = __webpack_require__(/*! ./internal-types */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/internal-types.js\");\nconst propagator_1 = __webpack_require__(/*! ./propagator */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/propagator.js\");\nconst semconv_1 = __webpack_require__(/*! ./semconv */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/semconv.js\");\n/** @knipignore */\nconst version_1 = __webpack_require__(/*! ./version */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/version.js\");\nfunction prepareCounter(meter, value, attributes) {\n    return (errorType) => {\n        meter.add(value, {\n            ...attributes,\n            ...(errorType ? { [semantic_conventions_1.ATTR_ERROR_TYPE]: errorType } : {}),\n        });\n    };\n}\nfunction prepareDurationHistogram(meter, value, attributes) {\n    return (errorType) => {\n        meter.record((Date.now() - value) / 1000, {\n            ...attributes,\n            ...(errorType ? { [semantic_conventions_1.ATTR_ERROR_TYPE]: errorType } : {}),\n        });\n    };\n}\nconst HISTOGRAM_BUCKET_BOUNDARIES = [\n    0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 2.5, 5, 7.5, 10,\n];\nclass KafkaJsInstrumentation extends instrumentation_1.InstrumentationBase {\n    constructor(config = {}) {\n        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);\n    }\n    _updateMetricInstruments() {\n        this._clientDuration = this.meter.createHistogram(semconv_1.METRIC_MESSAGING_CLIENT_OPERATION_DURATION, { advice: { explicitBucketBoundaries: HISTOGRAM_BUCKET_BOUNDARIES } });\n        this._sentMessages = this.meter.createCounter(semconv_1.METRIC_MESSAGING_CLIENT_SENT_MESSAGES);\n        this._consumedMessages = this.meter.createCounter(semconv_1.METRIC_MESSAGING_CLIENT_CONSUMED_MESSAGES);\n        this._processDuration = this.meter.createHistogram(semconv_1.METRIC_MESSAGING_PROCESS_DURATION, { advice: { explicitBucketBoundaries: HISTOGRAM_BUCKET_BOUNDARIES } });\n    }\n    init() {\n        const unpatch = (moduleExports) => {\n            if ((0, instrumentation_1.isWrapped)(moduleExports?.Kafka?.prototype.producer)) {\n                this._unwrap(moduleExports.Kafka.prototype, 'producer');\n            }\n            if ((0, instrumentation_1.isWrapped)(moduleExports?.Kafka?.prototype.consumer)) {\n                this._unwrap(moduleExports.Kafka.prototype, 'consumer');\n            }\n        };\n        const module = new instrumentation_1.InstrumentationNodeModuleDefinition('kafkajs', ['>=0.3.0 <3'], (moduleExports) => {\n            unpatch(moduleExports);\n            this._wrap(moduleExports?.Kafka?.prototype, 'producer', this._getProducerPatch());\n            this._wrap(moduleExports?.Kafka?.prototype, 'consumer', this._getConsumerPatch());\n            return moduleExports;\n        }, unpatch);\n        return module;\n    }\n    _getConsumerPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function consumer(...args) {\n                const newConsumer = original.apply(this, args);\n                if ((0, instrumentation_1.isWrapped)(newConsumer.run)) {\n                    instrumentation._unwrap(newConsumer, 'run');\n                }\n                instrumentation._wrap(newConsumer, 'run', instrumentation._getConsumerRunPatch());\n                instrumentation._setKafkaEventListeners(newConsumer);\n                return newConsumer;\n            };\n        };\n    }\n    _setKafkaEventListeners(kafkaObj) {\n        if (kafkaObj[internal_types_1.EVENT_LISTENERS_SET])\n            return;\n        // The REQUEST Consumer event was added in kafkajs@1.5.0.\n        if (kafkaObj.events?.REQUEST) {\n            kafkaObj.on(kafkaObj.events.REQUEST, this._recordClientDurationMetric.bind(this));\n        }\n        kafkaObj[internal_types_1.EVENT_LISTENERS_SET] = true;\n    }\n    _recordClientDurationMetric(event) {\n        const [address, port] = event.payload.broker.split(':');\n        this._clientDuration.record(event.payload.duration / 1000, {\n            [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n            [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: `${event.payload.apiName}`,\n            [semantic_conventions_1.ATTR_SERVER_ADDRESS]: address,\n            [semantic_conventions_1.ATTR_SERVER_PORT]: Number.parseInt(port, 10),\n        });\n    }\n    _getProducerPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function consumer(...args) {\n                const newProducer = original.apply(this, args);\n                if ((0, instrumentation_1.isWrapped)(newProducer.sendBatch)) {\n                    instrumentation._unwrap(newProducer, 'sendBatch');\n                }\n                instrumentation._wrap(newProducer, 'sendBatch', instrumentation._getSendBatchPatch());\n                if ((0, instrumentation_1.isWrapped)(newProducer.send)) {\n                    instrumentation._unwrap(newProducer, 'send');\n                }\n                instrumentation._wrap(newProducer, 'send', instrumentation._getSendPatch());\n                if ((0, instrumentation_1.isWrapped)(newProducer.transaction)) {\n                    instrumentation._unwrap(newProducer, 'transaction');\n                }\n                instrumentation._wrap(newProducer, 'transaction', instrumentation._getProducerTransactionPatch());\n                instrumentation._setKafkaEventListeners(newProducer);\n                return newProducer;\n            };\n        };\n    }\n    _getConsumerRunPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function run(...args) {\n                const config = args[0];\n                if (config?.eachMessage) {\n                    if ((0, instrumentation_1.isWrapped)(config.eachMessage)) {\n                        instrumentation._unwrap(config, 'eachMessage');\n                    }\n                    instrumentation._wrap(config, 'eachMessage', instrumentation._getConsumerEachMessagePatch());\n                }\n                if (config?.eachBatch) {\n                    if ((0, instrumentation_1.isWrapped)(config.eachBatch)) {\n                        instrumentation._unwrap(config, 'eachBatch');\n                    }\n                    instrumentation._wrap(config, 'eachBatch', instrumentation._getConsumerEachBatchPatch());\n                }\n                return original.call(this, config);\n            };\n        };\n    }\n    _getConsumerEachMessagePatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function eachMessage(...args) {\n                const payload = args[0];\n                const propagatedContext = api_1.propagation.extract(api_1.ROOT_CONTEXT, payload.message.headers, propagator_1.bufferTextMapGetter);\n                const span = instrumentation._startConsumerSpan({\n                    topic: payload.topic,\n                    message: payload.message,\n                    operationType: semconv_1.MESSAGING_OPERATION_TYPE_VALUE_PROCESS,\n                    ctx: propagatedContext,\n                    attributes: {\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.partition),\n                    },\n                });\n                const pendingMetrics = [\n                    prepareDurationHistogram(instrumentation._processDuration, Date.now(), {\n                        [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                        [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'process',\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: payload.topic,\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.partition),\n                    }),\n                    prepareCounter(instrumentation._consumedMessages, 1, {\n                        [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                        [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'process',\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: payload.topic,\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.partition),\n                    }),\n                ];\n                const eachMessagePromise = api_1.context.with(api_1.trace.setSpan(propagatedContext, span), () => {\n                    return original.apply(this, args);\n                });\n                return instrumentation._endSpansOnPromise([span], pendingMetrics, eachMessagePromise);\n            };\n        };\n    }\n    _getConsumerEachBatchPatch() {\n        return (original) => {\n            const instrumentation = this;\n            return function eachBatch(...args) {\n                const payload = args[0];\n                // https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/messaging.md#topic-with-multiple-consumers\n                const receivingSpan = instrumentation._startConsumerSpan({\n                    topic: payload.batch.topic,\n                    message: undefined,\n                    operationType: semconv_1.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE,\n                    ctx: api_1.ROOT_CONTEXT,\n                    attributes: {\n                        [semconv_1.ATTR_MESSAGING_BATCH_MESSAGE_COUNT]: payload.batch.messages.length,\n                        [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.batch.partition),\n                    },\n                });\n                return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), receivingSpan), () => {\n                    const startTime = Date.now();\n                    const spans = [];\n                    const pendingMetrics = [\n                        prepareCounter(instrumentation._consumedMessages, payload.batch.messages.length, {\n                            [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                            [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'process',\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: payload.batch.topic,\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.batch.partition),\n                        }),\n                    ];\n                    payload.batch.messages.forEach(message => {\n                        const propagatedContext = api_1.propagation.extract(api_1.ROOT_CONTEXT, message.headers, propagator_1.bufferTextMapGetter);\n                        const spanContext = api_1.trace\n                            .getSpan(propagatedContext)\n                            ?.spanContext();\n                        let origSpanLink;\n                        if (spanContext) {\n                            origSpanLink = {\n                                context: spanContext,\n                            };\n                        }\n                        spans.push(instrumentation._startConsumerSpan({\n                            topic: payload.batch.topic,\n                            message,\n                            operationType: semconv_1.MESSAGING_OPERATION_TYPE_VALUE_PROCESS,\n                            link: origSpanLink,\n                            attributes: {\n                                [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.batch.partition),\n                            },\n                        }));\n                        pendingMetrics.push(prepareDurationHistogram(instrumentation._processDuration, startTime, {\n                            [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                            [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'process',\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: payload.batch.topic,\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.batch.partition),\n                        }));\n                    });\n                    const batchMessagePromise = original.apply(this, args);\n                    spans.unshift(receivingSpan);\n                    return instrumentation._endSpansOnPromise(spans, pendingMetrics, batchMessagePromise);\n                });\n            };\n        };\n    }\n    _getProducerTransactionPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function transaction(...args) {\n                const transactionSpan = instrumentation.tracer.startSpan('transaction');\n                const transactionPromise = original.apply(this, args);\n                transactionPromise\n                    .then((transaction) => {\n                    const originalSend = transaction.send;\n                    transaction.send = function send(...args) {\n                        return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), transactionSpan), () => {\n                            const patched = instrumentation._getSendPatch()(originalSend);\n                            return patched.apply(this, args).catch(err => {\n                                transactionSpan.setStatus({\n                                    code: api_1.SpanStatusCode.ERROR,\n                                    message: err?.message,\n                                });\n                                transactionSpan.recordException(err);\n                                throw err;\n                            });\n                        });\n                    };\n                    const originalSendBatch = transaction.sendBatch;\n                    transaction.sendBatch = function sendBatch(...args) {\n                        return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), transactionSpan), () => {\n                            const patched = instrumentation._getSendBatchPatch()(originalSendBatch);\n                            return patched.apply(this, args).catch(err => {\n                                transactionSpan.setStatus({\n                                    code: api_1.SpanStatusCode.ERROR,\n                                    message: err?.message,\n                                });\n                                transactionSpan.recordException(err);\n                                throw err;\n                            });\n                        });\n                    };\n                    const originalCommit = transaction.commit;\n                    transaction.commit = function commit(...args) {\n                        const originCommitPromise = originalCommit\n                            .apply(this, args)\n                            .then(() => {\n                            transactionSpan.setStatus({ code: api_1.SpanStatusCode.OK });\n                        });\n                        return instrumentation._endSpansOnPromise([transactionSpan], [], originCommitPromise);\n                    };\n                    const originalAbort = transaction.abort;\n                    transaction.abort = function abort(...args) {\n                        const originAbortPromise = originalAbort.apply(this, args);\n                        return instrumentation._endSpansOnPromise([transactionSpan], [], originAbortPromise);\n                    };\n                })\n                    .catch(err => {\n                    transactionSpan.setStatus({\n                        code: api_1.SpanStatusCode.ERROR,\n                        message: err?.message,\n                    });\n                    transactionSpan.recordException(err);\n                    transactionSpan.end();\n                });\n                return transactionPromise;\n            };\n        };\n    }\n    _getSendBatchPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function sendBatch(...args) {\n                const batch = args[0];\n                const messages = batch.topicMessages || [];\n                const spans = [];\n                const pendingMetrics = [];\n                messages.forEach(topicMessage => {\n                    topicMessage.messages.forEach(message => {\n                        spans.push(instrumentation._startProducerSpan(topicMessage.topic, message));\n                        pendingMetrics.push(prepareCounter(instrumentation._sentMessages, 1, {\n                            [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                            [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'send',\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: topicMessage.topic,\n                            ...(message.partition !== undefined\n                                ? {\n                                    [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(message.partition),\n                                }\n                                : {}),\n                        }));\n                    });\n                });\n                const origSendResult = original.apply(this, args);\n                return instrumentation._endSpansOnPromise(spans, pendingMetrics, origSendResult);\n            };\n        };\n    }\n    _getSendPatch() {\n        const instrumentation = this;\n        return (original) => {\n            return function send(...args) {\n                const record = args[0];\n                const spans = record.messages.map(message => {\n                    return instrumentation._startProducerSpan(record.topic, message);\n                });\n                const pendingMetrics = record.messages.map(m => prepareCounter(instrumentation._sentMessages, 1, {\n                    [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                    [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'send',\n                    [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: record.topic,\n                    ...(m.partition !== undefined\n                        ? {\n                            [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(m.partition),\n                        }\n                        : {}),\n                }));\n                const origSendResult = original.apply(this, args);\n                return instrumentation._endSpansOnPromise(spans, pendingMetrics, origSendResult);\n            };\n        };\n    }\n    _endSpansOnPromise(spans, pendingMetrics, sendPromise) {\n        return Promise.resolve(sendPromise)\n            .then(result => {\n            pendingMetrics.forEach(m => m());\n            return result;\n        })\n            .catch(reason => {\n            let errorMessage;\n            let errorType = semantic_conventions_1.ERROR_TYPE_VALUE_OTHER;\n            if (typeof reason === 'string' || reason === undefined) {\n                errorMessage = reason;\n            }\n            else if (typeof reason === 'object' &&\n                Object.prototype.hasOwnProperty.call(reason, 'message')) {\n                errorMessage = reason.message;\n                errorType = reason.constructor.name;\n            }\n            pendingMetrics.forEach(m => m(errorType));\n            spans.forEach(span => {\n                span.setAttribute(semantic_conventions_1.ATTR_ERROR_TYPE, errorType);\n                span.setStatus({\n                    code: api_1.SpanStatusCode.ERROR,\n                    message: errorMessage,\n                });\n            });\n            throw reason;\n        })\n            .finally(() => {\n            spans.forEach(span => span.end());\n        });\n    }\n    _startConsumerSpan({ topic, message, operationType, ctx, link, attributes, }) {\n        const operationName = operationType === semconv_1.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE\n            ? 'poll' // for batch processing spans\n            : operationType; // for individual message processing spans\n        const span = this.tracer.startSpan(`${operationName} ${topic}`, {\n            kind: operationType === semconv_1.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE\n                ? api_1.SpanKind.CLIENT\n                : api_1.SpanKind.CONSUMER,\n            attributes: {\n                ...attributes,\n                [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: topic,\n                [semconv_1.ATTR_MESSAGING_OPERATION_TYPE]: operationType,\n                [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: operationName,\n                [semconv_1.ATTR_MESSAGING_KAFKA_MESSAGE_KEY]: message?.key\n                    ? String(message.key)\n                    : undefined,\n                [semconv_1.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE]: message?.key && message.value === null ? true : undefined,\n                [semconv_1.ATTR_MESSAGING_KAFKA_OFFSET]: message?.offset,\n            },\n            links: link ? [link] : [],\n        }, ctx);\n        const { consumerHook } = this.getConfig();\n        if (consumerHook && message) {\n            (0, instrumentation_1.safeExecuteInTheMiddle)(() => consumerHook(span, { topic, message }), e => {\n                if (e)\n                    this._diag.error('consumerHook error', e);\n            }, true);\n        }\n        return span;\n    }\n    _startProducerSpan(topic, message) {\n        const span = this.tracer.startSpan(`send ${topic}`, {\n            kind: api_1.SpanKind.PRODUCER,\n            attributes: {\n                [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,\n                [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: topic,\n                [semconv_1.ATTR_MESSAGING_KAFKA_MESSAGE_KEY]: message.key\n                    ? String(message.key)\n                    : undefined,\n                [semconv_1.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE]: message.key && message.value === null ? true : undefined,\n                [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: message.partition !== undefined\n                    ? String(message.partition)\n                    : undefined,\n                [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: 'send',\n                [semconv_1.ATTR_MESSAGING_OPERATION_TYPE]: semconv_1.MESSAGING_OPERATION_TYPE_VALUE_SEND,\n            },\n        });\n        message.headers = message.headers ?? {};\n        api_1.propagation.inject(api_1.trace.setSpan(api_1.context.active(), span), message.headers);\n        const { producerHook } = this.getConfig();\n        if (producerHook) {\n            (0, instrumentation_1.safeExecuteInTheMiddle)(() => producerHook(span, { topic, message }), e => {\n                if (e)\n                    this._diag.error('producerHook error', e);\n            }, true);\n        }\n        return span;\n    }\n}\nexports.KafkaJsInstrumentation = KafkaJsInstrumentation;\n//# sourceMappingURL=instrumentation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTQuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy9pbnN0cnVtZW50YXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWEsQ0FBQyxvREFBb0QseUNBQXlDLDBDQUEwQyw4Q0FBOEM7QUFDbk07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QjtBQUM5QixjQUFjLG1CQUFPLENBQUMsc0lBQW9CO0FBQzFDLDBCQUEwQixtQkFBTyxDQUFDLHFNQUFnQztBQUNsRSwrQkFBK0IsbUJBQU8sQ0FBQywwTEFBcUM7QUFDNUUseUJBQXlCLG1CQUFPLENBQUMsK01BQWtCO0FBQ25ELHFCQUFxQixtQkFBTyxDQUFDLHVNQUFjO0FBQzNDLGtCQUFrQixtQkFBTyxDQUFDLGlNQUFXO0FBQ3JDO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsaU1BQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0RBQXNELElBQUk7QUFDeEYsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzREFBc0QsSUFBSTtBQUN4RixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGtIQUFrSCxVQUFVLHlEQUF5RDtBQUNyTDtBQUNBO0FBQ0EsMEdBQTBHLFVBQVUseURBQXlEO0FBQzdLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHNCQUFzQjtBQUNoRjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCwrQkFBK0I7QUFDdkYseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHlCQUF5Qix1REFBdUQ7QUFDaEY7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qiw4Q0FBOEMsZUFBZSxFQUFFLE1BQU07QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBLHFGQUFxRixnQkFBZ0I7QUFDckc7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxNQUFNO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQSxxRkFBcUYsZ0JBQWdCO0FBQ3JHO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jb2R5ZGVhcmtsYW5kL3NlbnRyeXZpYmUvbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTQuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy9pbnN0cnVtZW50YXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7O2dsb2JhbFRoaXNbXCJfc2VudHJ5UmV3cml0ZXNUdW5uZWxQYXRoXCJdID0gdW5kZWZpbmVkO2dsb2JhbFRoaXNbXCJTRU5UUllfUkVMRUFTRVwiXSA9IHVuZGVmaW5lZDtnbG9iYWxUaGlzW1wiX3NlbnRyeUJhc2VQYXRoXCJdID0gdW5kZWZpbmVkO2dsb2JhbFRoaXNbXCJfc2VudHJ5TmV4dEpzVmVyc2lvblwiXSA9IFwiMTUuNS40XCI7Z2xvYmFsVGhpc1tcIl9zZW50cnlSZXdyaXRlRnJhbWVzRGlzdERpclwiXSA9IFwiLm5leHRcIjtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9ycywgQXNwZWN0b1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkthZmthSnNJbnN0cnVtZW50YXRpb24gPSB2b2lkIDA7XG5jb25zdCBhcGlfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9hcGlcIik7XG5jb25zdCBpbnN0cnVtZW50YXRpb25fMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb25cIik7XG5jb25zdCBzZW1hbnRpY19jb252ZW50aW9uc18xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zXCIpO1xuY29uc3QgaW50ZXJuYWxfdHlwZXNfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsLXR5cGVzXCIpO1xuY29uc3QgcHJvcGFnYXRvcl8xID0gcmVxdWlyZShcIi4vcHJvcGFnYXRvclwiKTtcbmNvbnN0IHNlbWNvbnZfMSA9IHJlcXVpcmUoXCIuL3NlbWNvbnZcIik7XG4vKiogQGtuaXBpZ25vcmUgKi9cbmNvbnN0IHZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL3ZlcnNpb25cIik7XG5mdW5jdGlvbiBwcmVwYXJlQ291bnRlcihtZXRlciwgdmFsdWUsIGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gKGVycm9yVHlwZSkgPT4ge1xuICAgICAgICBtZXRlci5hZGQodmFsdWUsIHtcbiAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAuLi4oZXJyb3JUeXBlID8geyBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0VSUk9SX1RZUEVdOiBlcnJvclR5cGUgfSA6IHt9KSxcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVEdXJhdGlvbkhpc3RvZ3JhbShtZXRlciwgdmFsdWUsIGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gKGVycm9yVHlwZSkgPT4ge1xuICAgICAgICBtZXRlci5yZWNvcmQoKERhdGUubm93KCkgLSB2YWx1ZSkgLyAxMDAwLCB7XG4gICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgLi4uKGVycm9yVHlwZSA/IHsgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9FUlJPUl9UWVBFXTogZXJyb3JUeXBlIH0gOiB7fSksXG4gICAgICAgIH0pO1xuICAgIH07XG59XG5jb25zdCBISVNUT0dSQU1fQlVDS0VUX0JPVU5EQVJJRVMgPSBbXG4gICAgMC4wMDUsIDAuMDEsIDAuMDI1LCAwLjA1LCAwLjA3NSwgMC4xLCAwLjI1LCAwLjUsIDAuNzUsIDEsIDIuNSwgNSwgNy41LCAxMCxcbl07XG5jbGFzcyBLYWZrYUpzSW5zdHJ1bWVudGF0aW9uIGV4dGVuZHMgaW5zdHJ1bWVudGF0aW9uXzEuSW5zdHJ1bWVudGF0aW9uQmFzZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgc3VwZXIodmVyc2lvbl8xLlBBQ0tBR0VfTkFNRSwgdmVyc2lvbl8xLlBBQ0tBR0VfVkVSU0lPTiwgY29uZmlnKTtcbiAgICB9XG4gICAgX3VwZGF0ZU1ldHJpY0luc3RydW1lbnRzKCkge1xuICAgICAgICB0aGlzLl9jbGllbnREdXJhdGlvbiA9IHRoaXMubWV0ZXIuY3JlYXRlSGlzdG9ncmFtKHNlbWNvbnZfMS5NRVRSSUNfTUVTU0FHSU5HX0NMSUVOVF9PUEVSQVRJT05fRFVSQVRJT04sIHsgYWR2aWNlOiB7IGV4cGxpY2l0QnVja2V0Qm91bmRhcmllczogSElTVE9HUkFNX0JVQ0tFVF9CT1VOREFSSUVTIH0gfSk7XG4gICAgICAgIHRoaXMuX3NlbnRNZXNzYWdlcyA9IHRoaXMubWV0ZXIuY3JlYXRlQ291bnRlcihzZW1jb252XzEuTUVUUklDX01FU1NBR0lOR19DTElFTlRfU0VOVF9NRVNTQUdFUyk7XG4gICAgICAgIHRoaXMuX2NvbnN1bWVkTWVzc2FnZXMgPSB0aGlzLm1ldGVyLmNyZWF0ZUNvdW50ZXIoc2VtY29udl8xLk1FVFJJQ19NRVNTQUdJTkdfQ0xJRU5UX0NPTlNVTUVEX01FU1NBR0VTKTtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc0R1cmF0aW9uID0gdGhpcy5tZXRlci5jcmVhdGVIaXN0b2dyYW0oc2VtY29udl8xLk1FVFJJQ19NRVNTQUdJTkdfUFJPQ0VTU19EVVJBVElPTiwgeyBhZHZpY2U6IHsgZXhwbGljaXRCdWNrZXRCb3VuZGFyaWVzOiBISVNUT0dSQU1fQlVDS0VUX0JPVU5EQVJJRVMgfSB9KTtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgY29uc3QgdW5wYXRjaCA9IChtb2R1bGVFeHBvcnRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cz8uS2Fma2E/LnByb3RvdHlwZS5wcm9kdWNlcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5LYWZrYS5wcm90b3R5cGUsICdwcm9kdWNlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHM/LkthZmthPy5wcm90b3R5cGUuY29uc3VtZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMuS2Fma2EucHJvdG90eXBlLCAnY29uc3VtZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbW9kdWxlID0gbmV3IGluc3RydW1lbnRhdGlvbl8xLkluc3RydW1lbnRhdGlvbk5vZGVNb2R1bGVEZWZpbml0aW9uKCdrYWZrYWpzJywgWyc+PTAuMy4wIDwzJ10sIChtb2R1bGVFeHBvcnRzKSA9PiB7XG4gICAgICAgICAgICB1bnBhdGNoKG1vZHVsZUV4cG9ydHMpO1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzPy5LYWZrYT8ucHJvdG90eXBlLCAncHJvZHVjZXInLCB0aGlzLl9nZXRQcm9kdWNlclBhdGNoKCkpO1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzPy5LYWZrYT8ucHJvdG90eXBlLCAnY29uc3VtZXInLCB0aGlzLl9nZXRDb25zdW1lclBhdGNoKCkpO1xuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZUV4cG9ydHM7XG4gICAgICAgIH0sIHVucGF0Y2gpO1xuICAgICAgICByZXR1cm4gbW9kdWxlO1xuICAgIH1cbiAgICBfZ2V0Q29uc3VtZXJQYXRjaCgpIHtcbiAgICAgICAgY29uc3QgaW5zdHJ1bWVudGF0aW9uID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChvcmlnaW5hbCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNvbnN1bWVyKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDb25zdW1lciA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShuZXdDb25zdW1lci5ydW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fdW53cmFwKG5ld0NvbnN1bWVyLCAncnVuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fd3JhcChuZXdDb25zdW1lciwgJ3J1bicsIGluc3RydW1lbnRhdGlvbi5fZ2V0Q29uc3VtZXJSdW5QYXRjaCgpKTtcbiAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX3NldEthZmthRXZlbnRMaXN0ZW5lcnMobmV3Q29uc3VtZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdDb25zdW1lcjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9zZXRLYWZrYUV2ZW50TGlzdGVuZXJzKGthZmthT2JqKSB7XG4gICAgICAgIGlmIChrYWZrYU9ialtpbnRlcm5hbF90eXBlc18xLkVWRU5UX0xJU1RFTkVSU19TRVRdKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBUaGUgUkVRVUVTVCBDb25zdW1lciBldmVudCB3YXMgYWRkZWQgaW4ga2Fma2Fqc0AxLjUuMC5cbiAgICAgICAgaWYgKGthZmthT2JqLmV2ZW50cz8uUkVRVUVTVCkge1xuICAgICAgICAgICAga2Fma2FPYmoub24oa2Fma2FPYmouZXZlbnRzLlJFUVVFU1QsIHRoaXMuX3JlY29yZENsaWVudER1cmF0aW9uTWV0cmljLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIGthZmthT2JqW2ludGVybmFsX3R5cGVzXzEuRVZFTlRfTElTVEVORVJTX1NFVF0gPSB0cnVlO1xuICAgIH1cbiAgICBfcmVjb3JkQ2xpZW50RHVyYXRpb25NZXRyaWMoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgW2FkZHJlc3MsIHBvcnRdID0gZXZlbnQucGF5bG9hZC5icm9rZXIuc3BsaXQoJzonKTtcbiAgICAgICAgdGhpcy5fY2xpZW50RHVyYXRpb24ucmVjb3JkKGV2ZW50LnBheWxvYWQuZHVyYXRpb24gLyAxMDAwLCB7XG4gICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX1NZU1RFTV06IHNlbWNvbnZfMS5NRVNTQUdJTkdfU1lTVEVNX1ZBTFVFX0tBRktBLFxuICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fTkFNRV06IGAke2V2ZW50LnBheWxvYWQuYXBpTmFtZX1gLFxuICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9TRVJWRVJfQUREUkVTU106IGFkZHJlc3MsXG4gICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1NFUlZFUl9QT1JUXTogTnVtYmVyLnBhcnNlSW50KHBvcnQsIDEwKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRQcm9kdWNlclBhdGNoKCkge1xuICAgICAgICBjb25zdCBpbnN0cnVtZW50YXRpb24gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKG9yaWdpbmFsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY29uc3VtZXIoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Byb2R1Y2VyID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG5ld1Byb2R1Y2VyLnNlbmRCYXRjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl91bndyYXAobmV3UHJvZHVjZXIsICdzZW5kQmF0Y2gnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl93cmFwKG5ld1Byb2R1Y2VyLCAnc2VuZEJhdGNoJywgaW5zdHJ1bWVudGF0aW9uLl9nZXRTZW5kQmF0Y2hQYXRjaCgpKTtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobmV3UHJvZHVjZXIuc2VuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl91bndyYXAobmV3UHJvZHVjZXIsICdzZW5kJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fd3JhcChuZXdQcm9kdWNlciwgJ3NlbmQnLCBpbnN0cnVtZW50YXRpb24uX2dldFNlbmRQYXRjaCgpKTtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobmV3UHJvZHVjZXIudHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fdW53cmFwKG5ld1Byb2R1Y2VyLCAndHJhbnNhY3Rpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl93cmFwKG5ld1Byb2R1Y2VyLCAndHJhbnNhY3Rpb24nLCBpbnN0cnVtZW50YXRpb24uX2dldFByb2R1Y2VyVHJhbnNhY3Rpb25QYXRjaCgpKTtcbiAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX3NldEthZmthRXZlbnRMaXN0ZW5lcnMobmV3UHJvZHVjZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdQcm9kdWNlcjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9nZXRDb25zdW1lclJ1blBhdGNoKCkge1xuICAgICAgICBjb25zdCBpbnN0cnVtZW50YXRpb24gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKG9yaWdpbmFsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gcnVuKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25maWcgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIGlmIChjb25maWc/LmVhY2hNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShjb25maWcuZWFjaE1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX3Vud3JhcChjb25maWcsICdlYWNoTWVzc2FnZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fd3JhcChjb25maWcsICdlYWNoTWVzc2FnZScsIGluc3RydW1lbnRhdGlvbi5fZ2V0Q29uc3VtZXJFYWNoTWVzc2FnZVBhdGNoKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnPy5lYWNoQmF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKGNvbmZpZy5lYWNoQmF0Y2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX3Vud3JhcChjb25maWcsICdlYWNoQmF0Y2gnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX3dyYXAoY29uZmlnLCAnZWFjaEJhdGNoJywgaW5zdHJ1bWVudGF0aW9uLl9nZXRDb25zdW1lckVhY2hCYXRjaFBhdGNoKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2dldENvbnN1bWVyRWFjaE1lc3NhZ2VQYXRjaCgpIHtcbiAgICAgICAgY29uc3QgaW5zdHJ1bWVudGF0aW9uID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChvcmlnaW5hbCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGVhY2hNZXNzYWdlKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wYWdhdGVkQ29udGV4dCA9IGFwaV8xLnByb3BhZ2F0aW9uLmV4dHJhY3QoYXBpXzEuUk9PVF9DT05URVhULCBwYXlsb2FkLm1lc3NhZ2UuaGVhZGVycywgcHJvcGFnYXRvcl8xLmJ1ZmZlclRleHRNYXBHZXR0ZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwYW4gPSBpbnN0cnVtZW50YXRpb24uX3N0YXJ0Q29uc3VtZXJTcGFuKHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWM6IHBheWxvYWQudG9waWMsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHBheWxvYWQubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uVHlwZTogc2VtY29udl8xLk1FU1NBR0lOR19PUEVSQVRJT05fVFlQRV9WQUxVRV9QUk9DRVNTLFxuICAgICAgICAgICAgICAgICAgICBjdHg6IHByb3BhZ2F0ZWRDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX1BBUlRJVElPTl9JRF06IFN0cmluZyhwYXlsb2FkLnBhcnRpdGlvbiksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGVuZGluZ01ldHJpY3MgPSBbXG4gICAgICAgICAgICAgICAgICAgIHByZXBhcmVEdXJhdGlvbkhpc3RvZ3JhbShpbnN0cnVtZW50YXRpb24uX3Byb2Nlc3NEdXJhdGlvbiwgRGF0ZS5ub3coKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19TWVNURU1dOiBzZW1jb252XzEuTUVTU0FHSU5HX1NZU1RFTV9WQUxVRV9LQUZLQSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfT1BFUkFUSU9OX05BTUVdOiAncHJvY2VzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX05BTUVdOiBwYXlsb2FkLnRvcGljLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9QQVJUSVRJT05fSURdOiBTdHJpbmcocGF5bG9hZC5wYXJ0aXRpb24pLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgcHJlcGFyZUNvdW50ZXIoaW5zdHJ1bWVudGF0aW9uLl9jb25zdW1lZE1lc3NhZ2VzLCAxLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX1NZU1RFTV06IHNlbWNvbnZfMS5NRVNTQUdJTkdfU1lTVEVNX1ZBTFVFX0tBRktBLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fTkFNRV06ICdwcm9jZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fTkFNRV06IHBheWxvYWQudG9waWMsXG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX1BBUlRJVElPTl9JRF06IFN0cmluZyhwYXlsb2FkLnBhcnRpdGlvbiksXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgY29uc3QgZWFjaE1lc3NhZ2VQcm9taXNlID0gYXBpXzEuY29udGV4dC53aXRoKGFwaV8xLnRyYWNlLnNldFNwYW4ocHJvcGFnYXRlZENvbnRleHQsIHNwYW4pLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdHJ1bWVudGF0aW9uLl9lbmRTcGFuc09uUHJvbWlzZShbc3Bhbl0sIHBlbmRpbmdNZXRyaWNzLCBlYWNoTWVzc2FnZVByb21pc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2dldENvbnN1bWVyRWFjaEJhdGNoUGF0Y2goKSB7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbiA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gZWFjaEJhdGNoKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vb3Blbi10ZWxlbWV0cnkvb3BlbnRlbGVtZXRyeS1zcGVjaWZpY2F0aW9uL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vdHJhY2Uvc2VtYW50aWNfY29udmVudGlvbnMvbWVzc2FnaW5nLm1kI3RvcGljLXdpdGgtbXVsdGlwbGUtY29uc3VtZXJzXG4gICAgICAgICAgICAgICAgY29uc3QgcmVjZWl2aW5nU3BhbiA9IGluc3RydW1lbnRhdGlvbi5fc3RhcnRDb25zdW1lclNwYW4oe1xuICAgICAgICAgICAgICAgICAgICB0b3BpYzogcGF5bG9hZC5iYXRjaC50b3BpYyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25UeXBlOiBzZW1jb252XzEuTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFX1ZBTFVFX1JFQ0VJVkUsXG4gICAgICAgICAgICAgICAgICAgIGN0eDogYXBpXzEuUk9PVF9DT05URVhULFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0JBVENIX01FU1NBR0VfQ09VTlRdOiBwYXlsb2FkLmJhdGNoLm1lc3NhZ2VzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fUEFSVElUSU9OX0lEXTogU3RyaW5nKHBheWxvYWQuYmF0Y2gucGFydGl0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBpXzEuY29udGV4dC53aXRoKGFwaV8xLnRyYWNlLnNldFNwYW4oYXBpXzEuY29udGV4dC5hY3RpdmUoKSwgcmVjZWl2aW5nU3BhbiksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BhbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVuZGluZ01ldHJpY3MgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVwYXJlQ291bnRlcihpbnN0cnVtZW50YXRpb24uX2NvbnN1bWVkTWVzc2FnZXMsIHBheWxvYWQuYmF0Y2gubWVzc2FnZXMubGVuZ3RoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19TWVNURU1dOiBzZW1jb252XzEuTUVTU0FHSU5HX1NZU1RFTV9WQUxVRV9LQUZLQSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9OQU1FXTogJ3Byb2Nlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fTkFNRV06IHBheWxvYWQuYmF0Y2gudG9waWMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9QQVJUSVRJT05fSURdOiBTdHJpbmcocGF5bG9hZC5iYXRjaC5wYXJ0aXRpb24pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQuYmF0Y2gubWVzc2FnZXMuZm9yRWFjaChtZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BhZ2F0ZWRDb250ZXh0ID0gYXBpXzEucHJvcGFnYXRpb24uZXh0cmFjdChhcGlfMS5ST09UX0NPTlRFWFQsIG1lc3NhZ2UuaGVhZGVycywgcHJvcGFnYXRvcl8xLmJ1ZmZlclRleHRNYXBHZXR0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BhbkNvbnRleHQgPSBhcGlfMS50cmFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRTcGFuKHByb3BhZ2F0ZWRDb250ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8uc3BhbkNvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvcmlnU3Bhbkxpbms7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BhbkNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnU3BhbkxpbmsgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHNwYW5Db250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFucy5wdXNoKGluc3RydW1lbnRhdGlvbi5fc3RhcnRDb25zdW1lclNwYW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcGljOiBwYXlsb2FkLmJhdGNoLnRvcGljLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uVHlwZTogc2VtY29udl8xLk1FU1NBR0lOR19PUEVSQVRJT05fVFlQRV9WQUxVRV9QUk9DRVNTLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbms6IG9yaWdTcGFuTGluayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fUEFSVElUSU9OX0lEXTogU3RyaW5nKHBheWxvYWQuYmF0Y2gucGFydGl0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ01ldHJpY3MucHVzaChwcmVwYXJlRHVyYXRpb25IaXN0b2dyYW0oaW5zdHJ1bWVudGF0aW9uLl9wcm9jZXNzRHVyYXRpb24sIHN0YXJ0VGltZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfU1lTVEVNXTogc2VtY29udl8xLk1FU1NBR0lOR19TWVNURU1fVkFMVUVfS0FGS0EsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fTkFNRV06ICdwcm9jZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX05BTUVdOiBwYXlsb2FkLmJhdGNoLnRvcGljLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fUEFSVElUSU9OX0lEXTogU3RyaW5nKHBheWxvYWQuYmF0Y2gucGFydGl0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoTWVzc2FnZVByb21pc2UgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgc3BhbnMudW5zaGlmdChyZWNlaXZpbmdTcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RydW1lbnRhdGlvbi5fZW5kU3BhbnNPblByb21pc2Uoc3BhbnMsIHBlbmRpbmdNZXRyaWNzLCBiYXRjaE1lc3NhZ2VQcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9nZXRQcm9kdWNlclRyYW5zYWN0aW9uUGF0Y2goKSB7XG4gICAgICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbiA9IHRoaXM7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiB0cmFuc2FjdGlvbiguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25TcGFuID0gaW5zdHJ1bWVudGF0aW9uLnRyYWNlci5zdGFydFNwYW4oJ3RyYW5zYWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25Qcm9taXNlID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25Qcm9taXNlXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCh0cmFuc2FjdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFNlbmQgPSB0cmFuc2FjdGlvbi5zZW5kO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5zZW5kID0gZnVuY3Rpb24gc2VuZCguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXBpXzEuY29udGV4dC53aXRoKGFwaV8xLnRyYWNlLnNldFNwYW4oYXBpXzEuY29udGV4dC5hY3RpdmUoKSwgdHJhbnNhY3Rpb25TcGFuKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGNoZWQgPSBpbnN0cnVtZW50YXRpb24uX2dldFNlbmRQYXRjaCgpKG9yaWdpbmFsU2VuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGNoZWQuYXBwbHkodGhpcywgYXJncykuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TcGFuLnNldFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycj8ubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uU3Bhbi5yZWNvcmRFeGNlcHRpb24oZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU2VuZEJhdGNoID0gdHJhbnNhY3Rpb24uc2VuZEJhdGNoO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5zZW5kQmF0Y2ggPSBmdW5jdGlvbiBzZW5kQmF0Y2goLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwaV8xLmNvbnRleHQud2l0aChhcGlfMS50cmFjZS5zZXRTcGFuKGFwaV8xLmNvbnRleHQuYWN0aXZlKCksIHRyYW5zYWN0aW9uU3BhbiksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRjaGVkID0gaW5zdHJ1bWVudGF0aW9uLl9nZXRTZW5kQmF0Y2hQYXRjaCgpKG9yaWdpbmFsU2VuZEJhdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0Y2hlZC5hcHBseSh0aGlzLCBhcmdzKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvblNwYW4uc2V0U3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGFwaV8xLlNwYW5TdGF0dXNDb2RlLkVSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyPy5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TcGFuLnJlY29yZEV4Y2VwdGlvbihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxDb21taXQgPSB0cmFuc2FjdGlvbi5jb21taXQ7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmNvbW1pdCA9IGZ1bmN0aW9uIGNvbW1pdCguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5Db21taXRQcm9taXNlID0gb3JpZ2luYWxDb21taXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwbHkodGhpcywgYXJncylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TcGFuLnNldFN0YXR1cyh7IGNvZGU6IGFwaV8xLlNwYW5TdGF0dXNDb2RlLk9LIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zdHJ1bWVudGF0aW9uLl9lbmRTcGFuc09uUHJvbWlzZShbdHJhbnNhY3Rpb25TcGFuXSwgW10sIG9yaWdpbkNvbW1pdFByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbEFib3J0ID0gdHJhbnNhY3Rpb24uYWJvcnQ7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luQWJvcnRQcm9taXNlID0gb3JpZ2luYWxBYm9ydC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnN0cnVtZW50YXRpb24uX2VuZFNwYW5zT25Qcm9taXNlKFt0cmFuc2FjdGlvblNwYW5dLCBbXSwgb3JpZ2luQWJvcnRQcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TcGFuLnNldFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycj8ubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uU3Bhbi5yZWNvcmRFeGNlcHRpb24oZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TcGFuLmVuZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvblByb21pc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBfZ2V0U2VuZEJhdGNoUGF0Y2goKSB7XG4gICAgICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbiA9IHRoaXM7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBzZW5kQmF0Y2goLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlcyA9IGJhdGNoLnRvcGljTWVzc2FnZXMgfHwgW107XG4gICAgICAgICAgICAgICAgY29uc3Qgc3BhbnMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwZW5kaW5nTWV0cmljcyA9IFtdO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VzLmZvckVhY2godG9waWNNZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNNZXNzYWdlLm1lc3NhZ2VzLmZvckVhY2gobWVzc2FnZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFucy5wdXNoKGluc3RydW1lbnRhdGlvbi5fc3RhcnRQcm9kdWNlclNwYW4odG9waWNNZXNzYWdlLnRvcGljLCBtZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nTWV0cmljcy5wdXNoKHByZXBhcmVDb3VudGVyKGluc3RydW1lbnRhdGlvbi5fc2VudE1lc3NhZ2VzLCAxLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19TWVNURU1dOiBzZW1jb252XzEuTUVTU0FHSU5HX1NZU1RFTV9WQUxVRV9LQUZLQSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9OQU1FXTogJ3NlbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fTkFNRV06IHRvcGljTWVzc2FnZS50b3BpYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4obWVzc2FnZS5wYXJ0aXRpb24gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfREVTVElOQVRJT05fUEFSVElUSU9OX0lEXTogU3RyaW5nKG1lc3NhZ2UucGFydGl0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ1NlbmRSZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdHJ1bWVudGF0aW9uLl9lbmRTcGFuc09uUHJvbWlzZShzcGFucywgcGVuZGluZ01ldHJpY3MsIG9yaWdTZW5kUmVzdWx0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9nZXRTZW5kUGF0Y2goKSB7XG4gICAgICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbiA9IHRoaXM7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBzZW5kKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWNvcmQgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwYW5zID0gcmVjb3JkLm1lc3NhZ2VzLm1hcChtZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RydW1lbnRhdGlvbi5fc3RhcnRQcm9kdWNlclNwYW4ocmVjb3JkLnRvcGljLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwZW5kaW5nTWV0cmljcyA9IHJlY29yZC5tZXNzYWdlcy5tYXAobSA9PiBwcmVwYXJlQ291bnRlcihpbnN0cnVtZW50YXRpb24uX3NlbnRNZXNzYWdlcywgMSwge1xuICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX1NZU1RFTV06IHNlbWNvbnZfMS5NRVNTQUdJTkdfU1lTVEVNX1ZBTFVFX0tBRktBLFxuICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9OQU1FXTogJ3NlbmQnLFxuICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX05BTUVdOiByZWNvcmQudG9waWMsXG4gICAgICAgICAgICAgICAgICAgIC4uLihtLnBhcnRpdGlvbiAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX1BBUlRJVElPTl9JRF06IFN0cmluZyhtLnBhcnRpdGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ1NlbmRSZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdHJ1bWVudGF0aW9uLl9lbmRTcGFuc09uUHJvbWlzZShzcGFucywgcGVuZGluZ01ldHJpY3MsIG9yaWdTZW5kUmVzdWx0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9lbmRTcGFuc09uUHJvbWlzZShzcGFucywgcGVuZGluZ01ldHJpY3MsIHNlbmRQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2VuZFByb21pc2UpXG4gICAgICAgICAgICAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgcGVuZGluZ01ldHJpY3MuZm9yRWFjaChtID0+IG0oKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICAgICAgICBsZXQgZXJyb3JNZXNzYWdlO1xuICAgICAgICAgICAgbGV0IGVycm9yVHlwZSA9IHNlbWFudGljX2NvbnZlbnRpb25zXzEuRVJST1JfVFlQRV9WQUxVRV9PVEhFUjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVhc29uID09PSAnc3RyaW5nJyB8fCByZWFzb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IHJlYXNvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiByZWFzb24gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlYXNvbiwgJ21lc3NhZ2UnKSkge1xuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IHJlYXNvbi5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIGVycm9yVHlwZSA9IHJlYXNvbi5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGVuZGluZ01ldHJpY3MuZm9yRWFjaChtID0+IG0oZXJyb3JUeXBlKSk7XG4gICAgICAgICAgICBzcGFucy5mb3JFYWNoKHNwYW4gPT4ge1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKHNlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9FUlJPUl9UWVBFLCBlcnJvclR5cGUpO1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogYXBpXzEuU3BhblN0YXR1c0NvZGUuRVJST1IsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yTWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgc3BhbnMuZm9yRWFjaChzcGFuID0+IHNwYW4uZW5kKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3N0YXJ0Q29uc3VtZXJTcGFuKHsgdG9waWMsIG1lc3NhZ2UsIG9wZXJhdGlvblR5cGUsIGN0eCwgbGluaywgYXR0cmlidXRlcywgfSkge1xuICAgICAgICBjb25zdCBvcGVyYXRpb25OYW1lID0gb3BlcmF0aW9uVHlwZSA9PT0gc2VtY29udl8xLk1FU1NBR0lOR19PUEVSQVRJT05fVFlQRV9WQUxVRV9SRUNFSVZFXG4gICAgICAgICAgICA/ICdwb2xsJyAvLyBmb3IgYmF0Y2ggcHJvY2Vzc2luZyBzcGFuc1xuICAgICAgICAgICAgOiBvcGVyYXRpb25UeXBlOyAvLyBmb3IgaW5kaXZpZHVhbCBtZXNzYWdlIHByb2Nlc3Npbmcgc3BhbnNcbiAgICAgICAgY29uc3Qgc3BhbiA9IHRoaXMudHJhY2VyLnN0YXJ0U3BhbihgJHtvcGVyYXRpb25OYW1lfSAke3RvcGljfWAsIHtcbiAgICAgICAgICAgIGtpbmQ6IG9wZXJhdGlvblR5cGUgPT09IHNlbWNvbnZfMS5NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEVfVkFMVUVfUkVDRUlWRVxuICAgICAgICAgICAgICAgID8gYXBpXzEuU3BhbktpbmQuQ0xJRU5UXG4gICAgICAgICAgICAgICAgOiBhcGlfMS5TcGFuS2luZC5DT05TVU1FUixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfU1lTVEVNXTogc2VtY29udl8xLk1FU1NBR0lOR19TWVNURU1fVkFMVUVfS0FGS0EsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9OQU1FXTogdG9waWMsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fVFlQRV06IG9wZXJhdGlvblR5cGUsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fTkFNRV06IG9wZXJhdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19LQUZLQV9NRVNTQUdFX0tFWV06IG1lc3NhZ2U/LmtleVxuICAgICAgICAgICAgICAgICAgICA/IFN0cmluZyhtZXNzYWdlLmtleSlcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19LQUZLQV9NRVNTQUdFX1RPTUJTVE9ORV06IG1lc3NhZ2U/LmtleSAmJiBtZXNzYWdlLnZhbHVlID09PSBudWxsID8gdHJ1ZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0tBRktBX09GRlNFVF06IG1lc3NhZ2U/Lm9mZnNldCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5rczogbGluayA/IFtsaW5rXSA6IFtdLFxuICAgICAgICB9LCBjdHgpO1xuICAgICAgICBjb25zdCB7IGNvbnN1bWVySG9vayB9ID0gdGhpcy5nZXRDb25maWcoKTtcbiAgICAgICAgaWYgKGNvbnN1bWVySG9vayAmJiBtZXNzYWdlKSB7XG4gICAgICAgICAgICAoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4gY29uc3VtZXJIb29rKHNwYW4sIHsgdG9waWMsIG1lc3NhZ2UgfSksIGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaWFnLmVycm9yKCdjb25zdW1lckhvb2sgZXJyb3InLCBlKTtcbiAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbiAgICBfc3RhcnRQcm9kdWNlclNwYW4odG9waWMsIG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgc3BhbiA9IHRoaXMudHJhY2VyLnN0YXJ0U3Bhbihgc2VuZCAke3RvcGljfWAsIHtcbiAgICAgICAgICAgIGtpbmQ6IGFwaV8xLlNwYW5LaW5kLlBST0RVQ0VSLFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfU1lTVEVNXTogc2VtY29udl8xLk1FU1NBR0lOR19TWVNURU1fVkFMVUVfS0FGS0EsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9OQU1FXTogdG9waWMsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19LQUZLQV9NRVNTQUdFX0tFWV06IG1lc3NhZ2Uua2V5XG4gICAgICAgICAgICAgICAgICAgID8gU3RyaW5nKG1lc3NhZ2Uua2V5KVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX0tBRktBX01FU1NBR0VfVE9NQlNUT05FXTogbWVzc2FnZS5rZXkgJiYgbWVzc2FnZS52YWx1ZSA9PT0gbnVsbCA/IHRydWUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgW3NlbWNvbnZfMS5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9QQVJUSVRJT05fSURdOiBtZXNzYWdlLnBhcnRpdGlvbiAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gU3RyaW5nKG1lc3NhZ2UucGFydGl0aW9uKVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBbc2VtY29udl8xLkFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9OQU1FXTogJ3NlbmQnLFxuICAgICAgICAgICAgICAgIFtzZW1jb252XzEuQVRUUl9NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEVdOiBzZW1jb252XzEuTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFX1ZBTFVFX1NFTkQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgbWVzc2FnZS5oZWFkZXJzID0gbWVzc2FnZS5oZWFkZXJzID8/IHt9O1xuICAgICAgICBhcGlfMS5wcm9wYWdhdGlvbi5pbmplY3QoYXBpXzEudHJhY2Uuc2V0U3BhbihhcGlfMS5jb250ZXh0LmFjdGl2ZSgpLCBzcGFuKSwgbWVzc2FnZS5oZWFkZXJzKTtcbiAgICAgICAgY29uc3QgeyBwcm9kdWNlckhvb2sgfSA9IHRoaXMuZ2V0Q29uZmlnKCk7XG4gICAgICAgIGlmIChwcm9kdWNlckhvb2spIHtcbiAgICAgICAgICAgICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiBwcm9kdWNlckhvb2soc3BhbiwgeyB0b3BpYywgbWVzc2FnZSB9KSwgZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpYWcuZXJyb3IoJ3Byb2R1Y2VySG9vayBlcnJvcicsIGUpO1xuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxufVxuZXhwb3J0cy5LYWZrYUpzSW5zdHJ1bWVudGF0aW9uID0gS2Fma2FKc0luc3RydW1lbnRhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluc3RydW1lbnRhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/instrumentation.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/internal-types.js":
/*!***************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/internal-types.js ***!
  \***************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors, Aspecto\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EVENT_LISTENERS_SET = void 0;\nexports.EVENT_LISTENERS_SET = Symbol('opentelemetry.instrumentation.kafkajs.eventListenersSet');\n//# sourceMappingURL=internal-types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTQuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy9pbnRlcm5hbC10eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyIvVXNlcnMvY29keWRlYXJrbGFuZC9zZW50cnl2aWJlL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24ta2Fma2Fqc0AwLjE0LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24ta2Fma2Fqcy9idWlsZC9zcmMvaW50ZXJuYWwtdHlwZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IFRoZSBPcGVuVGVsZW1ldHJ5IEF1dGhvcnMsIEFzcGVjdG9cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FVkVOVF9MSVNURU5FUlNfU0VUID0gdm9pZCAwO1xuZXhwb3J0cy5FVkVOVF9MSVNURU5FUlNfU0VUID0gU3ltYm9sKCdvcGVudGVsZW1ldHJ5Lmluc3RydW1lbnRhdGlvbi5rYWZrYWpzLmV2ZW50TGlzdGVuZXJzU2V0Jyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcm5hbC10eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/internal-types.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/propagator.js":
/*!***********************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/propagator.js ***!
  \***********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bufferTextMapGetter = void 0;\n/*\nsame as open telemetry's `defaultTextMapGetter`,\nbut also handle case where header is buffer,\nadding toString() to make sure string is returned\n*/\nexports.bufferTextMapGetter = {\n    get(carrier, key) {\n        if (!carrier) {\n            return undefined;\n        }\n        const keys = Object.keys(carrier);\n        for (const carrierKey of keys) {\n            if (carrierKey === key || carrierKey.toLowerCase() === key) {\n                return carrier[carrierKey]?.toString();\n            }\n        }\n        return undefined;\n    },\n    keys(carrier) {\n        return carrier ? Object.keys(carrier) : [];\n    },\n};\n//# sourceMappingURL=propagator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTQuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy9wcm9wYWdhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvY29keWRlYXJrbGFuZC9zZW50cnl2aWJlL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24ta2Fma2Fqc0AwLjE0LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24ta2Fma2Fqcy9idWlsZC9zcmMvcHJvcGFnYXRvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYnVmZmVyVGV4dE1hcEdldHRlciA9IHZvaWQgMDtcbi8qXG5zYW1lIGFzIG9wZW4gdGVsZW1ldHJ5J3MgYGRlZmF1bHRUZXh0TWFwR2V0dGVyYCxcbmJ1dCBhbHNvIGhhbmRsZSBjYXNlIHdoZXJlIGhlYWRlciBpcyBidWZmZXIsXG5hZGRpbmcgdG9TdHJpbmcoKSB0byBtYWtlIHN1cmUgc3RyaW5nIGlzIHJldHVybmVkXG4qL1xuZXhwb3J0cy5idWZmZXJUZXh0TWFwR2V0dGVyID0ge1xuICAgIGdldChjYXJyaWVyLCBrZXkpIHtcbiAgICAgICAgaWYgKCFjYXJyaWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjYXJyaWVyKTtcbiAgICAgICAgZm9yIChjb25zdCBjYXJyaWVyS2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgIGlmIChjYXJyaWVyS2V5ID09PSBrZXkgfHwgY2FycmllcktleS50b0xvd2VyQ2FzZSgpID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FycmllcltjYXJyaWVyS2V5XT8udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAga2V5cyhjYXJyaWVyKSB7XG4gICAgICAgIHJldHVybiBjYXJyaWVyID8gT2JqZWN0LmtleXMoY2FycmllcikgOiBbXTtcbiAgICB9LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BhZ2F0b3IuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/propagator.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/semconv.js":
/*!********************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/semconv.js ***!
  \********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.METRIC_MESSAGING_PROCESS_DURATION = exports.METRIC_MESSAGING_CLIENT_SENT_MESSAGES = exports.METRIC_MESSAGING_CLIENT_OPERATION_DURATION = exports.METRIC_MESSAGING_CLIENT_CONSUMED_MESSAGES = exports.MESSAGING_SYSTEM_VALUE_KAFKA = exports.MESSAGING_OPERATION_TYPE_VALUE_SEND = exports.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE = exports.MESSAGING_OPERATION_TYPE_VALUE_PROCESS = exports.ATTR_MESSAGING_SYSTEM = exports.ATTR_MESSAGING_OPERATION_TYPE = exports.ATTR_MESSAGING_OPERATION_NAME = exports.ATTR_MESSAGING_KAFKA_OFFSET = exports.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE = exports.ATTR_MESSAGING_KAFKA_MESSAGE_KEY = exports.ATTR_MESSAGING_DESTINATION_PARTITION_ID = exports.ATTR_MESSAGING_DESTINATION_NAME = exports.ATTR_MESSAGING_BATCH_MESSAGE_COUNT = void 0;\n/*\n * This file contains a copy of unstable semantic convention definitions\n * used by this package.\n * @see https://github.com/open-telemetry/opentelemetry-js/tree/main/semantic-conventions#unstable-semconv\n */\n/**\n * The number of messages sent, received, or processed in the scope of the batching operation.\n *\n * @example 0\n * @example 1\n * @example 2\n *\n * @note Instrumentations **SHOULD NOT** set `messaging.batch.message_count` on spans that operate with a single message. When a messaging client library supports both batch and single-message API for the same operation, instrumentations **SHOULD** use `messaging.batch.message_count` for batching APIs and **SHOULD NOT** use it for single-message APIs.\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_BATCH_MESSAGE_COUNT = 'messaging.batch.message_count';\n/**\n * The message destination name\n *\n * @example MyQueue\n * @example MyTopic\n *\n * @note Destination name **SHOULD** uniquely identify a specific queue, topic or other entity within the broker. If\n * the broker doesn't have such notion, the destination name **SHOULD** uniquely identify the broker.\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_DESTINATION_NAME = 'messaging.destination.name';\n/**\n * The identifier of the partition messages are sent to or received from, unique within the `messaging.destination.name`.\n *\n * @example \"1\"\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_DESTINATION_PARTITION_ID = 'messaging.destination.partition.id';\n/**\n * Message keys in Kafka are used for grouping alike messages to ensure they're processed on the same partition. They differ from `messaging.message.id` in that they're not unique. If the key is `null`, the attribute **MUST NOT** be set.\n *\n * @example \"myKey\"\n *\n * @note If the key type is not string, it's string representation has to be supplied for the attribute. If the key has no unambiguous, canonical string form, don't include its value.\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_KAFKA_MESSAGE_KEY = 'messaging.kafka.message.key';\n/**\n * A boolean that is true if the message is a tombstone.\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE = 'messaging.kafka.message.tombstone';\n/**\n * The offset of a record in the corresponding Kafka partition.\n *\n * @example 42\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_KAFKA_OFFSET = 'messaging.kafka.offset';\n/**\n * The system-specific name of the messaging operation.\n *\n * @example ack\n * @example nack\n * @example send\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_OPERATION_NAME = 'messaging.operation.name';\n/**\n * A string identifying the type of the messaging operation.\n *\n * @note If a custom value is used, it **MUST** be of low cardinality.\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_OPERATION_TYPE = 'messaging.operation.type';\n/**\n * The messaging system as identified by the client instrumentation.\n *\n * @note The actual messaging system may differ from the one known by the client. For example, when using Kafka client libraries to communicate with Azure Event Hubs, the `messaging.system` is set to `kafka` based on the instrumentation's best knowledge.\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.ATTR_MESSAGING_SYSTEM = 'messaging.system';\n/**\n * Enum value \"process\" for attribute {@link ATTR_MESSAGING_OPERATION_TYPE}.\n */\nexports.MESSAGING_OPERATION_TYPE_VALUE_PROCESS = 'process';\n/**\n * Enum value \"receive\" for attribute {@link ATTR_MESSAGING_OPERATION_TYPE}.\n */\nexports.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE = 'receive';\n/**\n * Enum value \"send\" for attribute {@link ATTR_MESSAGING_OPERATION_TYPE}.\n */\nexports.MESSAGING_OPERATION_TYPE_VALUE_SEND = 'send';\n/**\n * Enum value \"kafka\" for attribute {@link ATTR_MESSAGING_SYSTEM}.\n */\nexports.MESSAGING_SYSTEM_VALUE_KAFKA = 'kafka';\n/**\n * Number of messages that were delivered to the application.\n *\n * @note Records the number of messages pulled from the broker or number of messages dispatched to the application in push-based scenarios.\n * The metric **SHOULD** be reported once per message delivery. For example, if receiving and processing operations are both instrumented for a single message delivery, this counter is incremented when the message is received and not reported when it is processed.\n *\n * @experimental This metric is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.METRIC_MESSAGING_CLIENT_CONSUMED_MESSAGES = 'messaging.client.consumed.messages';\n/**\n * Duration of messaging operation initiated by a producer or consumer client.\n *\n * @note This metric **SHOULD NOT** be used to report processing duration - processing duration is reported in `messaging.process.duration` metric.\n *\n * @experimental This metric is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.METRIC_MESSAGING_CLIENT_OPERATION_DURATION = 'messaging.client.operation.duration';\n/**\n * Number of messages producer attempted to send to the broker.\n *\n * @note This metric **MUST NOT** count messages that were created but haven't yet been sent.\n *\n * @experimental This metric is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.METRIC_MESSAGING_CLIENT_SENT_MESSAGES = 'messaging.client.sent.messages';\n/**\n * Duration of processing operation.\n *\n * @note This metric **MUST** be reported for operations with `messaging.operation.type` that matches `process`.\n *\n * @experimental This metric is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexports.METRIC_MESSAGING_PROCESS_DURATION = 'messaging.process.duration';\n//# sourceMappingURL=semconv.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTQuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy9zZW1jb252LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlDQUF5QyxHQUFHLDZDQUE2QyxHQUFHLGtEQUFrRCxHQUFHLGlEQUFpRCxHQUFHLG9DQUFvQyxHQUFHLDJDQUEyQyxHQUFHLDhDQUE4QyxHQUFHLDhDQUE4QyxHQUFHLDZCQUE2QixHQUFHLHFDQUFxQyxHQUFHLHFDQUFxQyxHQUFHLG1DQUFtQyxHQUFHLDhDQUE4QyxHQUFHLHdDQUF3QyxHQUFHLCtDQUErQyxHQUFHLHVDQUF1QyxHQUFHLDBDQUEwQztBQUNwdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsdUNBQXVDLG9DQUFvQztBQUMzRTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLHVDQUF1QyxvQ0FBb0M7QUFDM0U7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxvQ0FBb0Msb0NBQW9DO0FBQ3hFO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EscUNBQXFDLDRCQUE0QjtBQUNqRTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDIiwic291cmNlcyI6WyIvVXNlcnMvY29keWRlYXJrbGFuZC9zZW50cnl2aWJlL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24ta2Fma2Fqc0AwLjE0LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24ta2Fma2Fqcy9idWlsZC9zcmMvc2VtY29udi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1FVFJJQ19NRVNTQUdJTkdfUFJPQ0VTU19EVVJBVElPTiA9IGV4cG9ydHMuTUVUUklDX01FU1NBR0lOR19DTElFTlRfU0VOVF9NRVNTQUdFUyA9IGV4cG9ydHMuTUVUUklDX01FU1NBR0lOR19DTElFTlRfT1BFUkFUSU9OX0RVUkFUSU9OID0gZXhwb3J0cy5NRVRSSUNfTUVTU0FHSU5HX0NMSUVOVF9DT05TVU1FRF9NRVNTQUdFUyA9IGV4cG9ydHMuTUVTU0FHSU5HX1NZU1RFTV9WQUxVRV9LQUZLQSA9IGV4cG9ydHMuTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFX1ZBTFVFX1NFTkQgPSBleHBvcnRzLk1FU1NBR0lOR19PUEVSQVRJT05fVFlQRV9WQUxVRV9SRUNFSVZFID0gZXhwb3J0cy5NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEVfVkFMVUVfUFJPQ0VTUyA9IGV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfU1lTVEVNID0gZXhwb3J0cy5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fVFlQRSA9IGV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfT1BFUkFUSU9OX05BTUUgPSBleHBvcnRzLkFUVFJfTUVTU0FHSU5HX0tBRktBX09GRlNFVCA9IGV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfS0FGS0FfTUVTU0FHRV9UT01CU1RPTkUgPSBleHBvcnRzLkFUVFJfTUVTU0FHSU5HX0tBRktBX01FU1NBR0VfS0VZID0gZXhwb3J0cy5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9QQVJUSVRJT05fSUQgPSBleHBvcnRzLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX05BTUUgPSBleHBvcnRzLkFUVFJfTUVTU0FHSU5HX0JBVENIX01FU1NBR0VfQ09VTlQgPSB2b2lkIDA7XG4vKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGEgY29weSBvZiB1bnN0YWJsZSBzZW1hbnRpYyBjb252ZW50aW9uIGRlZmluaXRpb25zXG4gKiB1c2VkIGJ5IHRoaXMgcGFja2FnZS5cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL29wZW4tdGVsZW1ldHJ5L29wZW50ZWxlbWV0cnktanMvdHJlZS9tYWluL3NlbWFudGljLWNvbnZlbnRpb25zI3Vuc3RhYmxlLXNlbWNvbnZcbiAqL1xuLyoqXG4gKiBUaGUgbnVtYmVyIG9mIG1lc3NhZ2VzIHNlbnQsIHJlY2VpdmVkLCBvciBwcm9jZXNzZWQgaW4gdGhlIHNjb3BlIG9mIHRoZSBiYXRjaGluZyBvcGVyYXRpb24uXG4gKlxuICogQGV4YW1wbGUgMFxuICogQGV4YW1wbGUgMVxuICogQGV4YW1wbGUgMlxuICpcbiAqIEBub3RlIEluc3RydW1lbnRhdGlvbnMgKipTSE9VTEQgTk9UKiogc2V0IGBtZXNzYWdpbmcuYmF0Y2gubWVzc2FnZV9jb3VudGAgb24gc3BhbnMgdGhhdCBvcGVyYXRlIHdpdGggYSBzaW5nbGUgbWVzc2FnZS4gV2hlbiBhIG1lc3NhZ2luZyBjbGllbnQgbGlicmFyeSBzdXBwb3J0cyBib3RoIGJhdGNoIGFuZCBzaW5nbGUtbWVzc2FnZSBBUEkgZm9yIHRoZSBzYW1lIG9wZXJhdGlvbiwgaW5zdHJ1bWVudGF0aW9ucyAqKlNIT1VMRCoqIHVzZSBgbWVzc2FnaW5nLmJhdGNoLm1lc3NhZ2VfY291bnRgIGZvciBiYXRjaGluZyBBUElzIGFuZCAqKlNIT1VMRCBOT1QqKiB1c2UgaXQgZm9yIHNpbmdsZS1tZXNzYWdlIEFQSXMuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIGF0dHJpYnV0ZSBpcyBleHBlcmltZW50YWwgYW5kIGlzIHN1YmplY3QgdG8gYnJlYWtpbmcgY2hhbmdlcyBpbiBtaW5vciByZWxlYXNlcyBvZiBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgLlxuICovXG5leHBvcnRzLkFUVFJfTUVTU0FHSU5HX0JBVENIX01FU1NBR0VfQ09VTlQgPSAnbWVzc2FnaW5nLmJhdGNoLm1lc3NhZ2VfY291bnQnO1xuLyoqXG4gKiBUaGUgbWVzc2FnZSBkZXN0aW5hdGlvbiBuYW1lXG4gKlxuICogQGV4YW1wbGUgTXlRdWV1ZVxuICogQGV4YW1wbGUgTXlUb3BpY1xuICpcbiAqIEBub3RlIERlc3RpbmF0aW9uIG5hbWUgKipTSE9VTEQqKiB1bmlxdWVseSBpZGVudGlmeSBhIHNwZWNpZmljIHF1ZXVlLCB0b3BpYyBvciBvdGhlciBlbnRpdHkgd2l0aGluIHRoZSBicm9rZXIuIElmXG4gKiB0aGUgYnJva2VyIGRvZXNuJ3QgaGF2ZSBzdWNoIG5vdGlvbiwgdGhlIGRlc3RpbmF0aW9uIG5hbWUgKipTSE9VTEQqKiB1bmlxdWVseSBpZGVudGlmeSB0aGUgYnJva2VyLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBhdHRyaWJ1dGUgaXMgZXhwZXJpbWVudGFsIGFuZCBpcyBzdWJqZWN0IHRvIGJyZWFraW5nIGNoYW5nZXMgaW4gbWlub3IgcmVsZWFzZXMgb2YgYEBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zYC5cbiAqL1xuZXhwb3J0cy5BVFRSX01FU1NBR0lOR19ERVNUSU5BVElPTl9OQU1FID0gJ21lc3NhZ2luZy5kZXN0aW5hdGlvbi5uYW1lJztcbi8qKlxuICogVGhlIGlkZW50aWZpZXIgb2YgdGhlIHBhcnRpdGlvbiBtZXNzYWdlcyBhcmUgc2VudCB0byBvciByZWNlaXZlZCBmcm9tLCB1bmlxdWUgd2l0aGluIHRoZSBgbWVzc2FnaW5nLmRlc3RpbmF0aW9uLm5hbWVgLlxuICpcbiAqIEBleGFtcGxlIFwiMVwiXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIGF0dHJpYnV0ZSBpcyBleHBlcmltZW50YWwgYW5kIGlzIHN1YmplY3QgdG8gYnJlYWtpbmcgY2hhbmdlcyBpbiBtaW5vciByZWxlYXNlcyBvZiBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgLlxuICovXG5leHBvcnRzLkFUVFJfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX1BBUlRJVElPTl9JRCA9ICdtZXNzYWdpbmcuZGVzdGluYXRpb24ucGFydGl0aW9uLmlkJztcbi8qKlxuICogTWVzc2FnZSBrZXlzIGluIEthZmthIGFyZSB1c2VkIGZvciBncm91cGluZyBhbGlrZSBtZXNzYWdlcyB0byBlbnN1cmUgdGhleSdyZSBwcm9jZXNzZWQgb24gdGhlIHNhbWUgcGFydGl0aW9uLiBUaGV5IGRpZmZlciBmcm9tIGBtZXNzYWdpbmcubWVzc2FnZS5pZGAgaW4gdGhhdCB0aGV5J3JlIG5vdCB1bmlxdWUuIElmIHRoZSBrZXkgaXMgYG51bGxgLCB0aGUgYXR0cmlidXRlICoqTVVTVCBOT1QqKiBiZSBzZXQuXG4gKlxuICogQGV4YW1wbGUgXCJteUtleVwiXG4gKlxuICogQG5vdGUgSWYgdGhlIGtleSB0eXBlIGlzIG5vdCBzdHJpbmcsIGl0J3Mgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGhhcyB0byBiZSBzdXBwbGllZCBmb3IgdGhlIGF0dHJpYnV0ZS4gSWYgdGhlIGtleSBoYXMgbm8gdW5hbWJpZ3VvdXMsIGNhbm9uaWNhbCBzdHJpbmcgZm9ybSwgZG9uJ3QgaW5jbHVkZSBpdHMgdmFsdWUuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIGF0dHJpYnV0ZSBpcyBleHBlcmltZW50YWwgYW5kIGlzIHN1YmplY3QgdG8gYnJlYWtpbmcgY2hhbmdlcyBpbiBtaW5vciByZWxlYXNlcyBvZiBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgLlxuICovXG5leHBvcnRzLkFUVFJfTUVTU0FHSU5HX0tBRktBX01FU1NBR0VfS0VZID0gJ21lc3NhZ2luZy5rYWZrYS5tZXNzYWdlLmtleSc7XG4vKipcbiAqIEEgYm9vbGVhbiB0aGF0IGlzIHRydWUgaWYgdGhlIG1lc3NhZ2UgaXMgYSB0b21ic3RvbmUuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIGF0dHJpYnV0ZSBpcyBleHBlcmltZW50YWwgYW5kIGlzIHN1YmplY3QgdG8gYnJlYWtpbmcgY2hhbmdlcyBpbiBtaW5vciByZWxlYXNlcyBvZiBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgLlxuICovXG5leHBvcnRzLkFUVFJfTUVTU0FHSU5HX0tBRktBX01FU1NBR0VfVE9NQlNUT05FID0gJ21lc3NhZ2luZy5rYWZrYS5tZXNzYWdlLnRvbWJzdG9uZSc7XG4vKipcbiAqIFRoZSBvZmZzZXQgb2YgYSByZWNvcmQgaW4gdGhlIGNvcnJlc3BvbmRpbmcgS2Fma2EgcGFydGl0aW9uLlxuICpcbiAqIEBleGFtcGxlIDQyXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIGF0dHJpYnV0ZSBpcyBleHBlcmltZW50YWwgYW5kIGlzIHN1YmplY3QgdG8gYnJlYWtpbmcgY2hhbmdlcyBpbiBtaW5vciByZWxlYXNlcyBvZiBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgLlxuICovXG5leHBvcnRzLkFUVFJfTUVTU0FHSU5HX0tBRktBX09GRlNFVCA9ICdtZXNzYWdpbmcua2Fma2Eub2Zmc2V0Jztcbi8qKlxuICogVGhlIHN5c3RlbS1zcGVjaWZpYyBuYW1lIG9mIHRoZSBtZXNzYWdpbmcgb3BlcmF0aW9uLlxuICpcbiAqIEBleGFtcGxlIGFja1xuICogQGV4YW1wbGUgbmFja1xuICogQGV4YW1wbGUgc2VuZFxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBhdHRyaWJ1dGUgaXMgZXhwZXJpbWVudGFsIGFuZCBpcyBzdWJqZWN0IHRvIGJyZWFraW5nIGNoYW5nZXMgaW4gbWlub3IgcmVsZWFzZXMgb2YgYEBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zYC5cbiAqL1xuZXhwb3J0cy5BVFRSX01FU1NBR0lOR19PUEVSQVRJT05fTkFNRSA9ICdtZXNzYWdpbmcub3BlcmF0aW9uLm5hbWUnO1xuLyoqXG4gKiBBIHN0cmluZyBpZGVudGlmeWluZyB0aGUgdHlwZSBvZiB0aGUgbWVzc2FnaW5nIG9wZXJhdGlvbi5cbiAqXG4gKiBAbm90ZSBJZiBhIGN1c3RvbSB2YWx1ZSBpcyB1c2VkLCBpdCAqKk1VU1QqKiBiZSBvZiBsb3cgY2FyZGluYWxpdHkuXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgYXR0cmlidXRlIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXMgc3ViamVjdCB0byBicmVha2luZyBjaGFuZ2VzIGluIG1pbm9yIHJlbGVhc2VzIG9mIGBAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc2AuXG4gKi9cbmV4cG9ydHMuQVRUUl9NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEUgPSAnbWVzc2FnaW5nLm9wZXJhdGlvbi50eXBlJztcbi8qKlxuICogVGhlIG1lc3NhZ2luZyBzeXN0ZW0gYXMgaWRlbnRpZmllZCBieSB0aGUgY2xpZW50IGluc3RydW1lbnRhdGlvbi5cbiAqXG4gKiBAbm90ZSBUaGUgYWN0dWFsIG1lc3NhZ2luZyBzeXN0ZW0gbWF5IGRpZmZlciBmcm9tIHRoZSBvbmUga25vd24gYnkgdGhlIGNsaWVudC4gRm9yIGV4YW1wbGUsIHdoZW4gdXNpbmcgS2Fma2EgY2xpZW50IGxpYnJhcmllcyB0byBjb21tdW5pY2F0ZSB3aXRoIEF6dXJlIEV2ZW50IEh1YnMsIHRoZSBgbWVzc2FnaW5nLnN5c3RlbWAgaXMgc2V0IHRvIGBrYWZrYWAgYmFzZWQgb24gdGhlIGluc3RydW1lbnRhdGlvbidzIGJlc3Qga25vd2xlZGdlLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBhdHRyaWJ1dGUgaXMgZXhwZXJpbWVudGFsIGFuZCBpcyBzdWJqZWN0IHRvIGJyZWFraW5nIGNoYW5nZXMgaW4gbWlub3IgcmVsZWFzZXMgb2YgYEBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zYC5cbiAqL1xuZXhwb3J0cy5BVFRSX01FU1NBR0lOR19TWVNURU0gPSAnbWVzc2FnaW5nLnN5c3RlbSc7XG4vKipcbiAqIEVudW0gdmFsdWUgXCJwcm9jZXNzXCIgZm9yIGF0dHJpYnV0ZSB7QGxpbmsgQVRUUl9NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEV9LlxuICovXG5leHBvcnRzLk1FU1NBR0lOR19PUEVSQVRJT05fVFlQRV9WQUxVRV9QUk9DRVNTID0gJ3Byb2Nlc3MnO1xuLyoqXG4gKiBFbnVtIHZhbHVlIFwicmVjZWl2ZVwiIGZvciBhdHRyaWJ1dGUge0BsaW5rIEFUVFJfTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFfS5cbiAqL1xuZXhwb3J0cy5NRVNTQUdJTkdfT1BFUkFUSU9OX1RZUEVfVkFMVUVfUkVDRUlWRSA9ICdyZWNlaXZlJztcbi8qKlxuICogRW51bSB2YWx1ZSBcInNlbmRcIiBmb3IgYXR0cmlidXRlIHtAbGluayBBVFRSX01FU1NBR0lOR19PUEVSQVRJT05fVFlQRX0uXG4gKi9cbmV4cG9ydHMuTUVTU0FHSU5HX09QRVJBVElPTl9UWVBFX1ZBTFVFX1NFTkQgPSAnc2VuZCc7XG4vKipcbiAqIEVudW0gdmFsdWUgXCJrYWZrYVwiIGZvciBhdHRyaWJ1dGUge0BsaW5rIEFUVFJfTUVTU0FHSU5HX1NZU1RFTX0uXG4gKi9cbmV4cG9ydHMuTUVTU0FHSU5HX1NZU1RFTV9WQUxVRV9LQUZLQSA9ICdrYWZrYSc7XG4vKipcbiAqIE51bWJlciBvZiBtZXNzYWdlcyB0aGF0IHdlcmUgZGVsaXZlcmVkIHRvIHRoZSBhcHBsaWNhdGlvbi5cbiAqXG4gKiBAbm90ZSBSZWNvcmRzIHRoZSBudW1iZXIgb2YgbWVzc2FnZXMgcHVsbGVkIGZyb20gdGhlIGJyb2tlciBvciBudW1iZXIgb2YgbWVzc2FnZXMgZGlzcGF0Y2hlZCB0byB0aGUgYXBwbGljYXRpb24gaW4gcHVzaC1iYXNlZCBzY2VuYXJpb3MuXG4gKiBUaGUgbWV0cmljICoqU0hPVUxEKiogYmUgcmVwb3J0ZWQgb25jZSBwZXIgbWVzc2FnZSBkZWxpdmVyeS4gRm9yIGV4YW1wbGUsIGlmIHJlY2VpdmluZyBhbmQgcHJvY2Vzc2luZyBvcGVyYXRpb25zIGFyZSBib3RoIGluc3RydW1lbnRlZCBmb3IgYSBzaW5nbGUgbWVzc2FnZSBkZWxpdmVyeSwgdGhpcyBjb3VudGVyIGlzIGluY3JlbWVudGVkIHdoZW4gdGhlIG1lc3NhZ2UgaXMgcmVjZWl2ZWQgYW5kIG5vdCByZXBvcnRlZCB3aGVuIGl0IGlzIHByb2Nlc3NlZC5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgbWV0cmljIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXMgc3ViamVjdCB0byBicmVha2luZyBjaGFuZ2VzIGluIG1pbm9yIHJlbGVhc2VzIG9mIGBAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc2AuXG4gKi9cbmV4cG9ydHMuTUVUUklDX01FU1NBR0lOR19DTElFTlRfQ09OU1VNRURfTUVTU0FHRVMgPSAnbWVzc2FnaW5nLmNsaWVudC5jb25zdW1lZC5tZXNzYWdlcyc7XG4vKipcbiAqIER1cmF0aW9uIG9mIG1lc3NhZ2luZyBvcGVyYXRpb24gaW5pdGlhdGVkIGJ5IGEgcHJvZHVjZXIgb3IgY29uc3VtZXIgY2xpZW50LlxuICpcbiAqIEBub3RlIFRoaXMgbWV0cmljICoqU0hPVUxEIE5PVCoqIGJlIHVzZWQgdG8gcmVwb3J0IHByb2Nlc3NpbmcgZHVyYXRpb24gLSBwcm9jZXNzaW5nIGR1cmF0aW9uIGlzIHJlcG9ydGVkIGluIGBtZXNzYWdpbmcucHJvY2Vzcy5kdXJhdGlvbmAgbWV0cmljLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBtZXRyaWMgaXMgZXhwZXJpbWVudGFsIGFuZCBpcyBzdWJqZWN0IHRvIGJyZWFraW5nIGNoYW5nZXMgaW4gbWlub3IgcmVsZWFzZXMgb2YgYEBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zYC5cbiAqL1xuZXhwb3J0cy5NRVRSSUNfTUVTU0FHSU5HX0NMSUVOVF9PUEVSQVRJT05fRFVSQVRJT04gPSAnbWVzc2FnaW5nLmNsaWVudC5vcGVyYXRpb24uZHVyYXRpb24nO1xuLyoqXG4gKiBOdW1iZXIgb2YgbWVzc2FnZXMgcHJvZHVjZXIgYXR0ZW1wdGVkIHRvIHNlbmQgdG8gdGhlIGJyb2tlci5cbiAqXG4gKiBAbm90ZSBUaGlzIG1ldHJpYyAqKk1VU1QgTk9UKiogY291bnQgbWVzc2FnZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgYnV0IGhhdmVuJ3QgeWV0IGJlZW4gc2VudC5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgbWV0cmljIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXMgc3ViamVjdCB0byBicmVha2luZyBjaGFuZ2VzIGluIG1pbm9yIHJlbGVhc2VzIG9mIGBAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc2AuXG4gKi9cbmV4cG9ydHMuTUVUUklDX01FU1NBR0lOR19DTElFTlRfU0VOVF9NRVNTQUdFUyA9ICdtZXNzYWdpbmcuY2xpZW50LnNlbnQubWVzc2FnZXMnO1xuLyoqXG4gKiBEdXJhdGlvbiBvZiBwcm9jZXNzaW5nIG9wZXJhdGlvbi5cbiAqXG4gKiBAbm90ZSBUaGlzIG1ldHJpYyAqKk1VU1QqKiBiZSByZXBvcnRlZCBmb3Igb3BlcmF0aW9ucyB3aXRoIGBtZXNzYWdpbmcub3BlcmF0aW9uLnR5cGVgIHRoYXQgbWF0Y2hlcyBgcHJvY2Vzc2AuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIG1ldHJpYyBpcyBleHBlcmltZW50YWwgYW5kIGlzIHN1YmplY3QgdG8gYnJlYWtpbmcgY2hhbmdlcyBpbiBtaW5vciByZWxlYXNlcyBvZiBgQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNgLlxuICovXG5leHBvcnRzLk1FVFJJQ19NRVNTQUdJTkdfUFJPQ0VTU19EVVJBVElPTiA9ICdtZXNzYWdpbmcucHJvY2Vzcy5kdXJhdGlvbic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZW1jb252LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/semconv.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/version.js":
/*!********************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/version.js ***!
  \********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;\n// this is autogenerated file, see scripts/version-update.js\nexports.PACKAGE_VERSION = '0.14.0';\nexports.PACKAGE_NAME = '@opentelemetry/instrumentation-kafkajs';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTQuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLHVCQUF1QjtBQUM5QztBQUNBLHVCQUF1QjtBQUN2QixvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jb2R5ZGVhcmtsYW5kL3NlbnRyeXZpYmUvbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1rYWZrYWpzQDAuMTQuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1rYWZrYWpzL2J1aWxkL3NyYy92ZXJzaW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBUaGUgT3BlblRlbGVtZXRyeSBBdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUEFDS0FHRV9OQU1FID0gZXhwb3J0cy5QQUNLQUdFX1ZFUlNJT04gPSB2b2lkIDA7XG4vLyB0aGlzIGlzIGF1dG9nZW5lcmF0ZWQgZmlsZSwgc2VlIHNjcmlwdHMvdmVyc2lvbi11cGRhdGUuanNcbmV4cG9ydHMuUEFDS0FHRV9WRVJTSU9OID0gJzAuMTQuMCc7XG5leHBvcnRzLlBBQ0tBR0VfTkFNRSA9ICdAb3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24ta2Fma2Fqcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@opentelemetry+instrumentation-kafkajs@0.14.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-kafkajs/build/src/version.js\n");

/***/ })

};
;