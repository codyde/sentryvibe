/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@sentry+opentelemetry@10.17.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.1_lnanjtbeaorg7cpyd6d5aj7lji";
exports.ids = ["vendor-chunks/@sentry+opentelemetry@10.17.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.1_lnanjtbeaorg7cpyd6d5aj7lji"];
exports.modules = {

/***/ "(instrument)/../../node_modules/.pnpm/@sentry+opentelemetry@10.17.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.1_lnanjtbeaorg7cpyd6d5aj7lji/node_modules/@sentry/opentelemetry/build/cjs/index.js":
/*!***************************************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@sentry+opentelemetry@10.17.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.1_lnanjtbeaorg7cpyd6d5aj7lji/node_modules/@sentry/opentelemetry/build/cjs/index.js ***!
  \***************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst semanticConventions = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.37.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nconst core = __webpack_require__(/*! @sentry/core */ \"(instrument)/../../node_modules/.pnpm/@sentry+core@10.17.0/node_modules/@sentry/core/build/cjs/index.js\");\nconst api = __webpack_require__(/*! @opentelemetry/api */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst core$1 = __webpack_require__(/*! @opentelemetry/core */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+core@2.1.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\nconst sdkTraceBase = __webpack_require__(/*! @opentelemetry/sdk-trace-base */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@2.1.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/index.js\");\n\n/** If this attribute is true, it means that the parent is a remote span. */\nconst SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE = 'sentry.parentIsRemote';\n\n// These are not standardized yet, but used by the graphql instrumentation\nconst SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION = 'sentry.graphql.operation';\n\n/**\n * Get the parent span id from a span.\n * In OTel v1, the parent span id is accessed as `parentSpanId`\n * In OTel v2, the parent span id is accessed as `spanId` on the `parentSpanContext`\n */\nfunction getParentSpanId(span) {\n  if ('parentSpanId' in span) {\n    return span.parentSpanId ;\n  } else if ('parentSpanContext' in span) {\n    return (span.parentSpanContext )?.spanId;\n  }\n\n  return undefined;\n}\n\n/**\n * Check if a given span has attributes.\n * This is necessary because the base `Span` type does not have attributes,\n * so in places where we are passed a generic span, we need to check if we want to access them.\n */\nfunction spanHasAttributes(\n  span,\n) {\n  const castSpan = span ;\n  return !!castSpan.attributes && typeof castSpan.attributes === 'object';\n}\n\n/**\n * Check if a given span has a kind.\n * This is necessary because the base `Span` type does not have a kind,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasKind(span) {\n  const castSpan = span ;\n  return typeof castSpan.kind === 'number';\n}\n\n/**\n * Check if a given span has a status.\n * This is necessary because the base `Span` type does not have a status,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasStatus(\n  span,\n) {\n  const castSpan = span ;\n  return !!castSpan.status;\n}\n\n/**\n * Check if a given span has a name.\n * This is necessary because the base `Span` type does not have a name,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasName(span) {\n  const castSpan = span ;\n  return !!castSpan.name;\n}\n\n/**\n * Check if a given span has a kind.\n * This is necessary because the base `Span` type does not have a kind,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasParentId(\n  span,\n) {\n  const castSpan = span ;\n  return !!getParentSpanId(castSpan);\n}\n\n/**\n * Check if a given span has events.\n * This is necessary because the base `Span` type does not have events,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasEvents(\n  span,\n) {\n  const castSpan = span ;\n  return Array.isArray(castSpan.events);\n}\n\n/**\n * Get sanitizied request data from an OTEL span.\n */\nfunction getRequestSpanData(span) {\n  // The base `Span` type has no `attributes`, so we need to guard here against that\n  if (!spanHasAttributes(span)) {\n    return {};\n  }\n\n  // eslint-disable-next-line deprecation/deprecation\n  const maybeUrlAttribute = (span.attributes[semanticConventions.ATTR_URL_FULL] || span.attributes[semanticConventions.SEMATTRS_HTTP_URL])\n\n;\n\n  const data = {\n    url: maybeUrlAttribute,\n    // eslint-disable-next-line deprecation/deprecation\n    'http.method': (span.attributes[semanticConventions.ATTR_HTTP_REQUEST_METHOD] || span.attributes[semanticConventions.SEMATTRS_HTTP_METHOD])\n\n,\n  };\n\n  // Default to GET if URL is set but method is not\n  if (!data['http.method'] && data.url) {\n    data['http.method'] = 'GET';\n  }\n\n  try {\n    if (typeof maybeUrlAttribute === 'string') {\n      const url = core.parseUrl(maybeUrlAttribute);\n\n      data.url = core.getSanitizedUrlString(url);\n\n      if (url.search) {\n        data['http.query'] = url.search;\n      }\n      if (url.hash) {\n        data['http.fragment'] = url.hash;\n      }\n    }\n  } catch {\n    // ignore\n  }\n\n  return data;\n}\n\n// Typescript complains if we do not use `...args: any[]` for the mixin, with:\n// A mixin class must have a constructor with a single rest parameter of type 'any[]'.ts(2545)\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\n * Wrap an Client class with things we need for OpenTelemetry support.\n * Make sure that the Client class passed in is non-abstract!\n *\n * Usage:\n * const OpenTelemetryClient = getWrappedClientClass(NodeClient);\n * const client = new OpenTelemetryClient(options);\n */\nfunction wrapClientClass\n\n(ClientClass) {\n  // @ts-expect-error We just assume that this is non-abstract, if you pass in an abstract class this would make it non-abstract\n  class OpenTelemetryClient extends ClientClass  {\n\n     constructor(...args) {\n      super(...args);\n    }\n\n    /** Get the OTEL tracer. */\n     get tracer() {\n      if (this._tracer) {\n        return this._tracer;\n      }\n\n      const name = '@sentry/opentelemetry';\n      const version = core.SDK_VERSION;\n      const tracer = api.trace.getTracer(name, version);\n      this._tracer = tracer;\n\n      return tracer;\n    }\n\n    /**\n     * @inheritDoc\n     */\n     async flush(timeout) {\n      const provider = this.traceProvider;\n      await provider?.forceFlush();\n      return super.flush(timeout);\n    }\n  }\n\n  return OpenTelemetryClient ;\n}\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\n/**\n * Get the span kind from a span.\n * For whatever reason, this is not public API on the generic \"Span\" type,\n * so we need to check if we actually have a `SDKTraceBaseSpan` where we can fetch this from.\n * Otherwise, we fall back to `SpanKind.INTERNAL`.\n */\nfunction getSpanKind(span) {\n  if (spanHasKind(span)) {\n    return span.kind;\n  }\n\n  return api.SpanKind.INTERNAL;\n}\n\nconst SENTRY_TRACE_HEADER = 'sentry-trace';\nconst SENTRY_BAGGAGE_HEADER = 'baggage';\n\nconst SENTRY_TRACE_STATE_DSC = 'sentry.dsc';\nconst SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING = 'sentry.sampled_not_recording';\nconst SENTRY_TRACE_STATE_URL = 'sentry.url';\nconst SENTRY_TRACE_STATE_SAMPLE_RAND = 'sentry.sample_rand';\nconst SENTRY_TRACE_STATE_SAMPLE_RATE = 'sentry.sample_rate';\n\nconst SENTRY_SCOPES_CONTEXT_KEY = api.createContextKey('sentry_scopes');\n\nconst SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY = api.createContextKey('sentry_fork_isolation_scope');\n\nconst SENTRY_FORK_SET_SCOPE_CONTEXT_KEY = api.createContextKey('sentry_fork_set_scope');\n\nconst SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY = api.createContextKey('sentry_fork_set_isolation_scope');\n\nconst SCOPE_CONTEXT_FIELD = '_scopeContext';\n\n/**\n * Try to get the current scopes from the given OTEL context.\n * This requires a Context Manager that was wrapped with getWrappedContextManager.\n */\nfunction getScopesFromContext(context) {\n  return context.getValue(SENTRY_SCOPES_CONTEXT_KEY) ;\n}\n\n/**\n * Set the current scopes on an OTEL context.\n * This will return a forked context with the Propagation Context set.\n */\nfunction setScopesOnContext(context, scopes) {\n  return context.setValue(SENTRY_SCOPES_CONTEXT_KEY, scopes);\n}\n\n/**\n * Set the context on the scope so we can later look it up.\n * We need this to get the context from the scope in the `trace` functions.\n */\nfunction setContextOnScope(scope, context) {\n  core.addNonEnumerableProperty(scope, SCOPE_CONTEXT_FIELD, context);\n}\n\n/**\n * Get the context related to a scope.\n */\nfunction getContextFromScope(scope) {\n  return (scope )[SCOPE_CONTEXT_FIELD];\n}\n\n/**\n *\n * @param otelSpan Checks whether a given OTEL Span is an http request to sentry.\n * @returns boolean\n */\nfunction isSentryRequestSpan(span) {\n  if (!spanHasAttributes(span)) {\n    return false;\n  }\n\n  const { attributes } = span;\n\n  // `ATTR_URL_FULL` is the new attribute, but we still support the old one, `ATTR_HTTP_URL`, for now.\n  // eslint-disable-next-line deprecation/deprecation\n  const httpUrl = attributes[semanticConventions.SEMATTRS_HTTP_URL] || attributes[semanticConventions.ATTR_URL_FULL];\n\n  if (!httpUrl) {\n    return false;\n  }\n\n  return core.isSentryRequestUrl(httpUrl.toString(), core.getClient());\n}\n\n/**\n * OpenTelemetry only knows about SAMPLED or NONE decision,\n * but for us it is important to differentiate between unset and unsampled.\n *\n * Both of these are identified as `traceFlags === TracegFlags.NONE`,\n * but we additionally look at a special trace state to differentiate between them.\n */\nfunction getSamplingDecision(spanContext) {\n  const { traceFlags, traceState } = spanContext;\n\n  const sampledNotRecording = traceState ? traceState.get(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING) === '1' : false;\n\n  // If trace flag is `SAMPLED`, we interpret this as sampled\n  // If it is `NONE`, it could mean either it was sampled to be not recorder, or that it was not sampled at all\n  // For us this is an important difference, sow e look at the SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING\n  // to identify which it is\n  if (traceFlags === api.TraceFlags.SAMPLED) {\n    return true;\n  }\n\n  if (sampledNotRecording) {\n    return false;\n  }\n\n  // Fall back to DSC as a last resort, that may also contain `sampled`...\n  const dscString = traceState ? traceState.get(SENTRY_TRACE_STATE_DSC) : undefined;\n  const dsc = dscString ? core.baggageHeaderToDynamicSamplingContext(dscString) : undefined;\n\n  if (dsc?.sampled === 'true') {\n    return true;\n  }\n  if (dsc?.sampled === 'false') {\n    return false;\n  }\n\n  return undefined;\n}\n\n/**\n * Infer the op & description for a set of name, attributes and kind of a span.\n */\nfunction inferSpanData(spanName, attributes, kind) {\n  // if http.method exists, this is an http request span\n  // eslint-disable-next-line deprecation/deprecation\n  const httpMethod = attributes[semanticConventions.ATTR_HTTP_REQUEST_METHOD] || attributes[semanticConventions.SEMATTRS_HTTP_METHOD];\n  if (httpMethod) {\n    return descriptionForHttpMethod({ attributes, name: spanName, kind }, httpMethod);\n  }\n\n  // eslint-disable-next-line deprecation/deprecation\n  const dbSystem = attributes[semanticConventions.SEMATTRS_DB_SYSTEM];\n  const opIsCache =\n    typeof attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_OP] === 'string' &&\n    attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_OP].startsWith('cache.');\n\n  // If db.type exists then this is a database call span\n  // If the Redis DB is used as a cache, the span description should not be changed\n  if (dbSystem && !opIsCache) {\n    return descriptionForDbSystem({ attributes, name: spanName });\n  }\n\n  const customSourceOrRoute = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === 'custom' ? 'custom' : 'route';\n\n  // If rpc.service exists then this is a rpc call span.\n  // eslint-disable-next-line deprecation/deprecation\n  const rpcService = attributes[semanticConventions.SEMATTRS_RPC_SERVICE];\n  if (rpcService) {\n    return {\n      ...getUserUpdatedNameAndSource(spanName, attributes, 'route'),\n      op: 'rpc',\n    };\n  }\n\n  // If messaging.system exists then this is a messaging system span.\n  // eslint-disable-next-line deprecation/deprecation\n  const messagingSystem = attributes[semanticConventions.SEMATTRS_MESSAGING_SYSTEM];\n  if (messagingSystem) {\n    return {\n      ...getUserUpdatedNameAndSource(spanName, attributes, customSourceOrRoute),\n      op: 'message',\n    };\n  }\n\n  // If faas.trigger exists then this is a function as a service span.\n  // eslint-disable-next-line deprecation/deprecation\n  const faasTrigger = attributes[semanticConventions.SEMATTRS_FAAS_TRIGGER];\n  if (faasTrigger) {\n    return {\n      ...getUserUpdatedNameAndSource(spanName, attributes, customSourceOrRoute),\n      op: faasTrigger.toString(),\n    };\n  }\n\n  return { op: undefined, description: spanName, source: 'custom' };\n}\n\n/**\n * Extract better op/description from an otel span.\n *\n * Does not overwrite the span name if the source is already set to custom to ensure\n * that user-updated span names are preserved. In this case, we only adjust the op but\n * leave span description and source unchanged.\n *\n * Based on https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/7422ce2a06337f68a59b552b8c5a2ac125d6bae5/exporter/sentryexporter/sentry_exporter.go#L306\n */\nfunction parseSpanDescription(span) {\n  const attributes = spanHasAttributes(span) ? span.attributes : {};\n  const name = spanHasName(span) ? span.name : '<unknown>';\n  const kind = getSpanKind(span);\n\n  return inferSpanData(name, attributes, kind);\n}\n\nfunction descriptionForDbSystem({ attributes, name }) {\n  // if we already have a custom name, we don't overwrite it but only set the op\n  const userDefinedName = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n  if (typeof userDefinedName === 'string') {\n    return {\n      op: 'db',\n      description: userDefinedName,\n      source: (attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] ) || 'custom',\n    };\n  }\n\n  // if we already have the source set to custom, we don't overwrite the span description but only set the op\n  if (attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === 'custom') {\n    return { op: 'db', description: name, source: 'custom' };\n  }\n\n  // Use DB statement (Ex \"SELECT * FROM table\") if possible as description.\n  // eslint-disable-next-line deprecation/deprecation\n  const statement = attributes[semanticConventions.SEMATTRS_DB_STATEMENT];\n\n  const description = statement ? statement.toString() : name;\n\n  return { op: 'db', description, source: 'task' };\n}\n\n/** Only exported for tests. */\nfunction descriptionForHttpMethod(\n  { name, kind, attributes },\n  httpMethod,\n) {\n  const opParts = ['http'];\n\n  switch (kind) {\n    case api.SpanKind.CLIENT:\n      opParts.push('client');\n      break;\n    case api.SpanKind.SERVER:\n      opParts.push('server');\n      break;\n  }\n\n  // Spans for HTTP requests we have determined to be prefetch requests will have a `.prefetch` postfix in the op\n  if (attributes['sentry.http.prefetch']) {\n    opParts.push('prefetch');\n  }\n\n  const { urlPath, url, query, fragment, hasRoute } = getSanitizedUrl(attributes, kind);\n\n  if (!urlPath) {\n    return { ...getUserUpdatedNameAndSource(name, attributes), op: opParts.join('.') };\n  }\n\n  const graphqlOperationsAttribute = attributes[SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION];\n\n  // Ex. GET /api/users\n  const baseDescription = `${httpMethod} ${urlPath}`;\n\n  // When the http span has a graphql operation, append it to the description\n  // We add these in the graphqlIntegration\n  const inferredDescription = graphqlOperationsAttribute\n    ? `${baseDescription} (${getGraphqlOperationNamesFromAttribute(graphqlOperationsAttribute)})`\n    : baseDescription;\n\n  // If `httpPath` is a root path, then we can categorize the transaction source as route.\n  const inferredSource = hasRoute || urlPath === '/' ? 'route' : 'url';\n\n  const data = {};\n\n  if (url) {\n    data.url = url;\n  }\n  if (query) {\n    data['http.query'] = query;\n  }\n  if (fragment) {\n    data['http.fragment'] = fragment;\n  }\n\n  // If the span kind is neither client nor server, we use the original name\n  // this infers that somebody manually started this span, in which case we don't want to overwrite the name\n  const isClientOrServerKind = kind === api.SpanKind.CLIENT || kind === api.SpanKind.SERVER;\n\n  // If the span is an auto-span (=it comes from one of our instrumentations),\n  // we always want to infer the name\n  // this is necessary because some of the auto-instrumentation we use uses kind=INTERNAL\n  const origin = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] || 'manual';\n  const isManualSpan = !`${origin}`.startsWith('auto');\n\n  // If users (or in very rare occasions we) set the source to custom, we don't overwrite the name\n  const alreadyHasCustomSource = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === 'custom';\n  const customSpanName = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n\n  const useInferredDescription =\n    !alreadyHasCustomSource && customSpanName == null && (isClientOrServerKind || !isManualSpan);\n\n  const { description, source } = useInferredDescription\n    ? { description: inferredDescription, source: inferredSource }\n    : getUserUpdatedNameAndSource(name, attributes);\n\n  return {\n    op: opParts.join('.'),\n    description,\n    source,\n    data,\n  };\n}\n\nfunction getGraphqlOperationNamesFromAttribute(attr) {\n  if (Array.isArray(attr)) {\n    const sorted = attr.slice().sort();\n\n    // Up to 5 items, we just add all of them\n    if (sorted.length <= 5) {\n      return sorted.join(', ');\n    } else {\n      // Else, we add the first 5 and the diff of other operations\n      return `${sorted.slice(0, 5).join(', ')}, +${sorted.length - 5}`;\n    }\n  }\n\n  return `${attr}`;\n}\n\n/** Exported for tests only */\nfunction getSanitizedUrl(\n  attributes,\n  kind,\n)\n\n {\n  // This is the relative path of the URL, e.g. /sub\n  // eslint-disable-next-line deprecation/deprecation\n  const httpTarget = attributes[semanticConventions.SEMATTRS_HTTP_TARGET];\n  // This is the full URL, including host & query params etc., e.g. https://example.com/sub?foo=bar\n  // eslint-disable-next-line deprecation/deprecation\n  const httpUrl = attributes[semanticConventions.SEMATTRS_HTTP_URL] || attributes[semanticConventions.ATTR_URL_FULL];\n  // This is the normalized route name - may not always be available!\n  const httpRoute = attributes[semanticConventions.ATTR_HTTP_ROUTE];\n\n  const parsedUrl = typeof httpUrl === 'string' ? core.parseUrl(httpUrl) : undefined;\n  const url = parsedUrl ? core.getSanitizedUrlString(parsedUrl) : undefined;\n  const query = parsedUrl?.search || undefined;\n  const fragment = parsedUrl?.hash || undefined;\n\n  if (typeof httpRoute === 'string') {\n    return { urlPath: httpRoute, url, query, fragment, hasRoute: true };\n  }\n\n  if (kind === api.SpanKind.SERVER && typeof httpTarget === 'string') {\n    return { urlPath: core.stripUrlQueryAndFragment(httpTarget), url, query, fragment, hasRoute: false };\n  }\n\n  if (parsedUrl) {\n    return { urlPath: url, url, query, fragment, hasRoute: false };\n  }\n\n  // fall back to target even for client spans, if no URL is present\n  if (typeof httpTarget === 'string') {\n    return { urlPath: core.stripUrlQueryAndFragment(httpTarget), url, query, fragment, hasRoute: false };\n  }\n\n  return { urlPath: undefined, url, query, fragment, hasRoute: false };\n}\n\n/**\n * Because Otel instrumentation sometimes mutates span names via `span.updateName`, the only way\n * to ensure that a user-set span name is preserved is to store it as a tmp attribute on the span.\n * We delete this attribute once we're done with it when preparing the event envelope.\n *\n * This temp attribute always takes precedence over the original name.\n *\n * We also need to take care of setting the correct source. Users can always update the source\n * after updating the name, so we need to respect that.\n *\n * @internal exported only for testing\n */\nfunction getUserUpdatedNameAndSource(\n  originalName,\n  attributes,\n  fallbackSource = 'custom',\n)\n\n {\n  const source = (attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] ) || fallbackSource;\n  const description = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n\n  if (description && typeof description === 'string') {\n    return {\n      description,\n      source,\n    };\n  }\n\n  return { description: originalName, source };\n}\n\n/**\n * Setup a DSC handler on the passed client,\n * ensuring that the transaction name is inferred from the span correctly.\n */\nfunction enhanceDscWithOpenTelemetryRootSpanName(client) {\n  client.on('createDsc', (dsc, rootSpan) => {\n    if (!rootSpan) {\n      return;\n    }\n\n    // We want to overwrite the transaction on the DSC that is created by default in core\n    // The reason for this is that we want to infer the span name, not use the initial one\n    // Otherwise, we'll get names like \"GET\" instead of e.g. \"GET /foo\"\n    // `parseSpanDescription` takes the attributes of the span into account for the name\n    // This mutates the passed-in DSC\n\n    const jsonSpan = core.spanToJSON(rootSpan);\n    const attributes = jsonSpan.data;\n    const source = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n\n    const { description } = spanHasName(rootSpan) ? parseSpanDescription(rootSpan) : { description: undefined };\n    if (source !== 'url' && description) {\n      dsc.transaction = description;\n    }\n\n    // Also ensure sampling decision is correctly inferred\n    // In core, we use `spanIsSampled`, which just looks at the trace flags\n    // but in OTEL, we use a slightly more complex logic to be able to differntiate between unsampled and deferred sampling\n    if (core.hasSpansEnabled()) {\n      const sampled = getSamplingDecision(rootSpan.spanContext());\n      dsc.sampled = sampled == undefined ? undefined : String(sampled);\n    }\n  });\n}\n\n/**\n * Returns the currently active span.\n */\nfunction getActiveSpan() {\n  return api.trace.getActiveSpan();\n}\n\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nconst DEBUG_BUILD = (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__);\n\n/**\n * Generate a TraceState for the given data.\n */\nfunction makeTraceState({\n  dsc,\n  sampled,\n}\n\n) {\n  // We store the DSC as OTEL trace state on the span context\n  const dscString = dsc ? core.dynamicSamplingContextToSentryBaggageHeader(dsc) : undefined;\n\n  const traceStateBase = new core$1.TraceState();\n\n  const traceStateWithDsc = dscString ? traceStateBase.set(SENTRY_TRACE_STATE_DSC, dscString) : traceStateBase;\n\n  // We also specifically want to store if this is sampled to be not recording,\n  // or unsampled (=could be either sampled or not)\n  return sampled === false ? traceStateWithDsc.set(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING, '1') : traceStateWithDsc;\n}\n\nconst setupElements = new Set();\n\n/** Get all the OpenTelemetry elements that have been set up. */\nfunction openTelemetrySetupCheck() {\n  return Array.from(setupElements);\n}\n\n/** Mark an OpenTelemetry element as setup. */\nfunction setIsSetup(element) {\n  setupElements.add(element);\n}\n\n/**\n * Injects and extracts `sentry-trace` and `baggage` headers from carriers.\n */\nclass SentryPropagator extends core$1.W3CBaggagePropagator {\n  /** A map of URLs that have already been checked for if they match tracePropagationTargets. */\n\n   constructor() {\n    super();\n    setIsSetup('SentryPropagator');\n\n    // We're caching results so we don't have to recompute regexp every time we create a request.\n    this._urlMatchesTargetsMap = new core.LRUMap(100);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   inject(context, carrier, setter) {\n    if (core$1.isTracingSuppressed(context)) {\n      DEBUG_BUILD && core.debug.log('[Tracing] Not injecting trace data for url because tracing is suppressed.');\n      return;\n    }\n\n    const activeSpan = api.trace.getSpan(context);\n    const url = activeSpan && getCurrentURL(activeSpan);\n\n    const tracePropagationTargets = core.getClient()?.getOptions()?.tracePropagationTargets;\n    if (!shouldPropagateTraceForUrl(url, tracePropagationTargets, this._urlMatchesTargetsMap)) {\n      DEBUG_BUILD &&\n        core.debug.log('[Tracing] Not injecting trace data for url because it does not match tracePropagationTargets:', url);\n      return;\n    }\n\n    const existingBaggageHeader = getExistingBaggage(carrier);\n    let baggage = api.propagation.getBaggage(context) || api.propagation.createBaggage({});\n\n    const { dynamicSamplingContext, traceId, spanId, sampled } = getInjectionData(context);\n\n    if (existingBaggageHeader) {\n      const baggageEntries = core.parseBaggageHeader(existingBaggageHeader);\n\n      if (baggageEntries) {\n        Object.entries(baggageEntries).forEach(([key, value]) => {\n          baggage = baggage.setEntry(key, { value });\n        });\n      }\n    }\n\n    if (dynamicSamplingContext) {\n      baggage = Object.entries(dynamicSamplingContext).reduce((b, [dscKey, dscValue]) => {\n        if (dscValue) {\n          return b.setEntry(`${core.SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`, { value: dscValue });\n        }\n        return b;\n      }, baggage);\n    }\n\n    // We also want to avoid setting the default OTEL trace ID, if we get that for whatever reason\n    if (traceId && traceId !== api.INVALID_TRACEID) {\n      setter.set(carrier, SENTRY_TRACE_HEADER, core.generateSentryTraceHeader(traceId, spanId, sampled));\n    }\n\n    super.inject(api.propagation.setBaggage(context, baggage), carrier, setter);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   extract(context, carrier, getter) {\n    const maybeSentryTraceHeader = getter.get(carrier, SENTRY_TRACE_HEADER);\n    const baggage = getter.get(carrier, SENTRY_BAGGAGE_HEADER);\n\n    const sentryTrace = maybeSentryTraceHeader\n      ? Array.isArray(maybeSentryTraceHeader)\n        ? maybeSentryTraceHeader[0]\n        : maybeSentryTraceHeader\n      : undefined;\n\n    // Add remote parent span context\n    // If there is no incoming trace, this will return the context as-is\n    return ensureScopesOnContext(getContextWithRemoteActiveSpan(context, { sentryTrace, baggage }));\n  }\n\n  /**\n   * @inheritDoc\n   */\n   fields() {\n    return [SENTRY_TRACE_HEADER, SENTRY_BAGGAGE_HEADER];\n  }\n}\n\nconst NOT_PROPAGATED_MESSAGE =\n  '[Tracing] Not injecting trace data for url because it does not match tracePropagationTargets:';\n\n/**\n * Check if a given URL should be propagated to or not.\n * If no url is defined, or no trace propagation targets are defined, this will always return `true`.\n * You can also optionally provide a decision map, to cache decisions and avoid repeated regex lookups.\n */\nfunction shouldPropagateTraceForUrl(\n  url,\n  tracePropagationTargets,\n  decisionMap,\n) {\n  if (typeof url !== 'string' || !tracePropagationTargets) {\n    return true;\n  }\n\n  const cachedDecision = decisionMap?.get(url);\n  if (cachedDecision !== undefined) {\n    DEBUG_BUILD && !cachedDecision && core.debug.log(NOT_PROPAGATED_MESSAGE, url);\n    return cachedDecision;\n  }\n\n  const decision = core.stringMatchesSomePattern(url, tracePropagationTargets);\n  decisionMap?.set(url, decision);\n\n  DEBUG_BUILD && !decision && core.debug.log(NOT_PROPAGATED_MESSAGE, url);\n  return decision;\n}\n\n/**\n * Get propagation injection data for the given context.\n * The additional options can be passed to override the scope and client that is otherwise derived from the context.\n */\nfunction getInjectionData(\n  context,\n  options = {},\n)\n\n {\n  const span = api.trace.getSpan(context);\n\n  // If we have a remote span, the spanId should be considered as the parentSpanId, not spanId itself\n  // Instead, we use a virtual (generated) spanId for propagation\n  if (span?.spanContext().isRemote) {\n    const spanContext = span.spanContext();\n    const dynamicSamplingContext = core.getDynamicSamplingContextFromSpan(span);\n\n    return {\n      dynamicSamplingContext,\n      traceId: spanContext.traceId,\n      spanId: undefined,\n      sampled: getSamplingDecision(spanContext), // TODO: Do we need to change something here?\n    };\n  }\n\n  // If we have a local span, we just use this\n  if (span) {\n    const spanContext = span.spanContext();\n    const dynamicSamplingContext = core.getDynamicSamplingContextFromSpan(span);\n\n    return {\n      dynamicSamplingContext,\n      traceId: spanContext.traceId,\n      spanId: spanContext.spanId,\n      sampled: getSamplingDecision(spanContext), // TODO: Do we need to change something here?\n    };\n  }\n\n  // Else we try to use the propagation context from the scope\n  // The only scenario where this should happen is when we neither have a span, nor an incoming trace\n  const scope = options.scope || getScopesFromContext(context)?.scope || core.getCurrentScope();\n  const client = options.client || core.getClient();\n\n  const propagationContext = scope.getPropagationContext();\n  const dynamicSamplingContext = client ? core.getDynamicSamplingContextFromScope(client, scope) : undefined;\n  return {\n    dynamicSamplingContext,\n    traceId: propagationContext.traceId,\n    spanId: propagationContext.propagationSpanId,\n    sampled: propagationContext.sampled,\n  };\n}\n\nfunction getContextWithRemoteActiveSpan(\n  ctx,\n  { sentryTrace, baggage },\n) {\n  const propagationContext = core.propagationContextFromHeaders(sentryTrace, baggage);\n\n  const { traceId, parentSpanId, sampled, dsc } = propagationContext;\n\n  const client = core.getClient();\n  const incomingDsc = core.baggageHeaderToDynamicSamplingContext(baggage);\n\n  // We only want to set the virtual span if we are continuing a concrete trace\n  // Otherwise, we ignore the incoming trace here, e.g. if we have no trace headers\n  if (!parentSpanId || (client && !core.shouldContinueTrace(client, incomingDsc?.org_id))) {\n    return ctx;\n  }\n\n  const spanContext = generateRemoteSpanContext({\n    traceId,\n    spanId: parentSpanId,\n    sampled,\n    dsc,\n  });\n\n  return api.trace.setSpanContext(ctx, spanContext);\n}\n\n/**\n * Takes trace strings and propagates them as a remote active span.\n * This should be used in addition to `continueTrace` in OTEL-powered environments.\n */\nfunction continueTraceAsRemoteSpan(\n  ctx,\n  options,\n  callback,\n) {\n  const ctxWithSpanContext = ensureScopesOnContext(getContextWithRemoteActiveSpan(ctx, options));\n\n  return api.context.with(ctxWithSpanContext, callback);\n}\n\nfunction ensureScopesOnContext(ctx) {\n  // If there are no scopes yet on the context, ensure we have them\n  const scopes = getScopesFromContext(ctx);\n  const newScopes = {\n    // If we have no scope here, this is most likely either the root context or a context manually derived from it\n    // In this case, we want to fork the current scope, to ensure we do not pollute the root scope\n    scope: scopes ? scopes.scope : core.getCurrentScope().clone(),\n    isolationScope: scopes ? scopes.isolationScope : core.getIsolationScope(),\n  };\n\n  return setScopesOnContext(ctx, newScopes);\n}\n\n/** Try to get the existing baggage header so we can merge this in. */\nfunction getExistingBaggage(carrier) {\n  try {\n    const baggage = (carrier )[SENTRY_BAGGAGE_HEADER];\n    return Array.isArray(baggage) ? baggage.join(',') : baggage;\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * It is pretty tricky to get access to the outgoing request URL of a request in the propagator.\n * As we only have access to the context of the span to be sent and the carrier (=headers),\n * but the span may be unsampled and thus have no attributes.\n *\n * So we use the following logic:\n * 1. If we have an active span, we check if it has a URL attribute.\n * 2. Else, if the active span has no URL attribute (e.g. it is unsampled), we check a special trace state (which we set in our sampler).\n */\nfunction getCurrentURL(span) {\n  const spanData = core.spanToJSON(span).data;\n  // `ATTR_URL_FULL` is the new attribute, but we still support the old one, `SEMATTRS_HTTP_URL`, for now.\n  // eslint-disable-next-line deprecation/deprecation\n  const urlAttribute = spanData[semanticConventions.SEMATTRS_HTTP_URL] || spanData[semanticConventions.ATTR_URL_FULL];\n  if (typeof urlAttribute === 'string') {\n    return urlAttribute;\n  }\n\n  // Also look at the traceState, which we may set in the sampler even for unsampled spans\n  const urlTraceState = span.spanContext().traceState?.get(SENTRY_TRACE_STATE_URL);\n  if (urlTraceState) {\n    return urlTraceState;\n  }\n\n  return undefined;\n}\n\nfunction generateRemoteSpanContext({\n  spanId,\n  traceId,\n  sampled,\n  dsc,\n}\n\n) {\n  // We store the DSC as OTEL trace state on the span context\n  const traceState = makeTraceState({\n    dsc,\n    sampled,\n  });\n\n  const spanContext = {\n    traceId,\n    spanId,\n    isRemote: true,\n    traceFlags: sampled ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE,\n    traceState,\n  };\n\n  return spanContext;\n}\n\n/**\n * Wraps a function with a transaction/span and finishes the span after the function is done.\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * If you want to create a span that is not set as active, use {@link startInactiveSpan}.\n *\n * You'll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startSpan(options, callback) {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !api.trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? core$1.suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    return tracer.startActiveSpan(name, spanOptions, ctx, span => {\n      return core.handleCallbackErrors(\n        () => callback(span),\n        () => {\n          // Only set the span status to ERROR when there wasn't any status set before, in order to avoid stomping useful span statuses\n          if (core.spanToJSON(span).status === undefined) {\n            span.setStatus({ code: api.SpanStatusCode.ERROR });\n          }\n        },\n        () => span.end(),\n      );\n    });\n  });\n}\n\n/**\n * Similar to `Sentry.startSpan`. Wraps a function with a span, but does not finish the span\n * after the function is done automatically. You'll have to call `span.end()` manually.\n *\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * You'll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startSpanManual(\n  options,\n  callback,\n) {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !api.trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? core$1.suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    return tracer.startActiveSpan(name, spanOptions, ctx, span => {\n      return core.handleCallbackErrors(\n        () => callback(span, () => span.end()),\n        () => {\n          // Only set the span status to ERROR when there wasn't any status set before, in order to avoid stomping useful span statuses\n          if (core.spanToJSON(span).status === undefined) {\n            span.setStatus({ code: api.SpanStatusCode.ERROR });\n          }\n        },\n      );\n    });\n  });\n}\n\n/**\n * Creates a span. This span is not set as active, so will not get automatic instrumentation spans\n * as children or be able to be accessed via `Sentry.getActiveSpan()`.\n *\n * If you want to create a span that is set as active, use {@link startSpan}.\n *\n * This function will always return a span,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startInactiveSpan(options) {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !api.trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? core$1.suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    const span = tracer.startSpan(name, spanOptions, ctx);\n\n    return span;\n  });\n}\n\n/**\n * Forks the current scope and sets the provided span as active span in the context of the provided callback. Can be\n * passed `null` to start an entirely new span tree.\n *\n * @param span Spans started in the context of the provided callback will be children of this span. If `null` is passed,\n * spans started within the callback will be root spans.\n * @param callback Execution context in which the provided span will be active. Is passed the newly forked scope.\n * @returns the value returned from the provided callback function.\n */\nfunction withActiveSpan(span, callback) {\n  const newContextWithActiveSpan = span ? api.trace.setSpan(api.context.active(), span) : api.trace.deleteSpan(api.context.active());\n  return api.context.with(newContextWithActiveSpan, () => callback(core.getCurrentScope()));\n}\n\nfunction getTracer() {\n  const client = core.getClient();\n  return client?.tracer || api.trace.getTracer('@sentry/opentelemetry', core.SDK_VERSION);\n}\n\nfunction getSpanOptions(options) {\n  const { startTime, attributes, kind, op, links } = options;\n\n  // OTEL expects timestamps in ms, not seconds\n  const fixedStartTime = typeof startTime === 'number' ? ensureTimestampInMilliseconds(startTime) : startTime;\n\n  return {\n    attributes: op\n      ? {\n          [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n          ...attributes,\n        }\n      : attributes,\n    kind,\n    links,\n    startTime: fixedStartTime,\n  };\n}\n\nfunction ensureTimestampInMilliseconds(timestamp) {\n  const isMs = timestamp < 9999999999;\n  return isMs ? timestamp * 1000 : timestamp;\n}\n\nfunction getContext(scope, forceTransaction) {\n  const ctx = getContextForScope(scope);\n  const parentSpan = api.trace.getSpan(ctx);\n\n  // In the case that we have no parent span, we start a new trace\n  // Note that if we continue a trace, we'll always have a remote parent span here anyhow\n  if (!parentSpan) {\n    return ctx;\n  }\n\n  // If we don't want to force a transaction, and we have a parent span, all good, we just return as-is!\n  if (!forceTransaction) {\n    return ctx;\n  }\n\n  // Else, if we do have a parent span but want to force a transaction, we have to simulate a \"root\" context\n\n  // Else, we need to do two things:\n  // 1. Unset the parent span from the context, so we'll create a new root span\n  // 2. Ensure the propagation context is correct, so we'll continue from the parent span\n  const ctxWithoutSpan = api.trace.deleteSpan(ctx);\n\n  const { spanId, traceId } = parentSpan.spanContext();\n  const sampled = getSamplingDecision(parentSpan.spanContext());\n\n  // In this case, when we are forcing a transaction, we want to treat this like continuing an incoming trace\n  // so we set the traceState according to the root span\n  const rootSpan = core.getRootSpan(parentSpan);\n  const dsc = core.getDynamicSamplingContextFromSpan(rootSpan);\n\n  const traceState = makeTraceState({\n    dsc,\n    sampled,\n  });\n\n  const spanOptions = {\n    traceId,\n    spanId,\n    isRemote: true,\n    traceFlags: sampled ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE,\n    traceState,\n  };\n\n  const ctxWithSpanContext = api.trace.setSpanContext(ctxWithoutSpan, spanOptions);\n\n  return ctxWithSpanContext;\n}\n\nfunction getContextForScope(scope) {\n  if (scope) {\n    const ctx = getContextFromScope(scope);\n    if (ctx) {\n      return ctx;\n    }\n  }\n\n  return api.context.active();\n}\n\n/**\n * Continue a trace from `sentry-trace` and `baggage` values.\n * These values can be obtained from incoming request headers, or in the browser from `<meta name=\"sentry-trace\">`\n * and `<meta name=\"baggage\">` HTML tags.\n *\n * Spans started with `startSpan`, `startSpanManual` and `startInactiveSpan`, within the callback will automatically\n * be attached to the incoming trace.\n *\n * This is a custom version of `continueTrace` that is used in OTEL-powered environments.\n * It propagates the trace as a remote span, in addition to setting it on the propagation context.\n */\nfunction continueTrace(options, callback) {\n  return continueTraceAsRemoteSpan(api.context.active(), options, callback);\n}\n\n/**\n * Get the trace context for a given scope.\n * We have a custom implementation here because we need an OTEL-specific way to get the span from a scope.\n */\nfunction getTraceContextForScope(\n  client,\n  scope,\n) {\n  const ctx = getContextFromScope(scope);\n  const span = ctx && api.trace.getSpan(ctx);\n\n  const traceContext = span ? core.spanToTraceContext(span) : core.getTraceContextFromScope(scope);\n\n  const dynamicSamplingContext = span\n    ? core.getDynamicSamplingContextFromSpan(span)\n    : core.getDynamicSamplingContextFromScope(client, scope);\n  return [dynamicSamplingContext, traceContext];\n}\n\nfunction getActiveSpanWrapper(parentSpan) {\n  return parentSpan !== undefined\n    ? (callback) => {\n        return withActiveSpan(parentSpan, callback);\n      }\n    : (callback) => callback();\n}\n\n/** Suppress tracing in the given callback, ensuring no spans are generated inside of it. */\nfunction suppressTracing(callback) {\n  const ctx = core$1.suppressTracing(api.context.active());\n  return api.context.with(ctx, callback);\n}\n\n/** Ensure the `trace` context is set on all events. */\nfunction setupEventContextTrace(client) {\n  client.on('preprocessEvent', event => {\n    const span = getActiveSpan();\n    // For transaction events, this is handled separately\n    // Because the active span may not be the span that is actually the transaction event\n    if (!span || event.type === 'transaction') {\n      return;\n    }\n\n    // If event has already set `trace` context, use that one.\n    event.contexts = {\n      trace: core.spanToTraceContext(span),\n      ...event.contexts,\n    };\n\n    const rootSpan = core.getRootSpan(span);\n\n    event.sdkProcessingMetadata = {\n      dynamicSamplingContext: core.getDynamicSamplingContextFromSpan(rootSpan),\n      ...event.sdkProcessingMetadata,\n    };\n\n    return event;\n  });\n}\n\n/**\n * Otel-specific implementation of `getTraceData`.\n * @see `@sentry/core` version of `getTraceData` for more information\n */\nfunction getTraceData({\n  span,\n  scope,\n  client,\n} = {}) {\n  let ctx = (scope && getContextFromScope(scope)) ?? api.context.active();\n\n  if (span) {\n    const { scope } = core.getCapturedScopesOnSpan(span);\n    // fall back to current context if for whatever reason we can't find the one of the span\n    ctx = (scope && getContextFromScope(scope)) || api.trace.setSpan(api.context.active(), span);\n  }\n\n  const { traceId, spanId, sampled, dynamicSamplingContext } = getInjectionData(ctx, { scope, client });\n\n  return {\n    'sentry-trace': core.generateSentryTraceHeader(traceId, spanId, sampled),\n    baggage: core.dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext),\n  };\n}\n\n/**\n * Sets the async context strategy to use follow the OTEL context under the hood.\n * We handle forking a hub inside of our custom OTEL Context Manager (./otelContextManager.ts)\n */\nfunction setOpenTelemetryContextAsyncContextStrategy() {\n  function getScopes() {\n    const ctx = api.context.active();\n    const scopes = getScopesFromContext(ctx);\n\n    if (scopes) {\n      return scopes;\n    }\n\n    // fallback behavior:\n    // if, for whatever reason, we can't find scopes on the context here, we have to fix this somehow\n    return {\n      scope: core.getDefaultCurrentScope(),\n      isolationScope: core.getDefaultIsolationScope(),\n    };\n  }\n\n  function withScope(callback) {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    // as by default, we don't want to fork this, unless triggered explicitly by `withScope`\n    return api.context.with(ctx, () => {\n      return callback(getCurrentScope());\n    });\n  }\n\n  function withSetScope(scope, callback) {\n    const ctx = getContextFromScope(scope) || api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_SET_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which picks up this scope as the current scope\n    return api.context.with(ctx.setValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY, scope), () => {\n      return callback(scope);\n    });\n  }\n\n  function withIsolationScope(callback) {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    return api.context.with(ctx.setValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY, true), () => {\n      return callback(getIsolationScope());\n    });\n  }\n\n  function withSetIsolationScope(isolationScope, callback) {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    return api.context.with(ctx.setValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY, isolationScope), () => {\n      return callback(getIsolationScope());\n    });\n  }\n\n  function getCurrentScope() {\n    return getScopes().scope;\n  }\n\n  function getIsolationScope() {\n    return getScopes().isolationScope;\n  }\n\n  core.setAsyncContextStrategy({\n    withScope,\n    withSetScope,\n    withSetIsolationScope,\n    withIsolationScope,\n    getCurrentScope,\n    getIsolationScope,\n    startSpan,\n    startSpanManual,\n    startInactiveSpan,\n    getActiveSpan,\n    suppressTracing,\n    getTraceData,\n    continueTrace,\n    // The types here don't fully align, because our own `Span` type is narrower\n    // than the OTEL one - but this is OK for here, as we now we'll only have OTEL spans passed around\n    withActiveSpan: withActiveSpan ,\n  });\n}\n\n/**\n * Wrap an OpenTelemetry ContextManager in a way that ensures the context is kept in sync with the Sentry Scope.\n *\n * Usage:\n * import { AsyncLocalStorageContextManager } from '@opentelemetry/context-async-hooks';\n * const SentryContextManager = wrapContextManagerClass(AsyncLocalStorageContextManager);\n * const contextManager = new SentryContextManager();\n */\nfunction wrapContextManagerClass(\n  ContextManagerClass,\n) {\n  /**\n   * This is a custom ContextManager for OpenTelemetry, which extends the default AsyncLocalStorageContextManager.\n   * It ensures that we create new scopes per context, so that the OTEL Context & the Sentry Scope are always in sync.\n   *\n   * Note that we currently only support AsyncHooks with this,\n   * but since this should work for Node 14+ anyhow that should be good enough.\n   */\n\n  // @ts-expect-error TS does not like this, but we know this is fine\n  class SentryContextManager extends ContextManagerClass {\n     constructor(...args) {\n      super(...args);\n      setIsSetup('SentryContextManager');\n    }\n    /**\n     * Overwrite with() of the original AsyncLocalStorageContextManager\n     * to ensure we also create new scopes per context.\n     */\n     with(\n      context,\n      fn,\n      thisArg,\n      ...args\n    ) {\n      const currentScopes = getScopesFromContext(context);\n      const currentScope = currentScopes?.scope || core.getCurrentScope();\n      const currentIsolationScope = currentScopes?.isolationScope || core.getIsolationScope();\n\n      const shouldForkIsolationScope = context.getValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY) === true;\n      const scope = context.getValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY) ;\n      const isolationScope = context.getValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY) ;\n\n      const newCurrentScope = scope || currentScope.clone();\n      const newIsolationScope =\n        isolationScope || (shouldForkIsolationScope ? currentIsolationScope.clone() : currentIsolationScope);\n      const scopes = { scope: newCurrentScope, isolationScope: newIsolationScope };\n\n      const ctx1 = setScopesOnContext(context, scopes);\n\n      // Remove the unneeded values again\n      const ctx2 = ctx1\n        .deleteValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY)\n        .deleteValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY)\n        .deleteValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY);\n\n      setContextOnScope(newCurrentScope, ctx2);\n\n      return super.with(ctx2, fn, thisArg, ...args);\n    }\n  }\n\n  return SentryContextManager ;\n}\n\n/**\n * This function runs through a list of OTEL Spans, and wraps them in an `SpanNode`\n * where each node holds a reference to their parent node.\n */\nfunction groupSpansWithParents(spans) {\n  const nodeMap = new Map();\n\n  for (const span of spans) {\n    createOrUpdateSpanNodeAndRefs(nodeMap, span);\n  }\n\n  return Array.from(nodeMap, function ([_id, spanNode]) {\n    return spanNode;\n  });\n}\n\n/**\n * This returns the _local_ parent ID - `parentId` on the span may point to a remote span.\n */\nfunction getLocalParentId(span) {\n  const parentIsRemote = span.attributes[SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE] === true;\n  // If the parentId is the trace parent ID, we pretend it's undefined\n  // As this means the parent exists somewhere else\n  return !parentIsRemote ? getParentSpanId(span) : undefined;\n}\n\nfunction createOrUpdateSpanNodeAndRefs(nodeMap, span) {\n  const id = span.spanContext().spanId;\n  const parentId = getLocalParentId(span);\n\n  if (!parentId) {\n    createOrUpdateNode(nodeMap, { id, span, children: [] });\n    return;\n  }\n\n  // Else make sure to create parent node as well\n  // Note that the parent may not know it's parent _yet_, this may be updated in a later pass\n  const parentNode = createOrGetParentNode(nodeMap, parentId);\n  const node = createOrUpdateNode(nodeMap, { id, span, parentNode, children: [] });\n  parentNode.children.push(node);\n}\n\nfunction createOrGetParentNode(nodeMap, id) {\n  const existing = nodeMap.get(id);\n\n  if (existing) {\n    return existing;\n  }\n\n  return createOrUpdateNode(nodeMap, { id, children: [] });\n}\n\nfunction createOrUpdateNode(nodeMap, spanNode) {\n  const existing = nodeMap.get(spanNode.id);\n\n  // If span is already set, nothing to do here\n  if (existing?.span) {\n    return existing;\n  }\n\n  // If it exists but span is not set yet, we update it\n  if (existing && !existing.span) {\n    existing.span = spanNode.span;\n    existing.parentNode = spanNode.parentNode;\n    return existing;\n  }\n\n  // Else, we create a new one...\n  nodeMap.set(spanNode.id, spanNode);\n  return spanNode;\n}\n\n// canonicalCodesGrpcMap maps some GRPC codes to Sentry's span statuses. See description in grpc documentation.\nconst canonicalGrpcErrorCodesMap = {\n  '1': 'cancelled',\n  '2': 'unknown_error',\n  '3': 'invalid_argument',\n  '4': 'deadline_exceeded',\n  '5': 'not_found',\n  '6': 'already_exists',\n  '7': 'permission_denied',\n  '8': 'resource_exhausted',\n  '9': 'failed_precondition',\n  '10': 'aborted',\n  '11': 'out_of_range',\n  '12': 'unimplemented',\n  '13': 'internal_error',\n  '14': 'unavailable',\n  '15': 'data_loss',\n  '16': 'unauthenticated',\n} ;\n\nconst isStatusErrorMessageValid = (message) => {\n  return Object.values(canonicalGrpcErrorCodesMap).includes(message );\n};\n\n/**\n * Get a Sentry span status from an otel span.\n */\nfunction mapStatus(span) {\n  const attributes = spanHasAttributes(span) ? span.attributes : {};\n  const status = spanHasStatus(span) ? span.status : undefined;\n\n  if (status) {\n    // Since span status OK is not set by default, we give it priority: https://opentelemetry.io/docs/concepts/signals/traces/#span-status\n    if (status.code === api.SpanStatusCode.OK) {\n      return { code: core.SPAN_STATUS_OK };\n      // If the span is already marked as erroneous we return that exact status\n    } else if (status.code === api.SpanStatusCode.ERROR) {\n      if (typeof status.message === 'undefined') {\n        const inferredStatus = inferStatusFromAttributes(attributes);\n        if (inferredStatus) {\n          return inferredStatus;\n        }\n      }\n\n      if (status.message && isStatusErrorMessageValid(status.message)) {\n        return { code: core.SPAN_STATUS_ERROR, message: status.message };\n      } else {\n        return { code: core.SPAN_STATUS_ERROR, message: 'unknown_error' };\n      }\n    }\n  }\n\n  // If the span status is UNSET, we try to infer it from HTTP or GRPC status codes.\n  const inferredStatus = inferStatusFromAttributes(attributes);\n\n  if (inferredStatus) {\n    return inferredStatus;\n  }\n\n  // We default to setting the spans status to ok.\n  if (status?.code === api.SpanStatusCode.UNSET) {\n    return { code: core.SPAN_STATUS_OK };\n  } else {\n    return { code: core.SPAN_STATUS_ERROR, message: 'unknown_error' };\n  }\n}\n\nfunction inferStatusFromAttributes(attributes) {\n  // If the span status is UNSET, we try to infer it from HTTP or GRPC status codes.\n\n  // eslint-disable-next-line deprecation/deprecation\n  const httpCodeAttribute = attributes[semanticConventions.ATTR_HTTP_RESPONSE_STATUS_CODE] || attributes[semanticConventions.SEMATTRS_HTTP_STATUS_CODE];\n  // eslint-disable-next-line deprecation/deprecation\n  const grpcCodeAttribute = attributes[semanticConventions.SEMATTRS_RPC_GRPC_STATUS_CODE];\n\n  const numberHttpCode =\n    typeof httpCodeAttribute === 'number'\n      ? httpCodeAttribute\n      : typeof httpCodeAttribute === 'string'\n        ? parseInt(httpCodeAttribute)\n        : undefined;\n\n  if (typeof numberHttpCode === 'number') {\n    return core.getSpanStatusFromHttpCode(numberHttpCode);\n  }\n\n  if (typeof grpcCodeAttribute === 'string') {\n    return { code: core.SPAN_STATUS_ERROR, message: canonicalGrpcErrorCodesMap[grpcCodeAttribute] || 'unknown_error' };\n  }\n\n  return undefined;\n}\n\nconst MAX_SPAN_COUNT = 1000;\nconst DEFAULT_TIMEOUT = 300; // 5 min\n\n/**\n * A Sentry-specific exporter that converts OpenTelemetry Spans to Sentry Spans & Transactions.\n */\nclass SentrySpanExporter {\n  /*\n   * A quick explanation on the buckets: We do bucketing of finished spans for efficiency. This span exporter is\n   * accumulating spans until a root span is encountered and then it flushes all the spans that are descendants of that\n   * root span. Because it is totally in the realm of possibilities that root spans are never finished, and we don't\n   * want to accumulate spans indefinitely in memory, we need to periodically evacuate spans. Naively we could simply\n   * store the spans in an array and each time a new span comes in we could iterate through the entire array and\n   * evacuate all spans that have an end-timestamp that is older than our limit. This could get quite expensive because\n   * we would have to iterate a potentially large number of spans every time we evacuate. We want to avoid these large\n   * bursts of computation.\n   *\n   * Instead we go for a bucketing approach and put spans into buckets, based on what second\n   * (modulo the time limit) the span was put into the exporter. With buckets, when we decide to evacuate, we can\n   * iterate through the bucket entries instead, which have an upper bound of items, making the evacuation much more\n   * efficient. Cleaning up also becomes much more efficient since it simply involves de-referencing a bucket within the\n   * bucket array, and letting garbage collection take care of the rest.\n   */\n\n  // Essentially a a set of span ids that are already sent. The values are expiration\n  // times in this cache so we don't hold onto them indefinitely.\n\n  /* Internally, we use a debounced flush to give some wiggle room to the span processor to accumulate more spans. */\n\n   constructor(options\n\n) {\n    this._finishedSpanBucketSize = options?.timeout || DEFAULT_TIMEOUT;\n    this._finishedSpanBuckets = new Array(this._finishedSpanBucketSize).fill(undefined);\n    this._lastCleanupTimestampInS = Math.floor(Date.now() / 1000);\n    this._spansToBucketEntry = new WeakMap();\n    this._sentSpans = new Map();\n    this._debouncedFlush = core.debounce(this.flush.bind(this), 1, { maxWait: 100 });\n  }\n\n  /**\n   * Export a single span.\n   * This is called by the span processor whenever a span is ended.\n   */\n   export(span) {\n    const currentTimestampInS = Math.floor(Date.now() / 1000);\n\n    if (this._lastCleanupTimestampInS !== currentTimestampInS) {\n      let droppedSpanCount = 0;\n      this._finishedSpanBuckets.forEach((bucket, i) => {\n        if (bucket && bucket.timestampInS <= currentTimestampInS - this._finishedSpanBucketSize) {\n          droppedSpanCount += bucket.spans.size;\n          this._finishedSpanBuckets[i] = undefined;\n        }\n      });\n      if (droppedSpanCount > 0) {\n        DEBUG_BUILD &&\n          core.debug.log(\n            `SpanExporter dropped ${droppedSpanCount} spans because they were pending for more than ${this._finishedSpanBucketSize} seconds.`,\n          );\n      }\n      this._lastCleanupTimestampInS = currentTimestampInS;\n    }\n\n    const currentBucketIndex = currentTimestampInS % this._finishedSpanBucketSize;\n    const currentBucket = this._finishedSpanBuckets[currentBucketIndex] || {\n      timestampInS: currentTimestampInS,\n      spans: new Set(),\n    };\n    this._finishedSpanBuckets[currentBucketIndex] = currentBucket;\n    currentBucket.spans.add(span);\n    this._spansToBucketEntry.set(span, currentBucket);\n\n    // If the span doesn't have a local parent ID (it's a root span), we're gonna flush all the ended spans\n    const localParentId = getLocalParentId(span);\n    if (!localParentId || this._sentSpans.has(localParentId)) {\n      this._debouncedFlush();\n    }\n  }\n\n  /**\n   * Try to flush any pending spans immediately.\n   * This is called internally by the exporter (via _debouncedFlush),\n   * but can also be triggered externally if we force-flush.\n   */\n   flush() {\n    const finishedSpans = this._finishedSpanBuckets.flatMap(bucket => (bucket ? Array.from(bucket.spans) : []));\n\n    this._flushSentSpanCache();\n    const sentSpans = this._maybeSend(finishedSpans);\n\n    const sentSpanCount = sentSpans.size;\n    const remainingOpenSpanCount = finishedSpans.length - sentSpanCount;\n    DEBUG_BUILD &&\n      core.debug.log(\n        `SpanExporter exported ${sentSpanCount} spans, ${remainingOpenSpanCount} spans are waiting for their parent spans to finish`,\n      );\n\n    const expirationDate = Date.now() + DEFAULT_TIMEOUT * 1000;\n\n    for (const span of sentSpans) {\n      this._sentSpans.set(span.spanContext().spanId, expirationDate);\n      const bucketEntry = this._spansToBucketEntry.get(span);\n      if (bucketEntry) {\n        bucketEntry.spans.delete(span);\n      }\n    }\n    // Cancel a pending debounced flush, if there is one\n    // This can be relevant if we directly flush, circumventing the debounce\n    // in that case, we want to cancel any pending debounced flush\n    this._debouncedFlush.cancel();\n  }\n\n  /**\n   * Clear the exporter.\n   * This is called when the span processor is shut down.\n   */\n   clear() {\n    this._finishedSpanBuckets = this._finishedSpanBuckets.fill(undefined);\n    this._sentSpans.clear();\n    this._debouncedFlush.cancel();\n  }\n\n  /**\n   * Send the given spans, but only if they are part of a finished transaction.\n   *\n   * Returns the sent spans.\n   * Spans remain unsent when their parent span is not yet finished.\n   * This will happen regularly, as child spans are generally finished before their parents.\n   * But it _could_ also happen because, for whatever reason, a parent span was lost.\n   * In this case, we'll eventually need to clean this up.\n   */\n   _maybeSend(spans) {\n    const grouped = groupSpansWithParents(spans);\n    const sentSpans = new Set();\n\n    const rootNodes = this._getCompletedRootNodes(grouped);\n\n    for (const root of rootNodes) {\n      const span = root.span;\n      sentSpans.add(span);\n      const transactionEvent = createTransactionForOtelSpan(span);\n\n      // Add an attribute to the transaction event to indicate that this transaction is an orphaned transaction\n      if (root.parentNode && this._sentSpans.has(root.parentNode.id)) {\n        const traceData = transactionEvent.contexts?.trace?.data;\n        if (traceData) {\n          traceData['sentry.parent_span_already_sent'] = true;\n        }\n      }\n\n      // We'll recursively add all the child spans to this array\n      const spans = transactionEvent.spans || [];\n\n      for (const child of root.children) {\n        createAndFinishSpanForOtelSpan(child, spans, sentSpans);\n      }\n\n      // spans.sort() mutates the array, but we do not use this anymore after this point\n      // so we can safely mutate it here\n      transactionEvent.spans =\n        spans.length > MAX_SPAN_COUNT\n          ? spans.sort((a, b) => a.start_timestamp - b.start_timestamp).slice(0, MAX_SPAN_COUNT)\n          : spans;\n\n      const measurements = core.timedEventsToMeasurements(span.events);\n      if (measurements) {\n        transactionEvent.measurements = measurements;\n      }\n\n      core.captureEvent(transactionEvent);\n    }\n\n    return sentSpans;\n  }\n\n  /** Remove \"expired\" span id entries from the _sentSpans cache. */\n   _flushSentSpanCache() {\n    const currentTimestamp = Date.now();\n    // Note, it is safe to delete items from the map as we go: https://stackoverflow.com/a/35943995/90297\n    for (const [spanId, expirationTime] of this._sentSpans.entries()) {\n      if (expirationTime <= currentTimestamp) {\n        this._sentSpans.delete(spanId);\n      }\n    }\n  }\n\n  /** Check if a node is a completed root node or a node whose parent has already been sent */\n   _nodeIsCompletedRootNodeOrHasSentParent(node) {\n    return !!node.span && (!node.parentNode || this._sentSpans.has(node.parentNode.id));\n  }\n\n  /** Get all completed root nodes from a list of nodes */\n   _getCompletedRootNodes(nodes) {\n    // TODO: We should be able to remove the explicit `node is SpanNodeCompleted` type guard\n    //       once we stop supporting TS < 5.5\n    return nodes.filter((node) => this._nodeIsCompletedRootNodeOrHasSentParent(node));\n  }\n}\n\nfunction parseSpan(span) {\n  const attributes = span.attributes;\n\n  const origin = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] ;\n  const op = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_OP] ;\n  const source = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] ;\n\n  return { origin, op, source };\n}\n\n/** Exported only for tests. */\nfunction createTransactionForOtelSpan(span) {\n  const { op, description, data, origin = 'manual', source } = getSpanData(span);\n  const capturedSpanScopes = core.getCapturedScopesOnSpan(span );\n\n  const sampleRate = span.attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE] ;\n\n  const attributes = {\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: sampleRate,\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: origin,\n    ...data,\n    ...removeSentryAttributes(span.attributes),\n  };\n\n  const { links } = span;\n  const { traceId: trace_id, spanId: span_id } = span.spanContext();\n\n  // If parentSpanIdFromTraceState is defined at all, we want it to take precedence\n  // In that case, an empty string should be interpreted as \"no parent span id\",\n  // even if `span.parentSpanId` is set\n  // this is the case when we are starting a new trace, where we have a virtual span based on the propagationContext\n  // We only want to continue the traceId in this case, but ignore the parent span\n  const parent_span_id = getParentSpanId(span);\n\n  const status = mapStatus(span);\n\n  const traceContext = {\n    parent_span_id,\n    span_id,\n    trace_id,\n    data: attributes,\n    origin,\n    op,\n    status: core.getStatusMessage(status), // As per protocol, span status is allowed to be undefined\n    links: core.convertSpanLinksForEnvelope(links),\n  };\n\n  const statusCode = attributes[semanticConventions.ATTR_HTTP_RESPONSE_STATUS_CODE];\n  const responseContext = typeof statusCode === 'number' ? { response: { status_code: statusCode } } : undefined;\n\n  const transactionEvent = {\n    contexts: {\n      trace: traceContext,\n      otel: {\n        resource: span.resource.attributes,\n      },\n      ...responseContext,\n    },\n    spans: [],\n    start_timestamp: core.spanTimeInputToSeconds(span.startTime),\n    timestamp: core.spanTimeInputToSeconds(span.endTime),\n    transaction: description,\n    type: 'transaction',\n    sdkProcessingMetadata: {\n      capturedSpanScope: capturedSpanScopes.scope,\n      capturedSpanIsolationScope: capturedSpanScopes.isolationScope,\n      sampleRate,\n      dynamicSamplingContext: core.getDynamicSamplingContextFromSpan(span ),\n    },\n    ...(source && {\n      transaction_info: {\n        source,\n      },\n    }),\n  };\n\n  return transactionEvent;\n}\n\nfunction createAndFinishSpanForOtelSpan(node, spans, sentSpans) {\n  const span = node.span;\n\n  if (span) {\n    sentSpans.add(span);\n  }\n\n  const shouldDrop = !span;\n\n  // If this span should be dropped, we still want to create spans for the children of this\n  if (shouldDrop) {\n    node.children.forEach(child => {\n      createAndFinishSpanForOtelSpan(child, spans, sentSpans);\n    });\n    return;\n  }\n\n  const span_id = span.spanContext().spanId;\n  const trace_id = span.spanContext().traceId;\n  const parentSpanId = getParentSpanId(span);\n\n  const { attributes, startTime, endTime, links } = span;\n\n  const { op, description, data, origin = 'manual' } = getSpanData(span);\n  const allData = {\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: origin,\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n    ...removeSentryAttributes(attributes),\n    ...data,\n  };\n\n  const status = mapStatus(span);\n\n  const spanJSON = {\n    span_id,\n    trace_id,\n    data: allData,\n    description,\n    parent_span_id: parentSpanId,\n    start_timestamp: core.spanTimeInputToSeconds(startTime),\n    // This is [0,0] by default in OTEL, in which case we want to interpret this as no end time\n    timestamp: core.spanTimeInputToSeconds(endTime) || undefined,\n    status: core.getStatusMessage(status), // As per protocol, span status is allowed to be undefined\n    op,\n    origin,\n    measurements: core.timedEventsToMeasurements(span.events),\n    links: core.convertSpanLinksForEnvelope(links),\n  };\n\n  spans.push(spanJSON);\n\n  node.children.forEach(child => {\n    createAndFinishSpanForOtelSpan(child, spans, sentSpans);\n  });\n}\n\nfunction getSpanData(span)\n\n {\n  const { op: definedOp, source: definedSource, origin } = parseSpan(span);\n  const { op: inferredOp, description, source: inferredSource, data: inferredData } = parseSpanDescription(span);\n\n  const op = definedOp || inferredOp;\n  const source = definedSource || inferredSource;\n\n  const data = { ...inferredData, ...getData(span) };\n\n  return {\n    op,\n    description,\n    source,\n    origin,\n    data,\n  };\n}\n\n/**\n * Remove custom `sentry.` attributes we do not need to send.\n * These are more carrier attributes we use inside of the SDK, we do not need to send them to the API.\n */\nfunction removeSentryAttributes(data) {\n  const cleanedData = { ...data };\n\n  /* eslint-disable @typescript-eslint/no-dynamic-delete */\n  delete cleanedData[core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE];\n  delete cleanedData[SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE];\n  delete cleanedData[core.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n  /* eslint-enable @typescript-eslint/no-dynamic-delete */\n\n  return cleanedData;\n}\n\nfunction getData(span) {\n  const attributes = span.attributes;\n  const data = {};\n\n  if (span.kind !== api.SpanKind.INTERNAL) {\n    data['otel.kind'] = api.SpanKind[span.kind];\n  }\n\n  // eslint-disable-next-line deprecation/deprecation\n  const maybeHttpStatusCodeAttribute = attributes[semanticConventions.SEMATTRS_HTTP_STATUS_CODE];\n  if (maybeHttpStatusCodeAttribute) {\n    data[semanticConventions.ATTR_HTTP_RESPONSE_STATUS_CODE] = maybeHttpStatusCodeAttribute ;\n  }\n\n  const requestData = getRequestSpanData(span);\n\n  if (requestData.url) {\n    data.url = requestData.url;\n  }\n\n  if (requestData['http.query']) {\n    data['http.query'] = requestData['http.query'].slice(1);\n  }\n  if (requestData['http.fragment']) {\n    data['http.fragment'] = requestData['http.fragment'].slice(1);\n  }\n\n  return data;\n}\n\nfunction onSpanStart(span, parentContext) {\n  // This is a reliable way to get the parent span - because this is exactly how the parent is identified in the OTEL SDK\n  const parentSpan = api.trace.getSpan(parentContext);\n\n  let scopes = getScopesFromContext(parentContext);\n\n  // We need access to the parent span in order to be able to move up the span tree for breadcrumbs\n  if (parentSpan && !parentSpan.spanContext().isRemote) {\n    core.addChildSpanToSpan(parentSpan, span);\n  }\n\n  // We need this in the span exporter\n  if (parentSpan?.spanContext().isRemote) {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE, true);\n  }\n\n  // The root context does not have scopes stored, so we check for this specifically\n  // As fallback we attach the global scopes\n  if (parentContext === api.ROOT_CONTEXT) {\n    scopes = {\n      scope: core.getDefaultCurrentScope(),\n      isolationScope: core.getDefaultIsolationScope(),\n    };\n  }\n\n  // We need the scope at time of span creation in order to apply it to the event when the span is finished\n  if (scopes) {\n    core.setCapturedScopesOnSpan(span, scopes.scope, scopes.isolationScope);\n  }\n\n  core.logSpanStart(span);\n\n  const client = core.getClient();\n  client?.emit('spanStart', span);\n}\n\nfunction onSpanEnd(span) {\n  core.logSpanEnd(span);\n\n  const client = core.getClient();\n  client?.emit('spanEnd', span);\n}\n\n/**\n * Converts OpenTelemetry Spans to Sentry Spans and sends them to Sentry via\n * the Sentry SDK.\n */\nclass SentrySpanProcessor  {\n\n   constructor(options) {\n    setIsSetup('SentrySpanProcessor');\n    this._exporter = new SentrySpanExporter(options);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   async forceFlush() {\n    this._exporter.flush();\n  }\n\n  /**\n   * @inheritDoc\n   */\n   async shutdown() {\n    this._exporter.clear();\n  }\n\n  /**\n   * @inheritDoc\n   */\n   onStart(span, parentContext) {\n    onSpanStart(span, parentContext);\n  }\n\n  /** @inheritDoc */\n   onEnd(span) {\n    onSpanEnd(span);\n\n    this._exporter.export(span);\n  }\n}\n\n/**\n * A custom OTEL sampler that uses Sentry sampling rates to make its decision\n */\nclass SentrySampler  {\n\n   constructor(client) {\n    this._client = client;\n    setIsSetup('SentrySampler');\n  }\n\n  /** @inheritDoc */\n   shouldSample(\n    context,\n    traceId,\n    spanName,\n    spanKind,\n    spanAttributes,\n    _links,\n  ) {\n    const options = this._client.getOptions();\n\n    const parentSpan = getValidSpan(context);\n    const parentContext = parentSpan?.spanContext();\n\n    if (!core.hasSpansEnabled(options)) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    // `ATTR_HTTP_REQUEST_METHOD` is the new attribute, but we still support the old one, `SEMATTRS_HTTP_METHOD`, for now.\n    // eslint-disable-next-line deprecation/deprecation\n    const maybeSpanHttpMethod = spanAttributes[semanticConventions.SEMATTRS_HTTP_METHOD] || spanAttributes[semanticConventions.ATTR_HTTP_REQUEST_METHOD];\n\n    // If we have a http.client span that has no local parent, we never want to sample it\n    // but we want to leave downstream sampling decisions up to the server\n    if (spanKind === api.SpanKind.CLIENT && maybeSpanHttpMethod && (!parentSpan || parentContext?.isRemote)) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    const parentSampled = parentSpan ? getParentSampled(parentSpan, traceId, spanName) : undefined;\n    const isRootSpan = !parentSpan || parentContext?.isRemote;\n\n    // We only sample based on parameters (like tracesSampleRate or tracesSampler) for root spans (which is done in sampleSpan).\n    // Non-root-spans simply inherit the sampling decision from their parent.\n    if (!isRootSpan) {\n      return wrapSamplingDecision({\n        decision: parentSampled ? sdkTraceBase.SamplingDecision.RECORD_AND_SAMPLED : sdkTraceBase.SamplingDecision.NOT_RECORD,\n        context,\n        spanAttributes,\n      });\n    }\n\n    // We want to pass the inferred name & attributes to the sampler method\n    const {\n      description: inferredSpanName,\n      data: inferredAttributes,\n      op,\n    } = inferSpanData(spanName, spanAttributes, spanKind);\n\n    const mergedAttributes = {\n      ...inferredAttributes,\n      ...spanAttributes,\n    };\n\n    if (op) {\n      mergedAttributes[core.SEMANTIC_ATTRIBUTE_SENTRY_OP] = op;\n    }\n\n    const mutableSamplingDecision = { decision: true };\n    this._client.emit(\n      'beforeSampling',\n      {\n        spanAttributes: mergedAttributes,\n        spanName: inferredSpanName,\n        parentSampled: parentSampled,\n        parentContext: parentContext,\n      },\n      mutableSamplingDecision,\n    );\n    if (!mutableSamplingDecision.decision) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    const { isolationScope } = getScopesFromContext(context) ?? {};\n\n    const dscString = parentContext?.traceState ? parentContext.traceState.get(SENTRY_TRACE_STATE_DSC) : undefined;\n    const dsc = dscString ? core.baggageHeaderToDynamicSamplingContext(dscString) : undefined;\n\n    const sampleRand = core.parseSampleRate(dsc?.sample_rand) ?? Math.random();\n\n    const [sampled, sampleRate, localSampleRateWasApplied] = core.sampleSpan(\n      options,\n      {\n        name: inferredSpanName,\n        attributes: mergedAttributes,\n        normalizedRequest: isolationScope?.getScopeData().sdkProcessingMetadata.normalizedRequest,\n        parentSampled,\n        parentSampleRate: core.parseSampleRate(dsc?.sample_rate),\n      },\n      sampleRand,\n    );\n\n    const method = `${maybeSpanHttpMethod}`.toUpperCase();\n    if (method === 'OPTIONS' || method === 'HEAD') {\n      DEBUG_BUILD && core.debug.log(`[Tracing] Not sampling span because HTTP method is '${method}' for ${spanName}`);\n\n      return wrapSamplingDecision({\n        decision: sdkTraceBase.SamplingDecision.NOT_RECORD,\n        context,\n        spanAttributes,\n        sampleRand,\n        downstreamTraceSampleRate: 0, // we don't want to sample anything in the downstream trace either\n      });\n    }\n\n    if (\n      !sampled &&\n      // We check for `parentSampled === undefined` because we only want to record client reports for spans that are trace roots (ie. when there was incoming trace)\n      parentSampled === undefined\n    ) {\n      DEBUG_BUILD && core.debug.log('[Tracing] Discarding root span because its trace was not chosen to be sampled.');\n      this._client.recordDroppedEvent('sample_rate', 'transaction');\n    }\n\n    return {\n      ...wrapSamplingDecision({\n        decision: sampled ? sdkTraceBase.SamplingDecision.RECORD_AND_SAMPLED : sdkTraceBase.SamplingDecision.NOT_RECORD,\n        context,\n        spanAttributes,\n        sampleRand,\n        downstreamTraceSampleRate: localSampleRateWasApplied ? sampleRate : undefined,\n      }),\n      attributes: {\n        // We set the sample rate on the span when a local sample rate was applied to better understand how traces were sampled in Sentry\n        [core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: localSampleRateWasApplied ? sampleRate : undefined,\n      },\n    };\n  }\n\n  /** Returns the sampler name or short description with the configuration. */\n   toString() {\n    return 'SentrySampler';\n  }\n}\n\nfunction getParentSampled(parentSpan, traceId, spanName) {\n  const parentContext = parentSpan.spanContext();\n\n  // Only inherit sample rate if `traceId` is the same\n  // Note for testing: `isSpanContextValid()` checks the format of the traceId/spanId, so we need to pass valid ones\n  if (api.isSpanContextValid(parentContext) && parentContext.traceId === traceId) {\n    if (parentContext.isRemote) {\n      const parentSampled = getSamplingDecision(parentSpan.spanContext());\n      DEBUG_BUILD &&\n        core.debug.log(`[Tracing] Inheriting remote parent's sampled decision for ${spanName}: ${parentSampled}`);\n      return parentSampled;\n    }\n\n    const parentSampled = getSamplingDecision(parentContext);\n    DEBUG_BUILD && core.debug.log(`[Tracing] Inheriting parent's sampled decision for ${spanName}: ${parentSampled}`);\n    return parentSampled;\n  }\n\n  return undefined;\n}\n\n/**\n * Wrap a sampling decision with data that Sentry needs to work properly with it.\n * If you pass `decision: undefined`, it will be treated as `NOT_RECORDING`, but in contrast to passing `NOT_RECORDING`\n * it will not propagate this decision to downstream Sentry SDKs.\n */\nfunction wrapSamplingDecision({\n  decision,\n  context,\n  spanAttributes,\n  sampleRand,\n  downstreamTraceSampleRate,\n}\n\n) {\n  let traceState = getBaseTraceState(context, spanAttributes);\n\n  // We will override the propagated sample rate downstream when\n  // - the tracesSampleRate is applied\n  // - the tracesSampler is invoked\n  // Since unsampled OTEL spans (NonRecordingSpans) cannot hold attributes we need to store this on the (trace)context.\n  if (downstreamTraceSampleRate !== undefined) {\n    traceState = traceState.set(SENTRY_TRACE_STATE_SAMPLE_RATE, `${downstreamTraceSampleRate}`);\n  }\n\n  if (sampleRand !== undefined) {\n    traceState = traceState.set(SENTRY_TRACE_STATE_SAMPLE_RAND, `${sampleRand}`);\n  }\n\n  // If the decision is undefined, we treat it as NOT_RECORDING, but we don't propagate this decision to downstream SDKs\n  // Which is done by not setting `SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING` traceState\n  if (decision == undefined) {\n    return { decision: sdkTraceBase.SamplingDecision.NOT_RECORD, traceState };\n  }\n\n  if (decision === sdkTraceBase.SamplingDecision.NOT_RECORD) {\n    return { decision, traceState: traceState.set(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING, '1') };\n  }\n\n  return { decision, traceState };\n}\n\nfunction getBaseTraceState(context, spanAttributes) {\n  const parentSpan = api.trace.getSpan(context);\n  const parentContext = parentSpan?.spanContext();\n\n  let traceState = parentContext?.traceState || new core$1.TraceState();\n\n  // We always keep the URL on the trace state, so we can access it in the propagator\n  // `ATTR_URL_FULL` is the new attribute, but we still support the old one, `ATTR_HTTP_URL`, for now.\n  // eslint-disable-next-line deprecation/deprecation\n  const url = spanAttributes[semanticConventions.SEMATTRS_HTTP_URL] || spanAttributes[semanticConventions.ATTR_URL_FULL];\n  if (url && typeof url === 'string') {\n    traceState = traceState.set(SENTRY_TRACE_STATE_URL, url);\n  }\n\n  return traceState;\n}\n\n/**\n * If the active span is invalid, we want to ignore it as parent.\n * This aligns with how otel tracers and default samplers handle these cases.\n */\nfunction getValidSpan(context) {\n  const span = api.trace.getSpan(context);\n  return span && api.isSpanContextValid(span.spanContext()) ? span : undefined;\n}\n\nexports.getClient = core.getClient;\nexports.getDynamicSamplingContextFromSpan = core.getDynamicSamplingContextFromSpan;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION = SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION;\nexports.SentryPropagator = SentryPropagator;\nexports.SentrySampler = SentrySampler;\nexports.SentrySpanProcessor = SentrySpanProcessor;\nexports.continueTrace = continueTrace;\nexports.enhanceDscWithOpenTelemetryRootSpanName = enhanceDscWithOpenTelemetryRootSpanName;\nexports.getActiveSpan = getActiveSpan;\nexports.getRequestSpanData = getRequestSpanData;\nexports.getScopesFromContext = getScopesFromContext;\nexports.getSpanKind = getSpanKind;\nexports.getTraceContextForScope = getTraceContextForScope;\nexports.isSentryRequestSpan = isSentryRequestSpan;\nexports.openTelemetrySetupCheck = openTelemetrySetupCheck;\nexports.setOpenTelemetryContextAsyncContextStrategy = setOpenTelemetryContextAsyncContextStrategy;\nexports.setupEventContextTrace = setupEventContextTrace;\nexports.shouldPropagateTraceForUrl = shouldPropagateTraceForUrl;\nexports.spanHasAttributes = spanHasAttributes;\nexports.spanHasEvents = spanHasEvents;\nexports.spanHasKind = spanHasKind;\nexports.spanHasName = spanHasName;\nexports.spanHasParentId = spanHasParentId;\nexports.spanHasStatus = spanHasStatus;\nexports.startInactiveSpan = startInactiveSpan;\nexports.startSpan = startSpan;\nexports.startSpanManual = startSpanManual;\nexports.suppressTracing = suppressTracing;\nexports.withActiveSpan = withActiveSpan;\nexports.wrapClientClass = wrapClientClass;\nexports.wrapContextManagerClass = wrapContextManagerClass;\nexports.wrapSamplingDecision = wrapSamplingDecision;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5K29wZW50ZWxlbWV0cnlAMTAuMTcuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjBfQG9wZW50ZWxlbWV0cnkrY29udGV4dC1hc3luYy1ob29rc0AyLjFfbG5hbmp0YmVhb3JnN2NweWQ2ZDVhajdsamkvbm9kZV9tb2R1bGVzL0BzZW50cnkvb3BlbnRlbGVtZXRyeS9idWlsZC9janMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEscURBQXFELGlCQUFpQjs7QUFFdEUsNEJBQTRCLG1CQUFPLENBQUMsaU1BQXFDO0FBQ3pFLGFBQWEsbUJBQU8sQ0FBQyw2SEFBYztBQUNuQyxZQUFZLG1CQUFPLENBQUMsNklBQW9CO0FBQ3hDLGVBQWUsbUJBQU8sQ0FBQyx5S0FBcUI7QUFDNUMscUJBQXFCLG1CQUFPLENBQUMsdU1BQStCOztBQUU1RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxhQUFhOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseUJBQXlCOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msa0NBQWtDO0FBQ3hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDRCQUE0QjtBQUNoRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQ0FBa0Msa0JBQWtCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLElBQUksd0JBQXdCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsMENBQTBDOztBQUVwRDtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBLDZCQUE2QixZQUFZLEVBQUUsUUFBUTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUyxpQkFBaUIsR0FBRyxrRUFBa0U7QUFDL0Y7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFVBQVUsc0JBQXNCO0FBQ2hDLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsZ0JBQWdCLDhCQUE4QixLQUFLLGtCQUFrQjtBQUNyRTtBQUNBOztBQUVBLFlBQVksS0FBSztBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGNBQWMsNkRBQTZEO0FBQ3ZGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlGQUF5Rjs7QUFFekYsWUFBWSxtREFBbUQ7O0FBRS9EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25ELFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwrQkFBK0IsRUFBRSxPQUFPLEtBQUssaUJBQWlCO0FBQzdGO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkVBQTJFLHNCQUFzQjtBQUNqRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksc0JBQXNCO0FBQzFCO0FBQ0E7O0FBRUEsVUFBVSxzQ0FBc0M7O0FBRWhEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSx3QkFBd0I7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUscUNBQXFDOztBQUUvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQ0FBZ0M7QUFDN0Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUscUNBQXFDOztBQUUvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQ0FBZ0M7QUFDN0Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGdCQUFnQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxxQ0FBcUM7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLHlDQUF5Qzs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxrQkFBa0I7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOOztBQUVBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLG1EQUFtRCwwQkFBMEIsZUFBZTs7QUFFdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtDQUFrQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLHdCQUF3QjtBQUMxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxvQ0FBb0M7QUFDakY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsa0JBQWtCO0FBQ3pEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQixRQUFRO0FBQ1IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLElBQUk7QUFDSixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxjQUFjO0FBQ25GOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0JBQWtCLGdEQUFnRCw4QkFBOEI7QUFDcEk7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxlQUFlLFNBQVMsd0JBQXdCO0FBQ2pGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxVQUFVLG1EQUFtRDtBQUM3RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsUUFBUTtBQUNsQixVQUFVLHFDQUFxQzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkRBQTZELFlBQVksNEJBQTRCOztBQUVyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLHdDQUF3Qzs7QUFFbEQsVUFBVSwyQ0FBMkM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0EsVUFBVSwrQ0FBK0M7QUFDekQsVUFBVSwwRUFBMEU7O0FBRXBGO0FBQ0E7O0FBRUEsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyw4Q0FBOEM7QUFDbEY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw4Q0FBOEM7QUFDbEY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw4Q0FBOEM7QUFDbEY7O0FBRUEsWUFBWSxpQkFBaUI7O0FBRTdCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQSwyRkFBMkYsT0FBTyxRQUFRLFNBQVM7O0FBRW5IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsU0FBUyxJQUFJLGNBQWM7QUFDL0c7QUFDQTs7QUFFQTtBQUNBLHdGQUF3RixTQUFTLElBQUksY0FBYztBQUNuSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSwwQkFBMEI7QUFDN0Y7O0FBRUE7QUFDQSxtRUFBbUUsV0FBVztBQUM5RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUEsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCLHlDQUF5QztBQUN6QyxtREFBbUQ7QUFDbkQsd0JBQXdCO0FBQ3hCLHFCQUFxQjtBQUNyQiwyQkFBMkI7QUFDM0IscUJBQXFCO0FBQ3JCLCtDQUErQztBQUMvQyxxQkFBcUI7QUFDckIsMEJBQTBCO0FBQzFCLDRCQUE0QjtBQUM1QixtQkFBbUI7QUFDbkIsK0JBQStCO0FBQy9CLDJCQUEyQjtBQUMzQiwrQkFBK0I7QUFDL0IsbURBQW1EO0FBQ25ELDhCQUE4QjtBQUM5QixrQ0FBa0M7QUFDbEMseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLHVCQUF1QjtBQUN2QixxQkFBcUI7QUFDckIseUJBQXlCO0FBQ3pCLGlCQUFpQjtBQUNqQix1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkIsK0JBQStCO0FBQy9CLDRCQUE0QjtBQUM1QiIsInNvdXJjZXMiOlsiL1VzZXJzL2NvZHlkZWFya2xhbmQvc2VudHJ5dmliZS9ub2RlX21vZHVsZXMvLnBucG0vQHNlbnRyeStvcGVudGVsZW1ldHJ5QDEwLjE3LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wX0BvcGVudGVsZW1ldHJ5K2NvbnRleHQtYXN5bmMtaG9va3NAMi4xX2xuYW5qdGJlYW9yZzdjcHlkNmQ1YWo3bGppL25vZGVfbW9kdWxlcy9Ac2VudHJ5L29wZW50ZWxlbWV0cnkvYnVpbGQvY2pzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG5jb25zdCBzZW1hbnRpY0NvbnZlbnRpb25zID0gcmVxdWlyZSgnQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnMnKTtcbmNvbnN0IGNvcmUgPSByZXF1aXJlKCdAc2VudHJ5L2NvcmUnKTtcbmNvbnN0IGFwaSA9IHJlcXVpcmUoJ0BvcGVudGVsZW1ldHJ5L2FwaScpO1xuY29uc3QgY29yZSQxID0gcmVxdWlyZSgnQG9wZW50ZWxlbWV0cnkvY29yZScpO1xuY29uc3Qgc2RrVHJhY2VCYXNlID0gcmVxdWlyZSgnQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UnKTtcblxuLyoqIElmIHRoaXMgYXR0cmlidXRlIGlzIHRydWUsIGl0IG1lYW5zIHRoYXQgdGhlIHBhcmVudCBpcyBhIHJlbW90ZSBzcGFuLiAqL1xuY29uc3QgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9QQVJFTlRfSVNfUkVNT1RFID0gJ3NlbnRyeS5wYXJlbnRJc1JlbW90ZSc7XG5cbi8vIFRoZXNlIGFyZSBub3Qgc3RhbmRhcmRpemVkIHlldCwgYnV0IHVzZWQgYnkgdGhlIGdyYXBocWwgaW5zdHJ1bWVudGF0aW9uXG5jb25zdCBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX0dSQVBIUUxfT1BFUkFUSU9OID0gJ3NlbnRyeS5ncmFwaHFsLm9wZXJhdGlvbic7XG5cbi8qKlxuICogR2V0IHRoZSBwYXJlbnQgc3BhbiBpZCBmcm9tIGEgc3Bhbi5cbiAqIEluIE9UZWwgdjEsIHRoZSBwYXJlbnQgc3BhbiBpZCBpcyBhY2Nlc3NlZCBhcyBgcGFyZW50U3BhbklkYFxuICogSW4gT1RlbCB2MiwgdGhlIHBhcmVudCBzcGFuIGlkIGlzIGFjY2Vzc2VkIGFzIGBzcGFuSWRgIG9uIHRoZSBgcGFyZW50U3BhbkNvbnRleHRgXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudFNwYW5JZChzcGFuKSB7XG4gIGlmICgncGFyZW50U3BhbklkJyBpbiBzcGFuKSB7XG4gICAgcmV0dXJuIHNwYW4ucGFyZW50U3BhbklkIDtcbiAgfSBlbHNlIGlmICgncGFyZW50U3BhbkNvbnRleHQnIGluIHNwYW4pIHtcbiAgICByZXR1cm4gKHNwYW4ucGFyZW50U3BhbkNvbnRleHQgKT8uc3BhbklkO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGdpdmVuIHNwYW4gaGFzIGF0dHJpYnV0ZXMuXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBiYXNlIGBTcGFuYCB0eXBlIGRvZXMgbm90IGhhdmUgYXR0cmlidXRlcyxcbiAqIHNvIGluIHBsYWNlcyB3aGVyZSB3ZSBhcmUgcGFzc2VkIGEgZ2VuZXJpYyBzcGFuLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIHdhbnQgdG8gYWNjZXNzIHRoZW0uXG4gKi9cbmZ1bmN0aW9uIHNwYW5IYXNBdHRyaWJ1dGVzKFxuICBzcGFuLFxuKSB7XG4gIGNvbnN0IGNhc3RTcGFuID0gc3BhbiA7XG4gIHJldHVybiAhIWNhc3RTcGFuLmF0dHJpYnV0ZXMgJiYgdHlwZW9mIGNhc3RTcGFuLmF0dHJpYnV0ZXMgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgZ2l2ZW4gc3BhbiBoYXMgYSBraW5kLlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB0aGUgYmFzZSBgU3BhbmAgdHlwZSBkb2VzIG5vdCBoYXZlIGEga2luZCxcbiAqIHNvIGluIHBsYWNlcyB3aGVyZSB3ZSBhcmUgcGFzc2VkIGEgZ2VuZXJpYyBzcGFuLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIHdhbnQgdG8gYWNjZXNzIGl0LlxuICovXG5mdW5jdGlvbiBzcGFuSGFzS2luZChzcGFuKSB7XG4gIGNvbnN0IGNhc3RTcGFuID0gc3BhbiA7XG4gIHJldHVybiB0eXBlb2YgY2FzdFNwYW4ua2luZCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBnaXZlbiBzcGFuIGhhcyBhIHN0YXR1cy5cbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdGhlIGJhc2UgYFNwYW5gIHR5cGUgZG9lcyBub3QgaGF2ZSBhIHN0YXR1cyxcbiAqIHNvIGluIHBsYWNlcyB3aGVyZSB3ZSBhcmUgcGFzc2VkIGEgZ2VuZXJpYyBzcGFuLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIHdhbnQgdG8gYWNjZXNzIGl0LlxuICovXG5mdW5jdGlvbiBzcGFuSGFzU3RhdHVzKFxuICBzcGFuLFxuKSB7XG4gIGNvbnN0IGNhc3RTcGFuID0gc3BhbiA7XG4gIHJldHVybiAhIWNhc3RTcGFuLnN0YXR1cztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGdpdmVuIHNwYW4gaGFzIGEgbmFtZS5cbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdGhlIGJhc2UgYFNwYW5gIHR5cGUgZG9lcyBub3QgaGF2ZSBhIG5hbWUsXG4gKiBzbyBpbiBwbGFjZXMgd2hlcmUgd2UgYXJlIHBhc3NlZCBhIGdlbmVyaWMgc3Bhbiwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSB3YW50IHRvIGFjY2VzcyBpdC5cbiAqL1xuZnVuY3Rpb24gc3Bhbkhhc05hbWUoc3Bhbikge1xuICBjb25zdCBjYXN0U3BhbiA9IHNwYW4gO1xuICByZXR1cm4gISFjYXN0U3Bhbi5uYW1lO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgZ2l2ZW4gc3BhbiBoYXMgYSBraW5kLlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB0aGUgYmFzZSBgU3BhbmAgdHlwZSBkb2VzIG5vdCBoYXZlIGEga2luZCxcbiAqIHNvIGluIHBsYWNlcyB3aGVyZSB3ZSBhcmUgcGFzc2VkIGEgZ2VuZXJpYyBzcGFuLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIHdhbnQgdG8gYWNjZXNzIGl0LlxuICovXG5mdW5jdGlvbiBzcGFuSGFzUGFyZW50SWQoXG4gIHNwYW4sXG4pIHtcbiAgY29uc3QgY2FzdFNwYW4gPSBzcGFuIDtcbiAgcmV0dXJuICEhZ2V0UGFyZW50U3BhbklkKGNhc3RTcGFuKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGdpdmVuIHNwYW4gaGFzIGV2ZW50cy5cbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdGhlIGJhc2UgYFNwYW5gIHR5cGUgZG9lcyBub3QgaGF2ZSBldmVudHMsXG4gKiBzbyBpbiBwbGFjZXMgd2hlcmUgd2UgYXJlIHBhc3NlZCBhIGdlbmVyaWMgc3Bhbiwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSB3YW50IHRvIGFjY2VzcyBpdC5cbiAqL1xuZnVuY3Rpb24gc3Bhbkhhc0V2ZW50cyhcbiAgc3Bhbixcbikge1xuICBjb25zdCBjYXN0U3BhbiA9IHNwYW4gO1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShjYXN0U3Bhbi5ldmVudHMpO1xufVxuXG4vKipcbiAqIEdldCBzYW5pdGl6aWVkIHJlcXVlc3QgZGF0YSBmcm9tIGFuIE9URUwgc3Bhbi5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVxdWVzdFNwYW5EYXRhKHNwYW4pIHtcbiAgLy8gVGhlIGJhc2UgYFNwYW5gIHR5cGUgaGFzIG5vIGBhdHRyaWJ1dGVzYCwgc28gd2UgbmVlZCB0byBndWFyZCBoZXJlIGFnYWluc3QgdGhhdFxuICBpZiAoIXNwYW5IYXNBdHRyaWJ1dGVzKHNwYW4pKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIGNvbnN0IG1heWJlVXJsQXR0cmlidXRlID0gKHNwYW4uYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLkFUVFJfVVJMX0ZVTExdIHx8IHNwYW4uYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfVVJMXSlcblxuO1xuXG4gIGNvbnN0IGRhdGEgPSB7XG4gICAgdXJsOiBtYXliZVVybEF0dHJpYnV0ZSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICAnaHR0cC5tZXRob2QnOiAoc3Bhbi5hdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuQVRUUl9IVFRQX1JFUVVFU1RfTUVUSE9EXSB8fCBzcGFuLmF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19IVFRQX01FVEhPRF0pXG5cbixcbiAgfTtcblxuICAvLyBEZWZhdWx0IHRvIEdFVCBpZiBVUkwgaXMgc2V0IGJ1dCBtZXRob2QgaXMgbm90XG4gIGlmICghZGF0YVsnaHR0cC5tZXRob2QnXSAmJiBkYXRhLnVybCkge1xuICAgIGRhdGFbJ2h0dHAubWV0aG9kJ10gPSAnR0VUJztcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBtYXliZVVybEF0dHJpYnV0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IHVybCA9IGNvcmUucGFyc2VVcmwobWF5YmVVcmxBdHRyaWJ1dGUpO1xuXG4gICAgICBkYXRhLnVybCA9IGNvcmUuZ2V0U2FuaXRpemVkVXJsU3RyaW5nKHVybCk7XG5cbiAgICAgIGlmICh1cmwuc2VhcmNoKSB7XG4gICAgICAgIGRhdGFbJ2h0dHAucXVlcnknXSA9IHVybC5zZWFyY2g7XG4gICAgICB9XG4gICAgICBpZiAodXJsLmhhc2gpIHtcbiAgICAgICAgZGF0YVsnaHR0cC5mcmFnbWVudCddID0gdXJsLmhhc2g7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIHtcbiAgICAvLyBpZ25vcmVcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vLyBUeXBlc2NyaXB0IGNvbXBsYWlucyBpZiB3ZSBkbyBub3QgdXNlIGAuLi5hcmdzOiBhbnlbXWAgZm9yIHRoZSBtaXhpbiwgd2l0aDpcbi8vIEEgbWl4aW4gY2xhc3MgbXVzdCBoYXZlIGEgY29uc3RydWN0b3Igd2l0aCBhIHNpbmdsZSByZXN0IHBhcmFtZXRlciBvZiB0eXBlICdhbnlbXScudHMoMjU0NSlcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cblxuLyoqXG4gKiBXcmFwIGFuIENsaWVudCBjbGFzcyB3aXRoIHRoaW5ncyB3ZSBuZWVkIGZvciBPcGVuVGVsZW1ldHJ5IHN1cHBvcnQuXG4gKiBNYWtlIHN1cmUgdGhhdCB0aGUgQ2xpZW50IGNsYXNzIHBhc3NlZCBpbiBpcyBub24tYWJzdHJhY3QhXG4gKlxuICogVXNhZ2U6XG4gKiBjb25zdCBPcGVuVGVsZW1ldHJ5Q2xpZW50ID0gZ2V0V3JhcHBlZENsaWVudENsYXNzKE5vZGVDbGllbnQpO1xuICogY29uc3QgY2xpZW50ID0gbmV3IE9wZW5UZWxlbWV0cnlDbGllbnQob3B0aW9ucyk7XG4gKi9cbmZ1bmN0aW9uIHdyYXBDbGllbnRDbGFzc1xuXG4oQ2xpZW50Q2xhc3MpIHtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBXZSBqdXN0IGFzc3VtZSB0aGF0IHRoaXMgaXMgbm9uLWFic3RyYWN0LCBpZiB5b3UgcGFzcyBpbiBhbiBhYnN0cmFjdCBjbGFzcyB0aGlzIHdvdWxkIG1ha2UgaXQgbm9uLWFic3RyYWN0XG4gIGNsYXNzIE9wZW5UZWxlbWV0cnlDbGllbnQgZXh0ZW5kcyBDbGllbnRDbGFzcyAge1xuXG4gICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIH1cblxuICAgIC8qKiBHZXQgdGhlIE9URUwgdHJhY2VyLiAqL1xuICAgICBnZXQgdHJhY2VyKCkge1xuICAgICAgaWYgKHRoaXMuX3RyYWNlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2VyO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuYW1lID0gJ0BzZW50cnkvb3BlbnRlbGVtZXRyeSc7XG4gICAgICBjb25zdCB2ZXJzaW9uID0gY29yZS5TREtfVkVSU0lPTjtcbiAgICAgIGNvbnN0IHRyYWNlciA9IGFwaS50cmFjZS5nZXRUcmFjZXIobmFtZSwgdmVyc2lvbik7XG4gICAgICB0aGlzLl90cmFjZXIgPSB0cmFjZXI7XG5cbiAgICAgIHJldHVybiB0cmFjZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICAgYXN5bmMgZmx1c2godGltZW91dCkge1xuICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLnRyYWNlUHJvdmlkZXI7XG4gICAgICBhd2FpdCBwcm92aWRlcj8uZm9yY2VGbHVzaCgpO1xuICAgICAgcmV0dXJuIHN1cGVyLmZsdXNoKHRpbWVvdXQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBPcGVuVGVsZW1ldHJ5Q2xpZW50IDtcbn1cbi8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuXG4vKipcbiAqIEdldCB0aGUgc3BhbiBraW5kIGZyb20gYSBzcGFuLlxuICogRm9yIHdoYXRldmVyIHJlYXNvbiwgdGhpcyBpcyBub3QgcHVibGljIEFQSSBvbiB0aGUgZ2VuZXJpYyBcIlNwYW5cIiB0eXBlLFxuICogc28gd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBhY3R1YWxseSBoYXZlIGEgYFNES1RyYWNlQmFzZVNwYW5gIHdoZXJlIHdlIGNhbiBmZXRjaCB0aGlzIGZyb20uXG4gKiBPdGhlcndpc2UsIHdlIGZhbGwgYmFjayB0byBgU3BhbktpbmQuSU5URVJOQUxgLlxuICovXG5mdW5jdGlvbiBnZXRTcGFuS2luZChzcGFuKSB7XG4gIGlmIChzcGFuSGFzS2luZChzcGFuKSkge1xuICAgIHJldHVybiBzcGFuLmtpbmQ7XG4gIH1cblxuICByZXR1cm4gYXBpLlNwYW5LaW5kLklOVEVSTkFMO1xufVxuXG5jb25zdCBTRU5UUllfVFJBQ0VfSEVBREVSID0gJ3NlbnRyeS10cmFjZSc7XG5jb25zdCBTRU5UUllfQkFHR0FHRV9IRUFERVIgPSAnYmFnZ2FnZSc7XG5cbmNvbnN0IFNFTlRSWV9UUkFDRV9TVEFURV9EU0MgPSAnc2VudHJ5LmRzYyc7XG5jb25zdCBTRU5UUllfVFJBQ0VfU1RBVEVfU0FNUExFRF9OT1RfUkVDT1JESU5HID0gJ3NlbnRyeS5zYW1wbGVkX25vdF9yZWNvcmRpbmcnO1xuY29uc3QgU0VOVFJZX1RSQUNFX1NUQVRFX1VSTCA9ICdzZW50cnkudXJsJztcbmNvbnN0IFNFTlRSWV9UUkFDRV9TVEFURV9TQU1QTEVfUkFORCA9ICdzZW50cnkuc2FtcGxlX3JhbmQnO1xuY29uc3QgU0VOVFJZX1RSQUNFX1NUQVRFX1NBTVBMRV9SQVRFID0gJ3NlbnRyeS5zYW1wbGVfcmF0ZSc7XG5cbmNvbnN0IFNFTlRSWV9TQ09QRVNfQ09OVEVYVF9LRVkgPSBhcGkuY3JlYXRlQ29udGV4dEtleSgnc2VudHJ5X3Njb3BlcycpO1xuXG5jb25zdCBTRU5UUllfRk9SS19JU09MQVRJT05fU0NPUEVfQ09OVEVYVF9LRVkgPSBhcGkuY3JlYXRlQ29udGV4dEtleSgnc2VudHJ5X2ZvcmtfaXNvbGF0aW9uX3Njb3BlJyk7XG5cbmNvbnN0IFNFTlRSWV9GT1JLX1NFVF9TQ09QRV9DT05URVhUX0tFWSA9IGFwaS5jcmVhdGVDb250ZXh0S2V5KCdzZW50cnlfZm9ya19zZXRfc2NvcGUnKTtcblxuY29uc3QgU0VOVFJZX0ZPUktfU0VUX0lTT0xBVElPTl9TQ09QRV9DT05URVhUX0tFWSA9IGFwaS5jcmVhdGVDb250ZXh0S2V5KCdzZW50cnlfZm9ya19zZXRfaXNvbGF0aW9uX3Njb3BlJyk7XG5cbmNvbnN0IFNDT1BFX0NPTlRFWFRfRklFTEQgPSAnX3Njb3BlQ29udGV4dCc7XG5cbi8qKlxuICogVHJ5IHRvIGdldCB0aGUgY3VycmVudCBzY29wZXMgZnJvbSB0aGUgZ2l2ZW4gT1RFTCBjb250ZXh0LlxuICogVGhpcyByZXF1aXJlcyBhIENvbnRleHQgTWFuYWdlciB0aGF0IHdhcyB3cmFwcGVkIHdpdGggZ2V0V3JhcHBlZENvbnRleHRNYW5hZ2VyLlxuICovXG5mdW5jdGlvbiBnZXRTY29wZXNGcm9tQ29udGV4dChjb250ZXh0KSB7XG4gIHJldHVybiBjb250ZXh0LmdldFZhbHVlKFNFTlRSWV9TQ09QRVNfQ09OVEVYVF9LRVkpIDtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGN1cnJlbnQgc2NvcGVzIG9uIGFuIE9URUwgY29udGV4dC5cbiAqIFRoaXMgd2lsbCByZXR1cm4gYSBmb3JrZWQgY29udGV4dCB3aXRoIHRoZSBQcm9wYWdhdGlvbiBDb250ZXh0IHNldC5cbiAqL1xuZnVuY3Rpb24gc2V0U2NvcGVzT25Db250ZXh0KGNvbnRleHQsIHNjb3Blcykge1xuICByZXR1cm4gY29udGV4dC5zZXRWYWx1ZShTRU5UUllfU0NPUEVTX0NPTlRFWFRfS0VZLCBzY29wZXMpO1xufVxuXG4vKipcbiAqIFNldCB0aGUgY29udGV4dCBvbiB0aGUgc2NvcGUgc28gd2UgY2FuIGxhdGVyIGxvb2sgaXQgdXAuXG4gKiBXZSBuZWVkIHRoaXMgdG8gZ2V0IHRoZSBjb250ZXh0IGZyb20gdGhlIHNjb3BlIGluIHRoZSBgdHJhY2VgIGZ1bmN0aW9ucy5cbiAqL1xuZnVuY3Rpb24gc2V0Q29udGV4dE9uU2NvcGUoc2NvcGUsIGNvbnRleHQpIHtcbiAgY29yZS5hZGROb25FbnVtZXJhYmxlUHJvcGVydHkoc2NvcGUsIFNDT1BFX0NPTlRFWFRfRklFTEQsIGNvbnRleHQpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgY29udGV4dCByZWxhdGVkIHRvIGEgc2NvcGUuXG4gKi9cbmZ1bmN0aW9uIGdldENvbnRleHRGcm9tU2NvcGUoc2NvcGUpIHtcbiAgcmV0dXJuIChzY29wZSApW1NDT1BFX0NPTlRFWFRfRklFTERdO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gb3RlbFNwYW4gQ2hlY2tzIHdoZXRoZXIgYSBnaXZlbiBPVEVMIFNwYW4gaXMgYW4gaHR0cCByZXF1ZXN0IHRvIHNlbnRyeS5cbiAqIEByZXR1cm5zIGJvb2xlYW5cbiAqL1xuZnVuY3Rpb24gaXNTZW50cnlSZXF1ZXN0U3BhbihzcGFuKSB7XG4gIGlmICghc3Bhbkhhc0F0dHJpYnV0ZXMoc3BhbikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCB7IGF0dHJpYnV0ZXMgfSA9IHNwYW47XG5cbiAgLy8gYEFUVFJfVVJMX0ZVTExgIGlzIHRoZSBuZXcgYXR0cmlidXRlLCBidXQgd2Ugc3RpbGwgc3VwcG9ydCB0aGUgb2xkIG9uZSwgYEFUVFJfSFRUUF9VUkxgLCBmb3Igbm93LlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgY29uc3QgaHR0cFVybCA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19IVFRQX1VSTF0gfHwgYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLkFUVFJfVVJMX0ZVTExdO1xuXG4gIGlmICghaHR0cFVybCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBjb3JlLmlzU2VudHJ5UmVxdWVzdFVybChodHRwVXJsLnRvU3RyaW5nKCksIGNvcmUuZ2V0Q2xpZW50KCkpO1xufVxuXG4vKipcbiAqIE9wZW5UZWxlbWV0cnkgb25seSBrbm93cyBhYm91dCBTQU1QTEVEIG9yIE5PTkUgZGVjaXNpb24sXG4gKiBidXQgZm9yIHVzIGl0IGlzIGltcG9ydGFudCB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gdW5zZXQgYW5kIHVuc2FtcGxlZC5cbiAqXG4gKiBCb3RoIG9mIHRoZXNlIGFyZSBpZGVudGlmaWVkIGFzIGB0cmFjZUZsYWdzID09PSBUcmFjZWdGbGFncy5OT05FYCxcbiAqIGJ1dCB3ZSBhZGRpdGlvbmFsbHkgbG9vayBhdCBhIHNwZWNpYWwgdHJhY2Ugc3RhdGUgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHRoZW0uXG4gKi9cbmZ1bmN0aW9uIGdldFNhbXBsaW5nRGVjaXNpb24oc3BhbkNvbnRleHQpIHtcbiAgY29uc3QgeyB0cmFjZUZsYWdzLCB0cmFjZVN0YXRlIH0gPSBzcGFuQ29udGV4dDtcblxuICBjb25zdCBzYW1wbGVkTm90UmVjb3JkaW5nID0gdHJhY2VTdGF0ZSA/IHRyYWNlU3RhdGUuZ2V0KFNFTlRSWV9UUkFDRV9TVEFURV9TQU1QTEVEX05PVF9SRUNPUkRJTkcpID09PSAnMScgOiBmYWxzZTtcblxuICAvLyBJZiB0cmFjZSBmbGFnIGlzIGBTQU1QTEVEYCwgd2UgaW50ZXJwcmV0IHRoaXMgYXMgc2FtcGxlZFxuICAvLyBJZiBpdCBpcyBgTk9ORWAsIGl0IGNvdWxkIG1lYW4gZWl0aGVyIGl0IHdhcyBzYW1wbGVkIHRvIGJlIG5vdCByZWNvcmRlciwgb3IgdGhhdCBpdCB3YXMgbm90IHNhbXBsZWQgYXQgYWxsXG4gIC8vIEZvciB1cyB0aGlzIGlzIGFuIGltcG9ydGFudCBkaWZmZXJlbmNlLCBzb3cgZSBsb29rIGF0IHRoZSBTRU5UUllfVFJBQ0VfU1RBVEVfU0FNUExFRF9OT1RfUkVDT1JESU5HXG4gIC8vIHRvIGlkZW50aWZ5IHdoaWNoIGl0IGlzXG4gIGlmICh0cmFjZUZsYWdzID09PSBhcGkuVHJhY2VGbGFncy5TQU1QTEVEKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoc2FtcGxlZE5vdFJlY29yZGluZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEZhbGwgYmFjayB0byBEU0MgYXMgYSBsYXN0IHJlc29ydCwgdGhhdCBtYXkgYWxzbyBjb250YWluIGBzYW1wbGVkYC4uLlxuICBjb25zdCBkc2NTdHJpbmcgPSB0cmFjZVN0YXRlID8gdHJhY2VTdGF0ZS5nZXQoU0VOVFJZX1RSQUNFX1NUQVRFX0RTQykgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IGRzYyA9IGRzY1N0cmluZyA/IGNvcmUuYmFnZ2FnZUhlYWRlclRvRHluYW1pY1NhbXBsaW5nQ29udGV4dChkc2NTdHJpbmcpIDogdW5kZWZpbmVkO1xuXG4gIGlmIChkc2M/LnNhbXBsZWQgPT09ICd0cnVlJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChkc2M/LnNhbXBsZWQgPT09ICdmYWxzZScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEluZmVyIHRoZSBvcCAmIGRlc2NyaXB0aW9uIGZvciBhIHNldCBvZiBuYW1lLCBhdHRyaWJ1dGVzIGFuZCBraW5kIG9mIGEgc3Bhbi5cbiAqL1xuZnVuY3Rpb24gaW5mZXJTcGFuRGF0YShzcGFuTmFtZSwgYXR0cmlidXRlcywga2luZCkge1xuICAvLyBpZiBodHRwLm1ldGhvZCBleGlzdHMsIHRoaXMgaXMgYW4gaHR0cCByZXF1ZXN0IHNwYW5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIGNvbnN0IGh0dHBNZXRob2QgPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuQVRUUl9IVFRQX1JFUVVFU1RfTUVUSE9EXSB8fCBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9NRVRIT0RdO1xuICBpZiAoaHR0cE1ldGhvZCkge1xuICAgIHJldHVybiBkZXNjcmlwdGlvbkZvckh0dHBNZXRob2QoeyBhdHRyaWJ1dGVzLCBuYW1lOiBzcGFuTmFtZSwga2luZCB9LCBodHRwTWV0aG9kKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBjb25zdCBkYlN5c3RlbSA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19EQl9TWVNURU1dO1xuICBjb25zdCBvcElzQ2FjaGUgPVxuICAgIHR5cGVvZiBhdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUF0gPT09ICdzdHJpbmcnICYmXG4gICAgYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1BdLnN0YXJ0c1dpdGgoJ2NhY2hlLicpO1xuXG4gIC8vIElmIGRiLnR5cGUgZXhpc3RzIHRoZW4gdGhpcyBpcyBhIGRhdGFiYXNlIGNhbGwgc3BhblxuICAvLyBJZiB0aGUgUmVkaXMgREIgaXMgdXNlZCBhcyBhIGNhY2hlLCB0aGUgc3BhbiBkZXNjcmlwdGlvbiBzaG91bGQgbm90IGJlIGNoYW5nZWRcbiAgaWYgKGRiU3lzdGVtICYmICFvcElzQ2FjaGUpIHtcbiAgICByZXR1cm4gZGVzY3JpcHRpb25Gb3JEYlN5c3RlbSh7IGF0dHJpYnV0ZXMsIG5hbWU6IHNwYW5OYW1lIH0pO1xuICB9XG5cbiAgY29uc3QgY3VzdG9tU291cmNlT3JSb3V0ZSA9IGF0dHJpYnV0ZXNbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRV0gPT09ICdjdXN0b20nID8gJ2N1c3RvbScgOiAncm91dGUnO1xuXG4gIC8vIElmIHJwYy5zZXJ2aWNlIGV4aXN0cyB0aGVuIHRoaXMgaXMgYSBycGMgY2FsbCBzcGFuLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgY29uc3QgcnBjU2VydmljZSA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19SUENfU0VSVklDRV07XG4gIGlmIChycGNTZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmdldFVzZXJVcGRhdGVkTmFtZUFuZFNvdXJjZShzcGFuTmFtZSwgYXR0cmlidXRlcywgJ3JvdXRlJyksXG4gICAgICBvcDogJ3JwYycsXG4gICAgfTtcbiAgfVxuXG4gIC8vIElmIG1lc3NhZ2luZy5zeXN0ZW0gZXhpc3RzIHRoZW4gdGhpcyBpcyBhIG1lc3NhZ2luZyBzeXN0ZW0gc3Bhbi5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIGNvbnN0IG1lc3NhZ2luZ1N5c3RlbSA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19NRVNTQUdJTkdfU1lTVEVNXTtcbiAgaWYgKG1lc3NhZ2luZ1N5c3RlbSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5nZXRVc2VyVXBkYXRlZE5hbWVBbmRTb3VyY2Uoc3Bhbk5hbWUsIGF0dHJpYnV0ZXMsIGN1c3RvbVNvdXJjZU9yUm91dGUpLFxuICAgICAgb3A6ICdtZXNzYWdlJyxcbiAgICB9O1xuICB9XG5cbiAgLy8gSWYgZmFhcy50cmlnZ2VyIGV4aXN0cyB0aGVuIHRoaXMgaXMgYSBmdW5jdGlvbiBhcyBhIHNlcnZpY2Ugc3Bhbi5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIGNvbnN0IGZhYXNUcmlnZ2VyID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0ZBQVNfVFJJR0dFUl07XG4gIGlmIChmYWFzVHJpZ2dlcikge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5nZXRVc2VyVXBkYXRlZE5hbWVBbmRTb3VyY2Uoc3Bhbk5hbWUsIGF0dHJpYnV0ZXMsIGN1c3RvbVNvdXJjZU9yUm91dGUpLFxuICAgICAgb3A6IGZhYXNUcmlnZ2VyLnRvU3RyaW5nKCksXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7IG9wOiB1bmRlZmluZWQsIGRlc2NyaXB0aW9uOiBzcGFuTmFtZSwgc291cmNlOiAnY3VzdG9tJyB9O1xufVxuXG4vKipcbiAqIEV4dHJhY3QgYmV0dGVyIG9wL2Rlc2NyaXB0aW9uIGZyb20gYW4gb3RlbCBzcGFuLlxuICpcbiAqIERvZXMgbm90IG92ZXJ3cml0ZSB0aGUgc3BhbiBuYW1lIGlmIHRoZSBzb3VyY2UgaXMgYWxyZWFkeSBzZXQgdG8gY3VzdG9tIHRvIGVuc3VyZVxuICogdGhhdCB1c2VyLXVwZGF0ZWQgc3BhbiBuYW1lcyBhcmUgcHJlc2VydmVkLiBJbiB0aGlzIGNhc2UsIHdlIG9ubHkgYWRqdXN0IHRoZSBvcCBidXRcbiAqIGxlYXZlIHNwYW4gZGVzY3JpcHRpb24gYW5kIHNvdXJjZSB1bmNoYW5nZWQuXG4gKlxuICogQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL29wZW4tdGVsZW1ldHJ5L29wZW50ZWxlbWV0cnktY29sbGVjdG9yLWNvbnRyaWIvYmxvYi83NDIyY2UyYTA2MzM3ZjY4YTU5YjU1MmI4YzVhMmFjMTI1ZDZiYWU1L2V4cG9ydGVyL3NlbnRyeWV4cG9ydGVyL3NlbnRyeV9leHBvcnRlci5nbyNMMzA2XG4gKi9cbmZ1bmN0aW9uIHBhcnNlU3BhbkRlc2NyaXB0aW9uKHNwYW4pIHtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHNwYW5IYXNBdHRyaWJ1dGVzKHNwYW4pID8gc3Bhbi5hdHRyaWJ1dGVzIDoge307XG4gIGNvbnN0IG5hbWUgPSBzcGFuSGFzTmFtZShzcGFuKSA/IHNwYW4ubmFtZSA6ICc8dW5rbm93bj4nO1xuICBjb25zdCBraW5kID0gZ2V0U3BhbktpbmQoc3Bhbik7XG5cbiAgcmV0dXJuIGluZmVyU3BhbkRhdGEobmFtZSwgYXR0cmlidXRlcywga2luZCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaXB0aW9uRm9yRGJTeXN0ZW0oeyBhdHRyaWJ1dGVzLCBuYW1lIH0pIHtcbiAgLy8gaWYgd2UgYWxyZWFkeSBoYXZlIGEgY3VzdG9tIG5hbWUsIHdlIGRvbid0IG92ZXJ3cml0ZSBpdCBidXQgb25seSBzZXQgdGhlIG9wXG4gIGNvbnN0IHVzZXJEZWZpbmVkTmFtZSA9IGF0dHJpYnV0ZXNbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX0NVU1RPTV9TUEFOX05BTUVdO1xuICBpZiAodHlwZW9mIHVzZXJEZWZpbmVkTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3A6ICdkYicsXG4gICAgICBkZXNjcmlwdGlvbjogdXNlckRlZmluZWROYW1lLFxuICAgICAgc291cmNlOiAoYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFXSApIHx8ICdjdXN0b20nLFxuICAgIH07XG4gIH1cblxuICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgdGhlIHNvdXJjZSBzZXQgdG8gY3VzdG9tLCB3ZSBkb24ndCBvdmVyd3JpdGUgdGhlIHNwYW4gZGVzY3JpcHRpb24gYnV0IG9ubHkgc2V0IHRoZSBvcFxuICBpZiAoYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFXSA9PT0gJ2N1c3RvbScpIHtcbiAgICByZXR1cm4geyBvcDogJ2RiJywgZGVzY3JpcHRpb246IG5hbWUsIHNvdXJjZTogJ2N1c3RvbScgfTtcbiAgfVxuXG4gIC8vIFVzZSBEQiBzdGF0ZW1lbnQgKEV4IFwiU0VMRUNUICogRlJPTSB0YWJsZVwiKSBpZiBwb3NzaWJsZSBhcyBkZXNjcmlwdGlvbi5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIGNvbnN0IHN0YXRlbWVudCA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19EQl9TVEFURU1FTlRdO1xuXG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gc3RhdGVtZW50ID8gc3RhdGVtZW50LnRvU3RyaW5nKCkgOiBuYW1lO1xuXG4gIHJldHVybiB7IG9wOiAnZGInLCBkZXNjcmlwdGlvbiwgc291cmNlOiAndGFzaycgfTtcbn1cblxuLyoqIE9ubHkgZXhwb3J0ZWQgZm9yIHRlc3RzLiAqL1xuZnVuY3Rpb24gZGVzY3JpcHRpb25Gb3JIdHRwTWV0aG9kKFxuICB7IG5hbWUsIGtpbmQsIGF0dHJpYnV0ZXMgfSxcbiAgaHR0cE1ldGhvZCxcbikge1xuICBjb25zdCBvcFBhcnRzID0gWydodHRwJ107XG5cbiAgc3dpdGNoIChraW5kKSB7XG4gICAgY2FzZSBhcGkuU3BhbktpbmQuQ0xJRU5UOlxuICAgICAgb3BQYXJ0cy5wdXNoKCdjbGllbnQnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXBpLlNwYW5LaW5kLlNFUlZFUjpcbiAgICAgIG9wUGFydHMucHVzaCgnc2VydmVyJyk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIC8vIFNwYW5zIGZvciBIVFRQIHJlcXVlc3RzIHdlIGhhdmUgZGV0ZXJtaW5lZCB0byBiZSBwcmVmZXRjaCByZXF1ZXN0cyB3aWxsIGhhdmUgYSBgLnByZWZldGNoYCBwb3N0Zml4IGluIHRoZSBvcFxuICBpZiAoYXR0cmlidXRlc1snc2VudHJ5Lmh0dHAucHJlZmV0Y2gnXSkge1xuICAgIG9wUGFydHMucHVzaCgncHJlZmV0Y2gnKTtcbiAgfVxuXG4gIGNvbnN0IHsgdXJsUGF0aCwgdXJsLCBxdWVyeSwgZnJhZ21lbnQsIGhhc1JvdXRlIH0gPSBnZXRTYW5pdGl6ZWRVcmwoYXR0cmlidXRlcywga2luZCk7XG5cbiAgaWYgKCF1cmxQYXRoKSB7XG4gICAgcmV0dXJuIHsgLi4uZ2V0VXNlclVwZGF0ZWROYW1lQW5kU291cmNlKG5hbWUsIGF0dHJpYnV0ZXMpLCBvcDogb3BQYXJ0cy5qb2luKCcuJykgfTtcbiAgfVxuXG4gIGNvbnN0IGdyYXBocWxPcGVyYXRpb25zQXR0cmlidXRlID0gYXR0cmlidXRlc1tTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX0dSQVBIUUxfT1BFUkFUSU9OXTtcblxuICAvLyBFeC4gR0VUIC9hcGkvdXNlcnNcbiAgY29uc3QgYmFzZURlc2NyaXB0aW9uID0gYCR7aHR0cE1ldGhvZH0gJHt1cmxQYXRofWA7XG5cbiAgLy8gV2hlbiB0aGUgaHR0cCBzcGFuIGhhcyBhIGdyYXBocWwgb3BlcmF0aW9uLCBhcHBlbmQgaXQgdG8gdGhlIGRlc2NyaXB0aW9uXG4gIC8vIFdlIGFkZCB0aGVzZSBpbiB0aGUgZ3JhcGhxbEludGVncmF0aW9uXG4gIGNvbnN0IGluZmVycmVkRGVzY3JpcHRpb24gPSBncmFwaHFsT3BlcmF0aW9uc0F0dHJpYnV0ZVxuICAgID8gYCR7YmFzZURlc2NyaXB0aW9ufSAoJHtnZXRHcmFwaHFsT3BlcmF0aW9uTmFtZXNGcm9tQXR0cmlidXRlKGdyYXBocWxPcGVyYXRpb25zQXR0cmlidXRlKX0pYFxuICAgIDogYmFzZURlc2NyaXB0aW9uO1xuXG4gIC8vIElmIGBodHRwUGF0aGAgaXMgYSByb290IHBhdGgsIHRoZW4gd2UgY2FuIGNhdGVnb3JpemUgdGhlIHRyYW5zYWN0aW9uIHNvdXJjZSBhcyByb3V0ZS5cbiAgY29uc3QgaW5mZXJyZWRTb3VyY2UgPSBoYXNSb3V0ZSB8fCB1cmxQYXRoID09PSAnLycgPyAncm91dGUnIDogJ3VybCc7XG5cbiAgY29uc3QgZGF0YSA9IHt9O1xuXG4gIGlmICh1cmwpIHtcbiAgICBkYXRhLnVybCA9IHVybDtcbiAgfVxuICBpZiAocXVlcnkpIHtcbiAgICBkYXRhWydodHRwLnF1ZXJ5J10gPSBxdWVyeTtcbiAgfVxuICBpZiAoZnJhZ21lbnQpIHtcbiAgICBkYXRhWydodHRwLmZyYWdtZW50J10gPSBmcmFnbWVudDtcbiAgfVxuXG4gIC8vIElmIHRoZSBzcGFuIGtpbmQgaXMgbmVpdGhlciBjbGllbnQgbm9yIHNlcnZlciwgd2UgdXNlIHRoZSBvcmlnaW5hbCBuYW1lXG4gIC8vIHRoaXMgaW5mZXJzIHRoYXQgc29tZWJvZHkgbWFudWFsbHkgc3RhcnRlZCB0aGlzIHNwYW4sIGluIHdoaWNoIGNhc2Ugd2UgZG9uJ3Qgd2FudCB0byBvdmVyd3JpdGUgdGhlIG5hbWVcbiAgY29uc3QgaXNDbGllbnRPclNlcnZlcktpbmQgPSBraW5kID09PSBhcGkuU3BhbktpbmQuQ0xJRU5UIHx8IGtpbmQgPT09IGFwaS5TcGFuS2luZC5TRVJWRVI7XG5cbiAgLy8gSWYgdGhlIHNwYW4gaXMgYW4gYXV0by1zcGFuICg9aXQgY29tZXMgZnJvbSBvbmUgb2Ygb3VyIGluc3RydW1lbnRhdGlvbnMpLFxuICAvLyB3ZSBhbHdheXMgd2FudCB0byBpbmZlciB0aGUgbmFtZVxuICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNvbWUgb2YgdGhlIGF1dG8taW5zdHJ1bWVudGF0aW9uIHdlIHVzZSB1c2VzIGtpbmQ9SU5URVJOQUxcbiAgY29uc3Qgb3JpZ2luID0gYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOXSB8fCAnbWFudWFsJztcbiAgY29uc3QgaXNNYW51YWxTcGFuID0gIWAke29yaWdpbn1gLnN0YXJ0c1dpdGgoJ2F1dG8nKTtcblxuICAvLyBJZiB1c2VycyAob3IgaW4gdmVyeSByYXJlIG9jY2FzaW9ucyB3ZSkgc2V0IHRoZSBzb3VyY2UgdG8gY3VzdG9tLCB3ZSBkb24ndCBvdmVyd3JpdGUgdGhlIG5hbWVcbiAgY29uc3QgYWxyZWFkeUhhc0N1c3RvbVNvdXJjZSA9IGF0dHJpYnV0ZXNbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRV0gPT09ICdjdXN0b20nO1xuICBjb25zdCBjdXN0b21TcGFuTmFtZSA9IGF0dHJpYnV0ZXNbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX0NVU1RPTV9TUEFOX05BTUVdO1xuXG4gIGNvbnN0IHVzZUluZmVycmVkRGVzY3JpcHRpb24gPVxuICAgICFhbHJlYWR5SGFzQ3VzdG9tU291cmNlICYmIGN1c3RvbVNwYW5OYW1lID09IG51bGwgJiYgKGlzQ2xpZW50T3JTZXJ2ZXJLaW5kIHx8ICFpc01hbnVhbFNwYW4pO1xuXG4gIGNvbnN0IHsgZGVzY3JpcHRpb24sIHNvdXJjZSB9ID0gdXNlSW5mZXJyZWREZXNjcmlwdGlvblxuICAgID8geyBkZXNjcmlwdGlvbjogaW5mZXJyZWREZXNjcmlwdGlvbiwgc291cmNlOiBpbmZlcnJlZFNvdXJjZSB9XG4gICAgOiBnZXRVc2VyVXBkYXRlZE5hbWVBbmRTb3VyY2UobmFtZSwgYXR0cmlidXRlcyk7XG5cbiAgcmV0dXJuIHtcbiAgICBvcDogb3BQYXJ0cy5qb2luKCcuJyksXG4gICAgZGVzY3JpcHRpb24sXG4gICAgc291cmNlLFxuICAgIGRhdGEsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEdyYXBocWxPcGVyYXRpb25OYW1lc0Zyb21BdHRyaWJ1dGUoYXR0cikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhdHRyKSkge1xuICAgIGNvbnN0IHNvcnRlZCA9IGF0dHIuc2xpY2UoKS5zb3J0KCk7XG5cbiAgICAvLyBVcCB0byA1IGl0ZW1zLCB3ZSBqdXN0IGFkZCBhbGwgb2YgdGhlbVxuICAgIGlmIChzb3J0ZWQubGVuZ3RoIDw9IDUpIHtcbiAgICAgIHJldHVybiBzb3J0ZWQuam9pbignLCAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRWxzZSwgd2UgYWRkIHRoZSBmaXJzdCA1IGFuZCB0aGUgZGlmZiBvZiBvdGhlciBvcGVyYXRpb25zXG4gICAgICByZXR1cm4gYCR7c29ydGVkLnNsaWNlKDAsIDUpLmpvaW4oJywgJyl9LCArJHtzb3J0ZWQubGVuZ3RoIC0gNX1gO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBgJHthdHRyfWA7XG59XG5cbi8qKiBFeHBvcnRlZCBmb3IgdGVzdHMgb25seSAqL1xuZnVuY3Rpb24gZ2V0U2FuaXRpemVkVXJsKFxuICBhdHRyaWJ1dGVzLFxuICBraW5kLFxuKVxuXG4ge1xuICAvLyBUaGlzIGlzIHRoZSByZWxhdGl2ZSBwYXRoIG9mIHRoZSBVUkwsIGUuZy4gL3N1YlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgY29uc3QgaHR0cFRhcmdldCA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19IVFRQX1RBUkdFVF07XG4gIC8vIFRoaXMgaXMgdGhlIGZ1bGwgVVJMLCBpbmNsdWRpbmcgaG9zdCAmIHF1ZXJ5IHBhcmFtcyBldGMuLCBlLmcuIGh0dHBzOi8vZXhhbXBsZS5jb20vc3ViP2Zvbz1iYXJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIGNvbnN0IGh0dHBVcmwgPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9VUkxdIHx8IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5BVFRSX1VSTF9GVUxMXTtcbiAgLy8gVGhpcyBpcyB0aGUgbm9ybWFsaXplZCByb3V0ZSBuYW1lIC0gbWF5IG5vdCBhbHdheXMgYmUgYXZhaWxhYmxlIVxuICBjb25zdCBodHRwUm91dGUgPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuQVRUUl9IVFRQX1JPVVRFXTtcblxuICBjb25zdCBwYXJzZWRVcmwgPSB0eXBlb2YgaHR0cFVybCA9PT0gJ3N0cmluZycgPyBjb3JlLnBhcnNlVXJsKGh0dHBVcmwpIDogdW5kZWZpbmVkO1xuICBjb25zdCB1cmwgPSBwYXJzZWRVcmwgPyBjb3JlLmdldFNhbml0aXplZFVybFN0cmluZyhwYXJzZWRVcmwpIDogdW5kZWZpbmVkO1xuICBjb25zdCBxdWVyeSA9IHBhcnNlZFVybD8uc2VhcmNoIHx8IHVuZGVmaW5lZDtcbiAgY29uc3QgZnJhZ21lbnQgPSBwYXJzZWRVcmw/Lmhhc2ggfHwgdW5kZWZpbmVkO1xuXG4gIGlmICh0eXBlb2YgaHR0cFJvdXRlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB7IHVybFBhdGg6IGh0dHBSb3V0ZSwgdXJsLCBxdWVyeSwgZnJhZ21lbnQsIGhhc1JvdXRlOiB0cnVlIH07XG4gIH1cblxuICBpZiAoa2luZCA9PT0gYXBpLlNwYW5LaW5kLlNFUlZFUiAmJiB0eXBlb2YgaHR0cFRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4geyB1cmxQYXRoOiBjb3JlLnN0cmlwVXJsUXVlcnlBbmRGcmFnbWVudChodHRwVGFyZ2V0KSwgdXJsLCBxdWVyeSwgZnJhZ21lbnQsIGhhc1JvdXRlOiBmYWxzZSB9O1xuICB9XG5cbiAgaWYgKHBhcnNlZFVybCkge1xuICAgIHJldHVybiB7IHVybFBhdGg6IHVybCwgdXJsLCBxdWVyeSwgZnJhZ21lbnQsIGhhc1JvdXRlOiBmYWxzZSB9O1xuICB9XG5cbiAgLy8gZmFsbCBiYWNrIHRvIHRhcmdldCBldmVuIGZvciBjbGllbnQgc3BhbnMsIGlmIG5vIFVSTCBpcyBwcmVzZW50XG4gIGlmICh0eXBlb2YgaHR0cFRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4geyB1cmxQYXRoOiBjb3JlLnN0cmlwVXJsUXVlcnlBbmRGcmFnbWVudChodHRwVGFyZ2V0KSwgdXJsLCBxdWVyeSwgZnJhZ21lbnQsIGhhc1JvdXRlOiBmYWxzZSB9O1xuICB9XG5cbiAgcmV0dXJuIHsgdXJsUGF0aDogdW5kZWZpbmVkLCB1cmwsIHF1ZXJ5LCBmcmFnbWVudCwgaGFzUm91dGU6IGZhbHNlIH07XG59XG5cbi8qKlxuICogQmVjYXVzZSBPdGVsIGluc3RydW1lbnRhdGlvbiBzb21ldGltZXMgbXV0YXRlcyBzcGFuIG5hbWVzIHZpYSBgc3Bhbi51cGRhdGVOYW1lYCwgdGhlIG9ubHkgd2F5XG4gKiB0byBlbnN1cmUgdGhhdCBhIHVzZXItc2V0IHNwYW4gbmFtZSBpcyBwcmVzZXJ2ZWQgaXMgdG8gc3RvcmUgaXQgYXMgYSB0bXAgYXR0cmlidXRlIG9uIHRoZSBzcGFuLlxuICogV2UgZGVsZXRlIHRoaXMgYXR0cmlidXRlIG9uY2Ugd2UncmUgZG9uZSB3aXRoIGl0IHdoZW4gcHJlcGFyaW5nIHRoZSBldmVudCBlbnZlbG9wZS5cbiAqXG4gKiBUaGlzIHRlbXAgYXR0cmlidXRlIGFsd2F5cyB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhlIG9yaWdpbmFsIG5hbWUuXG4gKlxuICogV2UgYWxzbyBuZWVkIHRvIHRha2UgY2FyZSBvZiBzZXR0aW5nIHRoZSBjb3JyZWN0IHNvdXJjZS4gVXNlcnMgY2FuIGFsd2F5cyB1cGRhdGUgdGhlIHNvdXJjZVxuICogYWZ0ZXIgdXBkYXRpbmcgdGhlIG5hbWUsIHNvIHdlIG5lZWQgdG8gcmVzcGVjdCB0aGF0LlxuICpcbiAqIEBpbnRlcm5hbCBleHBvcnRlZCBvbmx5IGZvciB0ZXN0aW5nXG4gKi9cbmZ1bmN0aW9uIGdldFVzZXJVcGRhdGVkTmFtZUFuZFNvdXJjZShcbiAgb3JpZ2luYWxOYW1lLFxuICBhdHRyaWJ1dGVzLFxuICBmYWxsYmFja1NvdXJjZSA9ICdjdXN0b20nLFxuKVxuXG4ge1xuICBjb25zdCBzb3VyY2UgPSAoYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFXSApIHx8IGZhbGxiYWNrU291cmNlO1xuICBjb25zdCBkZXNjcmlwdGlvbiA9IGF0dHJpYnV0ZXNbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX0NVU1RPTV9TUEFOX05BTUVdO1xuXG4gIGlmIChkZXNjcmlwdGlvbiAmJiB0eXBlb2YgZGVzY3JpcHRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgc291cmNlLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4geyBkZXNjcmlwdGlvbjogb3JpZ2luYWxOYW1lLCBzb3VyY2UgfTtcbn1cblxuLyoqXG4gKiBTZXR1cCBhIERTQyBoYW5kbGVyIG9uIHRoZSBwYXNzZWQgY2xpZW50LFxuICogZW5zdXJpbmcgdGhhdCB0aGUgdHJhbnNhY3Rpb24gbmFtZSBpcyBpbmZlcnJlZCBmcm9tIHRoZSBzcGFuIGNvcnJlY3RseS5cbiAqL1xuZnVuY3Rpb24gZW5oYW5jZURzY1dpdGhPcGVuVGVsZW1ldHJ5Um9vdFNwYW5OYW1lKGNsaWVudCkge1xuICBjbGllbnQub24oJ2NyZWF0ZURzYycsIChkc2MsIHJvb3RTcGFuKSA9PiB7XG4gICAgaWYgKCFyb290U3Bhbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFdlIHdhbnQgdG8gb3ZlcndyaXRlIHRoZSB0cmFuc2FjdGlvbiBvbiB0aGUgRFNDIHRoYXQgaXMgY3JlYXRlZCBieSBkZWZhdWx0IGluIGNvcmVcbiAgICAvLyBUaGUgcmVhc29uIGZvciB0aGlzIGlzIHRoYXQgd2Ugd2FudCB0byBpbmZlciB0aGUgc3BhbiBuYW1lLCBub3QgdXNlIHRoZSBpbml0aWFsIG9uZVxuICAgIC8vIE90aGVyd2lzZSwgd2UnbGwgZ2V0IG5hbWVzIGxpa2UgXCJHRVRcIiBpbnN0ZWFkIG9mIGUuZy4gXCJHRVQgL2Zvb1wiXG4gICAgLy8gYHBhcnNlU3BhbkRlc2NyaXB0aW9uYCB0YWtlcyB0aGUgYXR0cmlidXRlcyBvZiB0aGUgc3BhbiBpbnRvIGFjY291bnQgZm9yIHRoZSBuYW1lXG4gICAgLy8gVGhpcyBtdXRhdGVzIHRoZSBwYXNzZWQtaW4gRFNDXG5cbiAgICBjb25zdCBqc29uU3BhbiA9IGNvcmUuc3BhblRvSlNPTihyb290U3Bhbik7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IGpzb25TcGFuLmRhdGE7XG4gICAgY29uc3Qgc291cmNlID0gYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFXTtcblxuICAgIGNvbnN0IHsgZGVzY3JpcHRpb24gfSA9IHNwYW5IYXNOYW1lKHJvb3RTcGFuKSA/IHBhcnNlU3BhbkRlc2NyaXB0aW9uKHJvb3RTcGFuKSA6IHsgZGVzY3JpcHRpb246IHVuZGVmaW5lZCB9O1xuICAgIGlmIChzb3VyY2UgIT09ICd1cmwnICYmIGRlc2NyaXB0aW9uKSB7XG4gICAgICBkc2MudHJhbnNhY3Rpb24gPSBkZXNjcmlwdGlvbjtcbiAgICB9XG5cbiAgICAvLyBBbHNvIGVuc3VyZSBzYW1wbGluZyBkZWNpc2lvbiBpcyBjb3JyZWN0bHkgaW5mZXJyZWRcbiAgICAvLyBJbiBjb3JlLCB3ZSB1c2UgYHNwYW5Jc1NhbXBsZWRgLCB3aGljaCBqdXN0IGxvb2tzIGF0IHRoZSB0cmFjZSBmbGFnc1xuICAgIC8vIGJ1dCBpbiBPVEVMLCB3ZSB1c2UgYSBzbGlnaHRseSBtb3JlIGNvbXBsZXggbG9naWMgdG8gYmUgYWJsZSB0byBkaWZmZXJudGlhdGUgYmV0d2VlbiB1bnNhbXBsZWQgYW5kIGRlZmVycmVkIHNhbXBsaW5nXG4gICAgaWYgKGNvcmUuaGFzU3BhbnNFbmFibGVkKCkpIHtcbiAgICAgIGNvbnN0IHNhbXBsZWQgPSBnZXRTYW1wbGluZ0RlY2lzaW9uKHJvb3RTcGFuLnNwYW5Db250ZXh0KCkpO1xuICAgICAgZHNjLnNhbXBsZWQgPSBzYW1wbGVkID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IFN0cmluZyhzYW1wbGVkKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnRseSBhY3RpdmUgc3Bhbi5cbiAqL1xuZnVuY3Rpb24gZ2V0QWN0aXZlU3BhbigpIHtcbiAgcmV0dXJuIGFwaS50cmFjZS5nZXRBY3RpdmVTcGFuKCk7XG59XG5cbi8qKlxuICogVGhpcyBzZXJ2ZXMgYXMgYSBidWlsZCB0aW1lIGZsYWcgdGhhdCB3aWxsIGJlIHRydWUgYnkgZGVmYXVsdCwgYnV0IGZhbHNlIGluIG5vbi1kZWJ1ZyBidWlsZHMgb3IgaWYgdXNlcnMgcmVwbGFjZSBgX19TRU5UUllfREVCVUdfX2AgaW4gdGhlaXIgZ2VuZXJhdGVkIGNvZGUuXG4gKlxuICogQVRURU5USU9OOiBUaGlzIGNvbnN0YW50IG11c3QgbmV2ZXIgY3Jvc3MgcGFja2FnZSBib3VuZGFyaWVzIChpLmUuIGJlIGV4cG9ydGVkKSB0byBndWFyYW50ZWUgdGhhdCBpdCBjYW4gYmUgdXNlZCBmb3IgdHJlZSBzaGFraW5nLlxuICovXG5jb25zdCBERUJVR19CVUlMRCA9ICh0eXBlb2YgX19TRU5UUllfREVCVUdfXyA9PT0gJ3VuZGVmaW5lZCcgfHwgX19TRU5UUllfREVCVUdfXyk7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBUcmFjZVN0YXRlIGZvciB0aGUgZ2l2ZW4gZGF0YS5cbiAqL1xuZnVuY3Rpb24gbWFrZVRyYWNlU3RhdGUoe1xuICBkc2MsXG4gIHNhbXBsZWQsXG59XG5cbikge1xuICAvLyBXZSBzdG9yZSB0aGUgRFNDIGFzIE9URUwgdHJhY2Ugc3RhdGUgb24gdGhlIHNwYW4gY29udGV4dFxuICBjb25zdCBkc2NTdHJpbmcgPSBkc2MgPyBjb3JlLmR5bmFtaWNTYW1wbGluZ0NvbnRleHRUb1NlbnRyeUJhZ2dhZ2VIZWFkZXIoZHNjKSA6IHVuZGVmaW5lZDtcblxuICBjb25zdCB0cmFjZVN0YXRlQmFzZSA9IG5ldyBjb3JlJDEuVHJhY2VTdGF0ZSgpO1xuXG4gIGNvbnN0IHRyYWNlU3RhdGVXaXRoRHNjID0gZHNjU3RyaW5nID8gdHJhY2VTdGF0ZUJhc2Uuc2V0KFNFTlRSWV9UUkFDRV9TVEFURV9EU0MsIGRzY1N0cmluZykgOiB0cmFjZVN0YXRlQmFzZTtcblxuICAvLyBXZSBhbHNvIHNwZWNpZmljYWxseSB3YW50IHRvIHN0b3JlIGlmIHRoaXMgaXMgc2FtcGxlZCB0byBiZSBub3QgcmVjb3JkaW5nLFxuICAvLyBvciB1bnNhbXBsZWQgKD1jb3VsZCBiZSBlaXRoZXIgc2FtcGxlZCBvciBub3QpXG4gIHJldHVybiBzYW1wbGVkID09PSBmYWxzZSA/IHRyYWNlU3RhdGVXaXRoRHNjLnNldChTRU5UUllfVFJBQ0VfU1RBVEVfU0FNUExFRF9OT1RfUkVDT1JESU5HLCAnMScpIDogdHJhY2VTdGF0ZVdpdGhEc2M7XG59XG5cbmNvbnN0IHNldHVwRWxlbWVudHMgPSBuZXcgU2V0KCk7XG5cbi8qKiBHZXQgYWxsIHRoZSBPcGVuVGVsZW1ldHJ5IGVsZW1lbnRzIHRoYXQgaGF2ZSBiZWVuIHNldCB1cC4gKi9cbmZ1bmN0aW9uIG9wZW5UZWxlbWV0cnlTZXR1cENoZWNrKCkge1xuICByZXR1cm4gQXJyYXkuZnJvbShzZXR1cEVsZW1lbnRzKTtcbn1cblxuLyoqIE1hcmsgYW4gT3BlblRlbGVtZXRyeSBlbGVtZW50IGFzIHNldHVwLiAqL1xuZnVuY3Rpb24gc2V0SXNTZXR1cChlbGVtZW50KSB7XG4gIHNldHVwRWxlbWVudHMuYWRkKGVsZW1lbnQpO1xufVxuXG4vKipcbiAqIEluamVjdHMgYW5kIGV4dHJhY3RzIGBzZW50cnktdHJhY2VgIGFuZCBgYmFnZ2FnZWAgaGVhZGVycyBmcm9tIGNhcnJpZXJzLlxuICovXG5jbGFzcyBTZW50cnlQcm9wYWdhdG9yIGV4dGVuZHMgY29yZSQxLlczQ0JhZ2dhZ2VQcm9wYWdhdG9yIHtcbiAgLyoqIEEgbWFwIG9mIFVSTHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBjaGVja2VkIGZvciBpZiB0aGV5IG1hdGNoIHRyYWNlUHJvcGFnYXRpb25UYXJnZXRzLiAqL1xuXG4gICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHNldElzU2V0dXAoJ1NlbnRyeVByb3BhZ2F0b3InKTtcblxuICAgIC8vIFdlJ3JlIGNhY2hpbmcgcmVzdWx0cyBzbyB3ZSBkb24ndCBoYXZlIHRvIHJlY29tcHV0ZSByZWdleHAgZXZlcnkgdGltZSB3ZSBjcmVhdGUgYSByZXF1ZXN0LlxuICAgIHRoaXMuX3VybE1hdGNoZXNUYXJnZXRzTWFwID0gbmV3IGNvcmUuTFJVTWFwKDEwMCk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBpbmplY3QoY29udGV4dCwgY2Fycmllciwgc2V0dGVyKSB7XG4gICAgaWYgKGNvcmUkMS5pc1RyYWNpbmdTdXBwcmVzc2VkKGNvbnRleHQpKSB7XG4gICAgICBERUJVR19CVUlMRCAmJiBjb3JlLmRlYnVnLmxvZygnW1RyYWNpbmddIE5vdCBpbmplY3RpbmcgdHJhY2UgZGF0YSBmb3IgdXJsIGJlY2F1c2UgdHJhY2luZyBpcyBzdXBwcmVzc2VkLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdGl2ZVNwYW4gPSBhcGkudHJhY2UuZ2V0U3Bhbihjb250ZXh0KTtcbiAgICBjb25zdCB1cmwgPSBhY3RpdmVTcGFuICYmIGdldEN1cnJlbnRVUkwoYWN0aXZlU3Bhbik7XG5cbiAgICBjb25zdCB0cmFjZVByb3BhZ2F0aW9uVGFyZ2V0cyA9IGNvcmUuZ2V0Q2xpZW50KCk/LmdldE9wdGlvbnMoKT8udHJhY2VQcm9wYWdhdGlvblRhcmdldHM7XG4gICAgaWYgKCFzaG91bGRQcm9wYWdhdGVUcmFjZUZvclVybCh1cmwsIHRyYWNlUHJvcGFnYXRpb25UYXJnZXRzLCB0aGlzLl91cmxNYXRjaGVzVGFyZ2V0c01hcCkpIHtcbiAgICAgIERFQlVHX0JVSUxEICYmXG4gICAgICAgIGNvcmUuZGVidWcubG9nKCdbVHJhY2luZ10gTm90IGluamVjdGluZyB0cmFjZSBkYXRhIGZvciB1cmwgYmVjYXVzZSBpdCBkb2VzIG5vdCBtYXRjaCB0cmFjZVByb3BhZ2F0aW9uVGFyZ2V0czonLCB1cmwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGV4aXN0aW5nQmFnZ2FnZUhlYWRlciA9IGdldEV4aXN0aW5nQmFnZ2FnZShjYXJyaWVyKTtcbiAgICBsZXQgYmFnZ2FnZSA9IGFwaS5wcm9wYWdhdGlvbi5nZXRCYWdnYWdlKGNvbnRleHQpIHx8IGFwaS5wcm9wYWdhdGlvbi5jcmVhdGVCYWdnYWdlKHt9KTtcblxuICAgIGNvbnN0IHsgZHluYW1pY1NhbXBsaW5nQ29udGV4dCwgdHJhY2VJZCwgc3BhbklkLCBzYW1wbGVkIH0gPSBnZXRJbmplY3Rpb25EYXRhKGNvbnRleHQpO1xuXG4gICAgaWYgKGV4aXN0aW5nQmFnZ2FnZUhlYWRlcikge1xuICAgICAgY29uc3QgYmFnZ2FnZUVudHJpZXMgPSBjb3JlLnBhcnNlQmFnZ2FnZUhlYWRlcihleGlzdGluZ0JhZ2dhZ2VIZWFkZXIpO1xuXG4gICAgICBpZiAoYmFnZ2FnZUVudHJpZXMpIHtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoYmFnZ2FnZUVudHJpZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgIGJhZ2dhZ2UgPSBiYWdnYWdlLnNldEVudHJ5KGtleSwgeyB2YWx1ZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGR5bmFtaWNTYW1wbGluZ0NvbnRleHQpIHtcbiAgICAgIGJhZ2dhZ2UgPSBPYmplY3QuZW50cmllcyhkeW5hbWljU2FtcGxpbmdDb250ZXh0KS5yZWR1Y2UoKGIsIFtkc2NLZXksIGRzY1ZhbHVlXSkgPT4ge1xuICAgICAgICBpZiAoZHNjVmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gYi5zZXRFbnRyeShgJHtjb3JlLlNFTlRSWV9CQUdHQUdFX0tFWV9QUkVGSVh9JHtkc2NLZXl9YCwgeyB2YWx1ZTogZHNjVmFsdWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9LCBiYWdnYWdlKTtcbiAgICB9XG5cbiAgICAvLyBXZSBhbHNvIHdhbnQgdG8gYXZvaWQgc2V0dGluZyB0aGUgZGVmYXVsdCBPVEVMIHRyYWNlIElELCBpZiB3ZSBnZXQgdGhhdCBmb3Igd2hhdGV2ZXIgcmVhc29uXG4gICAgaWYgKHRyYWNlSWQgJiYgdHJhY2VJZCAhPT0gYXBpLklOVkFMSURfVFJBQ0VJRCkge1xuICAgICAgc2V0dGVyLnNldChjYXJyaWVyLCBTRU5UUllfVFJBQ0VfSEVBREVSLCBjb3JlLmdlbmVyYXRlU2VudHJ5VHJhY2VIZWFkZXIodHJhY2VJZCwgc3BhbklkLCBzYW1wbGVkKSk7XG4gICAgfVxuXG4gICAgc3VwZXIuaW5qZWN0KGFwaS5wcm9wYWdhdGlvbi5zZXRCYWdnYWdlKGNvbnRleHQsIGJhZ2dhZ2UpLCBjYXJyaWVyLCBzZXR0ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICAgZXh0cmFjdChjb250ZXh0LCBjYXJyaWVyLCBnZXR0ZXIpIHtcbiAgICBjb25zdCBtYXliZVNlbnRyeVRyYWNlSGVhZGVyID0gZ2V0dGVyLmdldChjYXJyaWVyLCBTRU5UUllfVFJBQ0VfSEVBREVSKTtcbiAgICBjb25zdCBiYWdnYWdlID0gZ2V0dGVyLmdldChjYXJyaWVyLCBTRU5UUllfQkFHR0FHRV9IRUFERVIpO1xuXG4gICAgY29uc3Qgc2VudHJ5VHJhY2UgPSBtYXliZVNlbnRyeVRyYWNlSGVhZGVyXG4gICAgICA/IEFycmF5LmlzQXJyYXkobWF5YmVTZW50cnlUcmFjZUhlYWRlcilcbiAgICAgICAgPyBtYXliZVNlbnRyeVRyYWNlSGVhZGVyWzBdXG4gICAgICAgIDogbWF5YmVTZW50cnlUcmFjZUhlYWRlclxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBBZGQgcmVtb3RlIHBhcmVudCBzcGFuIGNvbnRleHRcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBpbmNvbWluZyB0cmFjZSwgdGhpcyB3aWxsIHJldHVybiB0aGUgY29udGV4dCBhcy1pc1xuICAgIHJldHVybiBlbnN1cmVTY29wZXNPbkNvbnRleHQoZ2V0Q29udGV4dFdpdGhSZW1vdGVBY3RpdmVTcGFuKGNvbnRleHQsIHsgc2VudHJ5VHJhY2UsIGJhZ2dhZ2UgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICAgZmllbGRzKCkge1xuICAgIHJldHVybiBbU0VOVFJZX1RSQUNFX0hFQURFUiwgU0VOVFJZX0JBR0dBR0VfSEVBREVSXTtcbiAgfVxufVxuXG5jb25zdCBOT1RfUFJPUEFHQVRFRF9NRVNTQUdFID1cbiAgJ1tUcmFjaW5nXSBOb3QgaW5qZWN0aW5nIHRyYWNlIGRhdGEgZm9yIHVybCBiZWNhdXNlIGl0IGRvZXMgbm90IG1hdGNoIHRyYWNlUHJvcGFnYXRpb25UYXJnZXRzOic7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBnaXZlbiBVUkwgc2hvdWxkIGJlIHByb3BhZ2F0ZWQgdG8gb3Igbm90LlxuICogSWYgbm8gdXJsIGlzIGRlZmluZWQsIG9yIG5vIHRyYWNlIHByb3BhZ2F0aW9uIHRhcmdldHMgYXJlIGRlZmluZWQsIHRoaXMgd2lsbCBhbHdheXMgcmV0dXJuIGB0cnVlYC5cbiAqIFlvdSBjYW4gYWxzbyBvcHRpb25hbGx5IHByb3ZpZGUgYSBkZWNpc2lvbiBtYXAsIHRvIGNhY2hlIGRlY2lzaW9ucyBhbmQgYXZvaWQgcmVwZWF0ZWQgcmVnZXggbG9va3Vwcy5cbiAqL1xuZnVuY3Rpb24gc2hvdWxkUHJvcGFnYXRlVHJhY2VGb3JVcmwoXG4gIHVybCxcbiAgdHJhY2VQcm9wYWdhdGlvblRhcmdldHMsXG4gIGRlY2lzaW9uTWFwLFxuKSB7XG4gIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJyB8fCAhdHJhY2VQcm9wYWdhdGlvblRhcmdldHMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IGNhY2hlZERlY2lzaW9uID0gZGVjaXNpb25NYXA/LmdldCh1cmwpO1xuICBpZiAoY2FjaGVkRGVjaXNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIERFQlVHX0JVSUxEICYmICFjYWNoZWREZWNpc2lvbiAmJiBjb3JlLmRlYnVnLmxvZyhOT1RfUFJPUEFHQVRFRF9NRVNTQUdFLCB1cmwpO1xuICAgIHJldHVybiBjYWNoZWREZWNpc2lvbjtcbiAgfVxuXG4gIGNvbnN0IGRlY2lzaW9uID0gY29yZS5zdHJpbmdNYXRjaGVzU29tZVBhdHRlcm4odXJsLCB0cmFjZVByb3BhZ2F0aW9uVGFyZ2V0cyk7XG4gIGRlY2lzaW9uTWFwPy5zZXQodXJsLCBkZWNpc2lvbik7XG5cbiAgREVCVUdfQlVJTEQgJiYgIWRlY2lzaW9uICYmIGNvcmUuZGVidWcubG9nKE5PVF9QUk9QQUdBVEVEX01FU1NBR0UsIHVybCk7XG4gIHJldHVybiBkZWNpc2lvbjtcbn1cblxuLyoqXG4gKiBHZXQgcHJvcGFnYXRpb24gaW5qZWN0aW9uIGRhdGEgZm9yIHRoZSBnaXZlbiBjb250ZXh0LlxuICogVGhlIGFkZGl0aW9uYWwgb3B0aW9ucyBjYW4gYmUgcGFzc2VkIHRvIG92ZXJyaWRlIHRoZSBzY29wZSBhbmQgY2xpZW50IHRoYXQgaXMgb3RoZXJ3aXNlIGRlcml2ZWQgZnJvbSB0aGUgY29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZ2V0SW5qZWN0aW9uRGF0YShcbiAgY29udGV4dCxcbiAgb3B0aW9ucyA9IHt9LFxuKVxuXG4ge1xuICBjb25zdCBzcGFuID0gYXBpLnRyYWNlLmdldFNwYW4oY29udGV4dCk7XG5cbiAgLy8gSWYgd2UgaGF2ZSBhIHJlbW90ZSBzcGFuLCB0aGUgc3BhbklkIHNob3VsZCBiZSBjb25zaWRlcmVkIGFzIHRoZSBwYXJlbnRTcGFuSWQsIG5vdCBzcGFuSWQgaXRzZWxmXG4gIC8vIEluc3RlYWQsIHdlIHVzZSBhIHZpcnR1YWwgKGdlbmVyYXRlZCkgc3BhbklkIGZvciBwcm9wYWdhdGlvblxuICBpZiAoc3Bhbj8uc3BhbkNvbnRleHQoKS5pc1JlbW90ZSkge1xuICAgIGNvbnN0IHNwYW5Db250ZXh0ID0gc3Bhbi5zcGFuQ29udGV4dCgpO1xuICAgIGNvbnN0IGR5bmFtaWNTYW1wbGluZ0NvbnRleHQgPSBjb3JlLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbihzcGFuKTtcblxuICAgIHJldHVybiB7XG4gICAgICBkeW5hbWljU2FtcGxpbmdDb250ZXh0LFxuICAgICAgdHJhY2VJZDogc3BhbkNvbnRleHQudHJhY2VJZCxcbiAgICAgIHNwYW5JZDogdW5kZWZpbmVkLFxuICAgICAgc2FtcGxlZDogZ2V0U2FtcGxpbmdEZWNpc2lvbihzcGFuQ29udGV4dCksIC8vIFRPRE86IERvIHdlIG5lZWQgdG8gY2hhbmdlIHNvbWV0aGluZyBoZXJlP1xuICAgIH07XG4gIH1cblxuICAvLyBJZiB3ZSBoYXZlIGEgbG9jYWwgc3Bhbiwgd2UganVzdCB1c2UgdGhpc1xuICBpZiAoc3Bhbikge1xuICAgIGNvbnN0IHNwYW5Db250ZXh0ID0gc3Bhbi5zcGFuQ29udGV4dCgpO1xuICAgIGNvbnN0IGR5bmFtaWNTYW1wbGluZ0NvbnRleHQgPSBjb3JlLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbihzcGFuKTtcblxuICAgIHJldHVybiB7XG4gICAgICBkeW5hbWljU2FtcGxpbmdDb250ZXh0LFxuICAgICAgdHJhY2VJZDogc3BhbkNvbnRleHQudHJhY2VJZCxcbiAgICAgIHNwYW5JZDogc3BhbkNvbnRleHQuc3BhbklkLFxuICAgICAgc2FtcGxlZDogZ2V0U2FtcGxpbmdEZWNpc2lvbihzcGFuQ29udGV4dCksIC8vIFRPRE86IERvIHdlIG5lZWQgdG8gY2hhbmdlIHNvbWV0aGluZyBoZXJlP1xuICAgIH07XG4gIH1cblxuICAvLyBFbHNlIHdlIHRyeSB0byB1c2UgdGhlIHByb3BhZ2F0aW9uIGNvbnRleHQgZnJvbSB0aGUgc2NvcGVcbiAgLy8gVGhlIG9ubHkgc2NlbmFyaW8gd2hlcmUgdGhpcyBzaG91bGQgaGFwcGVuIGlzIHdoZW4gd2UgbmVpdGhlciBoYXZlIGEgc3Bhbiwgbm9yIGFuIGluY29taW5nIHRyYWNlXG4gIGNvbnN0IHNjb3BlID0gb3B0aW9ucy5zY29wZSB8fCBnZXRTY29wZXNGcm9tQ29udGV4dChjb250ZXh0KT8uc2NvcGUgfHwgY29yZS5nZXRDdXJyZW50U2NvcGUoKTtcbiAgY29uc3QgY2xpZW50ID0gb3B0aW9ucy5jbGllbnQgfHwgY29yZS5nZXRDbGllbnQoKTtcblxuICBjb25zdCBwcm9wYWdhdGlvbkNvbnRleHQgPSBzY29wZS5nZXRQcm9wYWdhdGlvbkNvbnRleHQoKTtcbiAgY29uc3QgZHluYW1pY1NhbXBsaW5nQ29udGV4dCA9IGNsaWVudCA/IGNvcmUuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TY29wZShjbGllbnQsIHNjb3BlKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIHtcbiAgICBkeW5hbWljU2FtcGxpbmdDb250ZXh0LFxuICAgIHRyYWNlSWQ6IHByb3BhZ2F0aW9uQ29udGV4dC50cmFjZUlkLFxuICAgIHNwYW5JZDogcHJvcGFnYXRpb25Db250ZXh0LnByb3BhZ2F0aW9uU3BhbklkLFxuICAgIHNhbXBsZWQ6IHByb3BhZ2F0aW9uQ29udGV4dC5zYW1wbGVkLFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0V2l0aFJlbW90ZUFjdGl2ZVNwYW4oXG4gIGN0eCxcbiAgeyBzZW50cnlUcmFjZSwgYmFnZ2FnZSB9LFxuKSB7XG4gIGNvbnN0IHByb3BhZ2F0aW9uQ29udGV4dCA9IGNvcmUucHJvcGFnYXRpb25Db250ZXh0RnJvbUhlYWRlcnMoc2VudHJ5VHJhY2UsIGJhZ2dhZ2UpO1xuXG4gIGNvbnN0IHsgdHJhY2VJZCwgcGFyZW50U3BhbklkLCBzYW1wbGVkLCBkc2MgfSA9IHByb3BhZ2F0aW9uQ29udGV4dDtcblxuICBjb25zdCBjbGllbnQgPSBjb3JlLmdldENsaWVudCgpO1xuICBjb25zdCBpbmNvbWluZ0RzYyA9IGNvcmUuYmFnZ2FnZUhlYWRlclRvRHluYW1pY1NhbXBsaW5nQ29udGV4dChiYWdnYWdlKTtcblxuICAvLyBXZSBvbmx5IHdhbnQgdG8gc2V0IHRoZSB2aXJ0dWFsIHNwYW4gaWYgd2UgYXJlIGNvbnRpbnVpbmcgYSBjb25jcmV0ZSB0cmFjZVxuICAvLyBPdGhlcndpc2UsIHdlIGlnbm9yZSB0aGUgaW5jb21pbmcgdHJhY2UgaGVyZSwgZS5nLiBpZiB3ZSBoYXZlIG5vIHRyYWNlIGhlYWRlcnNcbiAgaWYgKCFwYXJlbnRTcGFuSWQgfHwgKGNsaWVudCAmJiAhY29yZS5zaG91bGRDb250aW51ZVRyYWNlKGNsaWVudCwgaW5jb21pbmdEc2M/Lm9yZ19pZCkpKSB7XG4gICAgcmV0dXJuIGN0eDtcbiAgfVxuXG4gIGNvbnN0IHNwYW5Db250ZXh0ID0gZ2VuZXJhdGVSZW1vdGVTcGFuQ29udGV4dCh7XG4gICAgdHJhY2VJZCxcbiAgICBzcGFuSWQ6IHBhcmVudFNwYW5JZCxcbiAgICBzYW1wbGVkLFxuICAgIGRzYyxcbiAgfSk7XG5cbiAgcmV0dXJuIGFwaS50cmFjZS5zZXRTcGFuQ29udGV4dChjdHgsIHNwYW5Db250ZXh0KTtcbn1cblxuLyoqXG4gKiBUYWtlcyB0cmFjZSBzdHJpbmdzIGFuZCBwcm9wYWdhdGVzIHRoZW0gYXMgYSByZW1vdGUgYWN0aXZlIHNwYW4uXG4gKiBUaGlzIHNob3VsZCBiZSB1c2VkIGluIGFkZGl0aW9uIHRvIGBjb250aW51ZVRyYWNlYCBpbiBPVEVMLXBvd2VyZWQgZW52aXJvbm1lbnRzLlxuICovXG5mdW5jdGlvbiBjb250aW51ZVRyYWNlQXNSZW1vdGVTcGFuKFxuICBjdHgsXG4gIG9wdGlvbnMsXG4gIGNhbGxiYWNrLFxuKSB7XG4gIGNvbnN0IGN0eFdpdGhTcGFuQ29udGV4dCA9IGVuc3VyZVNjb3Blc09uQ29udGV4dChnZXRDb250ZXh0V2l0aFJlbW90ZUFjdGl2ZVNwYW4oY3R4LCBvcHRpb25zKSk7XG5cbiAgcmV0dXJuIGFwaS5jb250ZXh0LndpdGgoY3R4V2l0aFNwYW5Db250ZXh0LCBjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGVuc3VyZVNjb3Blc09uQ29udGV4dChjdHgpIHtcbiAgLy8gSWYgdGhlcmUgYXJlIG5vIHNjb3BlcyB5ZXQgb24gdGhlIGNvbnRleHQsIGVuc3VyZSB3ZSBoYXZlIHRoZW1cbiAgY29uc3Qgc2NvcGVzID0gZ2V0U2NvcGVzRnJvbUNvbnRleHQoY3R4KTtcbiAgY29uc3QgbmV3U2NvcGVzID0ge1xuICAgIC8vIElmIHdlIGhhdmUgbm8gc2NvcGUgaGVyZSwgdGhpcyBpcyBtb3N0IGxpa2VseSBlaXRoZXIgdGhlIHJvb3QgY29udGV4dCBvciBhIGNvbnRleHQgbWFudWFsbHkgZGVyaXZlZCBmcm9tIGl0XG4gICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSB3YW50IHRvIGZvcmsgdGhlIGN1cnJlbnQgc2NvcGUsIHRvIGVuc3VyZSB3ZSBkbyBub3QgcG9sbHV0ZSB0aGUgcm9vdCBzY29wZVxuICAgIHNjb3BlOiBzY29wZXMgPyBzY29wZXMuc2NvcGUgOiBjb3JlLmdldEN1cnJlbnRTY29wZSgpLmNsb25lKCksXG4gICAgaXNvbGF0aW9uU2NvcGU6IHNjb3BlcyA/IHNjb3Blcy5pc29sYXRpb25TY29wZSA6IGNvcmUuZ2V0SXNvbGF0aW9uU2NvcGUoKSxcbiAgfTtcblxuICByZXR1cm4gc2V0U2NvcGVzT25Db250ZXh0KGN0eCwgbmV3U2NvcGVzKTtcbn1cblxuLyoqIFRyeSB0byBnZXQgdGhlIGV4aXN0aW5nIGJhZ2dhZ2UgaGVhZGVyIHNvIHdlIGNhbiBtZXJnZSB0aGlzIGluLiAqL1xuZnVuY3Rpb24gZ2V0RXhpc3RpbmdCYWdnYWdlKGNhcnJpZXIpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBiYWdnYWdlID0gKGNhcnJpZXIgKVtTRU5UUllfQkFHR0FHRV9IRUFERVJdO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGJhZ2dhZ2UpID8gYmFnZ2FnZS5qb2luKCcsJykgOiBiYWdnYWdlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogSXQgaXMgcHJldHR5IHRyaWNreSB0byBnZXQgYWNjZXNzIHRvIHRoZSBvdXRnb2luZyByZXF1ZXN0IFVSTCBvZiBhIHJlcXVlc3QgaW4gdGhlIHByb3BhZ2F0b3IuXG4gKiBBcyB3ZSBvbmx5IGhhdmUgYWNjZXNzIHRvIHRoZSBjb250ZXh0IG9mIHRoZSBzcGFuIHRvIGJlIHNlbnQgYW5kIHRoZSBjYXJyaWVyICg9aGVhZGVycyksXG4gKiBidXQgdGhlIHNwYW4gbWF5IGJlIHVuc2FtcGxlZCBhbmQgdGh1cyBoYXZlIG5vIGF0dHJpYnV0ZXMuXG4gKlxuICogU28gd2UgdXNlIHRoZSBmb2xsb3dpbmcgbG9naWM6XG4gKiAxLiBJZiB3ZSBoYXZlIGFuIGFjdGl2ZSBzcGFuLCB3ZSBjaGVjayBpZiBpdCBoYXMgYSBVUkwgYXR0cmlidXRlLlxuICogMi4gRWxzZSwgaWYgdGhlIGFjdGl2ZSBzcGFuIGhhcyBubyBVUkwgYXR0cmlidXRlIChlLmcuIGl0IGlzIHVuc2FtcGxlZCksIHdlIGNoZWNrIGEgc3BlY2lhbCB0cmFjZSBzdGF0ZSAod2hpY2ggd2Ugc2V0IGluIG91ciBzYW1wbGVyKS5cbiAqL1xuZnVuY3Rpb24gZ2V0Q3VycmVudFVSTChzcGFuKSB7XG4gIGNvbnN0IHNwYW5EYXRhID0gY29yZS5zcGFuVG9KU09OKHNwYW4pLmRhdGE7XG4gIC8vIGBBVFRSX1VSTF9GVUxMYCBpcyB0aGUgbmV3IGF0dHJpYnV0ZSwgYnV0IHdlIHN0aWxsIHN1cHBvcnQgdGhlIG9sZCBvbmUsIGBTRU1BVFRSU19IVFRQX1VSTGAsIGZvciBub3cuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBjb25zdCB1cmxBdHRyaWJ1dGUgPSBzcGFuRGF0YVtzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfVVJMXSB8fCBzcGFuRGF0YVtzZW1hbnRpY0NvbnZlbnRpb25zLkFUVFJfVVJMX0ZVTExdO1xuICBpZiAodHlwZW9mIHVybEF0dHJpYnV0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdXJsQXR0cmlidXRlO1xuICB9XG5cbiAgLy8gQWxzbyBsb29rIGF0IHRoZSB0cmFjZVN0YXRlLCB3aGljaCB3ZSBtYXkgc2V0IGluIHRoZSBzYW1wbGVyIGV2ZW4gZm9yIHVuc2FtcGxlZCBzcGFuc1xuICBjb25zdCB1cmxUcmFjZVN0YXRlID0gc3Bhbi5zcGFuQ29udGV4dCgpLnRyYWNlU3RhdGU/LmdldChTRU5UUllfVFJBQ0VfU1RBVEVfVVJMKTtcbiAgaWYgKHVybFRyYWNlU3RhdGUpIHtcbiAgICByZXR1cm4gdXJsVHJhY2VTdGF0ZTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlUmVtb3RlU3BhbkNvbnRleHQoe1xuICBzcGFuSWQsXG4gIHRyYWNlSWQsXG4gIHNhbXBsZWQsXG4gIGRzYyxcbn1cblxuKSB7XG4gIC8vIFdlIHN0b3JlIHRoZSBEU0MgYXMgT1RFTCB0cmFjZSBzdGF0ZSBvbiB0aGUgc3BhbiBjb250ZXh0XG4gIGNvbnN0IHRyYWNlU3RhdGUgPSBtYWtlVHJhY2VTdGF0ZSh7XG4gICAgZHNjLFxuICAgIHNhbXBsZWQsXG4gIH0pO1xuXG4gIGNvbnN0IHNwYW5Db250ZXh0ID0ge1xuICAgIHRyYWNlSWQsXG4gICAgc3BhbklkLFxuICAgIGlzUmVtb3RlOiB0cnVlLFxuICAgIHRyYWNlRmxhZ3M6IHNhbXBsZWQgPyBhcGkuVHJhY2VGbGFncy5TQU1QTEVEIDogYXBpLlRyYWNlRmxhZ3MuTk9ORSxcbiAgICB0cmFjZVN0YXRlLFxuICB9O1xuXG4gIHJldHVybiBzcGFuQ29udGV4dDtcbn1cblxuLyoqXG4gKiBXcmFwcyBhIGZ1bmN0aW9uIHdpdGggYSB0cmFuc2FjdGlvbi9zcGFuIGFuZCBmaW5pc2hlcyB0aGUgc3BhbiBhZnRlciB0aGUgZnVuY3Rpb24gaXMgZG9uZS5cbiAqIFRoZSBjcmVhdGVkIHNwYW4gaXMgdGhlIGFjdGl2ZSBzcGFuIGFuZCB3aWxsIGJlIHVzZWQgYXMgcGFyZW50IGJ5IG90aGVyIHNwYW5zIGNyZWF0ZWQgaW5zaWRlIHRoZSBmdW5jdGlvblxuICogYW5kIGNhbiBiZSBhY2Nlc3NlZCB2aWEgYFNlbnRyeS5nZXRBY3RpdmVTcGFuKClgLCBhcyBsb25nIGFzIHRoZSBmdW5jdGlvbiBpcyBleGVjdXRlZCB3aGlsZSB0aGUgc2NvcGUgaXMgYWN0aXZlLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIGNyZWF0ZSBhIHNwYW4gdGhhdCBpcyBub3Qgc2V0IGFzIGFjdGl2ZSwgdXNlIHtAbGluayBzdGFydEluYWN0aXZlU3Bhbn0uXG4gKlxuICogWW91J2xsIGFsd2F5cyBnZXQgYSBzcGFuIHBhc3NlZCB0byB0aGUgY2FsbGJhY2ssXG4gKiBpdCBtYXkganVzdCBiZSBhIG5vbi1yZWNvcmRpbmcgc3BhbiBpZiB0aGUgc3BhbiBpcyBub3Qgc2FtcGxlZCBvciBpZiB0cmFjaW5nIGlzIGRpc2FibGVkLlxuICovXG5mdW5jdGlvbiBzdGFydFNwYW4ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKCk7XG5cbiAgY29uc3QgeyBuYW1lLCBwYXJlbnRTcGFuOiBjdXN0b21QYXJlbnRTcGFuIH0gPSBvcHRpb25zO1xuXG4gIC8vIElmIGBvcHRpb25zLnBhcmVudFNwYW5gIGlzIGRlZmluZWQsIHdlIHdhbnQgdG8gd3JhcCB0aGUgY2FsbGJhY2sgaW4gYHdpdGhBY3RpdmVTcGFuYFxuICBjb25zdCB3cmFwcGVyID0gZ2V0QWN0aXZlU3BhbldyYXBwZXIoY3VzdG9tUGFyZW50U3Bhbik7XG5cbiAgcmV0dXJuIHdyYXBwZXIoKCkgPT4ge1xuICAgIGNvbnN0IGFjdGl2ZUN0eCA9IGdldENvbnRleHQob3B0aW9ucy5zY29wZSwgb3B0aW9ucy5mb3JjZVRyYW5zYWN0aW9uKTtcbiAgICBjb25zdCBzaG91bGRTa2lwU3BhbiA9IG9wdGlvbnMub25seUlmUGFyZW50ICYmICFhcGkudHJhY2UuZ2V0U3BhbihhY3RpdmVDdHgpO1xuICAgIGNvbnN0IGN0eCA9IHNob3VsZFNraXBTcGFuID8gY29yZSQxLnN1cHByZXNzVHJhY2luZyhhY3RpdmVDdHgpIDogYWN0aXZlQ3R4O1xuXG4gICAgY29uc3Qgc3Bhbk9wdGlvbnMgPSBnZXRTcGFuT3B0aW9ucyhvcHRpb25zKTtcblxuICAgIHJldHVybiB0cmFjZXIuc3RhcnRBY3RpdmVTcGFuKG5hbWUsIHNwYW5PcHRpb25zLCBjdHgsIHNwYW4gPT4ge1xuICAgICAgcmV0dXJuIGNvcmUuaGFuZGxlQ2FsbGJhY2tFcnJvcnMoXG4gICAgICAgICgpID0+IGNhbGxiYWNrKHNwYW4pLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgLy8gT25seSBzZXQgdGhlIHNwYW4gc3RhdHVzIHRvIEVSUk9SIHdoZW4gdGhlcmUgd2Fzbid0IGFueSBzdGF0dXMgc2V0IGJlZm9yZSwgaW4gb3JkZXIgdG8gYXZvaWQgc3RvbXBpbmcgdXNlZnVsIHNwYW4gc3RhdHVzZXNcbiAgICAgICAgICBpZiAoY29yZS5zcGFuVG9KU09OKHNwYW4pLnN0YXR1cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzcGFuLnNldFN0YXR1cyh7IGNvZGU6IGFwaS5TcGFuU3RhdHVzQ29kZS5FUlJPUiB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICgpID0+IHNwYW4uZW5kKCksXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBTaW1pbGFyIHRvIGBTZW50cnkuc3RhcnRTcGFuYC4gV3JhcHMgYSBmdW5jdGlvbiB3aXRoIGEgc3BhbiwgYnV0IGRvZXMgbm90IGZpbmlzaCB0aGUgc3BhblxuICogYWZ0ZXIgdGhlIGZ1bmN0aW9uIGlzIGRvbmUgYXV0b21hdGljYWxseS4gWW91J2xsIGhhdmUgdG8gY2FsbCBgc3Bhbi5lbmQoKWAgbWFudWFsbHkuXG4gKlxuICogVGhlIGNyZWF0ZWQgc3BhbiBpcyB0aGUgYWN0aXZlIHNwYW4gYW5kIHdpbGwgYmUgdXNlZCBhcyBwYXJlbnQgYnkgb3RoZXIgc3BhbnMgY3JlYXRlZCBpbnNpZGUgdGhlIGZ1bmN0aW9uXG4gKiBhbmQgY2FuIGJlIGFjY2Vzc2VkIHZpYSBgU2VudHJ5LmdldEFjdGl2ZVNwYW4oKWAsIGFzIGxvbmcgYXMgdGhlIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIHdoaWxlIHRoZSBzY29wZSBpcyBhY3RpdmUuXG4gKlxuICogWW91J2xsIGFsd2F5cyBnZXQgYSBzcGFuIHBhc3NlZCB0byB0aGUgY2FsbGJhY2ssXG4gKiBpdCBtYXkganVzdCBiZSBhIG5vbi1yZWNvcmRpbmcgc3BhbiBpZiB0aGUgc3BhbiBpcyBub3Qgc2FtcGxlZCBvciBpZiB0cmFjaW5nIGlzIGRpc2FibGVkLlxuICovXG5mdW5jdGlvbiBzdGFydFNwYW5NYW51YWwoXG4gIG9wdGlvbnMsXG4gIGNhbGxiYWNrLFxuKSB7XG4gIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcigpO1xuXG4gIGNvbnN0IHsgbmFtZSwgcGFyZW50U3BhbjogY3VzdG9tUGFyZW50U3BhbiB9ID0gb3B0aW9ucztcblxuICAvLyBJZiBgb3B0aW9ucy5wYXJlbnRTcGFuYCBpcyBkZWZpbmVkLCB3ZSB3YW50IHRvIHdyYXAgdGhlIGNhbGxiYWNrIGluIGB3aXRoQWN0aXZlU3BhbmBcbiAgY29uc3Qgd3JhcHBlciA9IGdldEFjdGl2ZVNwYW5XcmFwcGVyKGN1c3RvbVBhcmVudFNwYW4pO1xuXG4gIHJldHVybiB3cmFwcGVyKCgpID0+IHtcbiAgICBjb25zdCBhY3RpdmVDdHggPSBnZXRDb250ZXh0KG9wdGlvbnMuc2NvcGUsIG9wdGlvbnMuZm9yY2VUcmFuc2FjdGlvbik7XG4gICAgY29uc3Qgc2hvdWxkU2tpcFNwYW4gPSBvcHRpb25zLm9ubHlJZlBhcmVudCAmJiAhYXBpLnRyYWNlLmdldFNwYW4oYWN0aXZlQ3R4KTtcbiAgICBjb25zdCBjdHggPSBzaG91bGRTa2lwU3BhbiA/IGNvcmUkMS5zdXBwcmVzc1RyYWNpbmcoYWN0aXZlQ3R4KSA6IGFjdGl2ZUN0eDtcblxuICAgIGNvbnN0IHNwYW5PcHRpb25zID0gZ2V0U3Bhbk9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICByZXR1cm4gdHJhY2VyLnN0YXJ0QWN0aXZlU3BhbihuYW1lLCBzcGFuT3B0aW9ucywgY3R4LCBzcGFuID0+IHtcbiAgICAgIHJldHVybiBjb3JlLmhhbmRsZUNhbGxiYWNrRXJyb3JzKFxuICAgICAgICAoKSA9PiBjYWxsYmFjayhzcGFuLCAoKSA9PiBzcGFuLmVuZCgpKSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIC8vIE9ubHkgc2V0IHRoZSBzcGFuIHN0YXR1cyB0byBFUlJPUiB3aGVuIHRoZXJlIHdhc24ndCBhbnkgc3RhdHVzIHNldCBiZWZvcmUsIGluIG9yZGVyIHRvIGF2b2lkIHN0b21waW5nIHVzZWZ1bCBzcGFuIHN0YXR1c2VzXG4gICAgICAgICAgaWYgKGNvcmUuc3BhblRvSlNPTihzcGFuKS5zdGF0dXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoeyBjb2RlOiBhcGkuU3BhblN0YXR1c0NvZGUuRVJST1IgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNwYW4uIFRoaXMgc3BhbiBpcyBub3Qgc2V0IGFzIGFjdGl2ZSwgc28gd2lsbCBub3QgZ2V0IGF1dG9tYXRpYyBpbnN0cnVtZW50YXRpb24gc3BhbnNcbiAqIGFzIGNoaWxkcmVuIG9yIGJlIGFibGUgdG8gYmUgYWNjZXNzZWQgdmlhIGBTZW50cnkuZ2V0QWN0aXZlU3BhbigpYC5cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byBjcmVhdGUgYSBzcGFuIHRoYXQgaXMgc2V0IGFzIGFjdGl2ZSwgdXNlIHtAbGluayBzdGFydFNwYW59LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBhbHdheXMgcmV0dXJuIGEgc3BhbixcbiAqIGl0IG1heSBqdXN0IGJlIGEgbm9uLXJlY29yZGluZyBzcGFuIGlmIHRoZSBzcGFuIGlzIG5vdCBzYW1wbGVkIG9yIGlmIHRyYWNpbmcgaXMgZGlzYWJsZWQuXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0SW5hY3RpdmVTcGFuKG9wdGlvbnMpIHtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKCk7XG5cbiAgY29uc3QgeyBuYW1lLCBwYXJlbnRTcGFuOiBjdXN0b21QYXJlbnRTcGFuIH0gPSBvcHRpb25zO1xuXG4gIC8vIElmIGBvcHRpb25zLnBhcmVudFNwYW5gIGlzIGRlZmluZWQsIHdlIHdhbnQgdG8gd3JhcCB0aGUgY2FsbGJhY2sgaW4gYHdpdGhBY3RpdmVTcGFuYFxuICBjb25zdCB3cmFwcGVyID0gZ2V0QWN0aXZlU3BhbldyYXBwZXIoY3VzdG9tUGFyZW50U3Bhbik7XG5cbiAgcmV0dXJuIHdyYXBwZXIoKCkgPT4ge1xuICAgIGNvbnN0IGFjdGl2ZUN0eCA9IGdldENvbnRleHQob3B0aW9ucy5zY29wZSwgb3B0aW9ucy5mb3JjZVRyYW5zYWN0aW9uKTtcbiAgICBjb25zdCBzaG91bGRTa2lwU3BhbiA9IG9wdGlvbnMub25seUlmUGFyZW50ICYmICFhcGkudHJhY2UuZ2V0U3BhbihhY3RpdmVDdHgpO1xuICAgIGNvbnN0IGN0eCA9IHNob3VsZFNraXBTcGFuID8gY29yZSQxLnN1cHByZXNzVHJhY2luZyhhY3RpdmVDdHgpIDogYWN0aXZlQ3R4O1xuXG4gICAgY29uc3Qgc3Bhbk9wdGlvbnMgPSBnZXRTcGFuT3B0aW9ucyhvcHRpb25zKTtcblxuICAgIGNvbnN0IHNwYW4gPSB0cmFjZXIuc3RhcnRTcGFuKG5hbWUsIHNwYW5PcHRpb25zLCBjdHgpO1xuXG4gICAgcmV0dXJuIHNwYW47XG4gIH0pO1xufVxuXG4vKipcbiAqIEZvcmtzIHRoZSBjdXJyZW50IHNjb3BlIGFuZCBzZXRzIHRoZSBwcm92aWRlZCBzcGFuIGFzIGFjdGl2ZSBzcGFuIGluIHRoZSBjb250ZXh0IG9mIHRoZSBwcm92aWRlZCBjYWxsYmFjay4gQ2FuIGJlXG4gKiBwYXNzZWQgYG51bGxgIHRvIHN0YXJ0IGFuIGVudGlyZWx5IG5ldyBzcGFuIHRyZWUuXG4gKlxuICogQHBhcmFtIHNwYW4gU3BhbnMgc3RhcnRlZCBpbiB0aGUgY29udGV4dCBvZiB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgd2lsbCBiZSBjaGlsZHJlbiBvZiB0aGlzIHNwYW4uIElmIGBudWxsYCBpcyBwYXNzZWQsXG4gKiBzcGFucyBzdGFydGVkIHdpdGhpbiB0aGUgY2FsbGJhY2sgd2lsbCBiZSByb290IHNwYW5zLlxuICogQHBhcmFtIGNhbGxiYWNrIEV4ZWN1dGlvbiBjb250ZXh0IGluIHdoaWNoIHRoZSBwcm92aWRlZCBzcGFuIHdpbGwgYmUgYWN0aXZlLiBJcyBwYXNzZWQgdGhlIG5ld2x5IGZvcmtlZCBzY29wZS5cbiAqIEByZXR1cm5zIHRoZSB2YWx1ZSByZXR1cm5lZCBmcm9tIHRoZSBwcm92aWRlZCBjYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gd2l0aEFjdGl2ZVNwYW4oc3BhbiwgY2FsbGJhY2spIHtcbiAgY29uc3QgbmV3Q29udGV4dFdpdGhBY3RpdmVTcGFuID0gc3BhbiA/IGFwaS50cmFjZS5zZXRTcGFuKGFwaS5jb250ZXh0LmFjdGl2ZSgpLCBzcGFuKSA6IGFwaS50cmFjZS5kZWxldGVTcGFuKGFwaS5jb250ZXh0LmFjdGl2ZSgpKTtcbiAgcmV0dXJuIGFwaS5jb250ZXh0LndpdGgobmV3Q29udGV4dFdpdGhBY3RpdmVTcGFuLCAoKSA9PiBjYWxsYmFjayhjb3JlLmdldEN1cnJlbnRTY29wZSgpKSk7XG59XG5cbmZ1bmN0aW9uIGdldFRyYWNlcigpIHtcbiAgY29uc3QgY2xpZW50ID0gY29yZS5nZXRDbGllbnQoKTtcbiAgcmV0dXJuIGNsaWVudD8udHJhY2VyIHx8IGFwaS50cmFjZS5nZXRUcmFjZXIoJ0BzZW50cnkvb3BlbnRlbGVtZXRyeScsIGNvcmUuU0RLX1ZFUlNJT04pO1xufVxuXG5mdW5jdGlvbiBnZXRTcGFuT3B0aW9ucyhvcHRpb25zKSB7XG4gIGNvbnN0IHsgc3RhcnRUaW1lLCBhdHRyaWJ1dGVzLCBraW5kLCBvcCwgbGlua3MgfSA9IG9wdGlvbnM7XG5cbiAgLy8gT1RFTCBleHBlY3RzIHRpbWVzdGFtcHMgaW4gbXMsIG5vdCBzZWNvbmRzXG4gIGNvbnN0IGZpeGVkU3RhcnRUaW1lID0gdHlwZW9mIHN0YXJ0VGltZSA9PT0gJ251bWJlcicgPyBlbnN1cmVUaW1lc3RhbXBJbk1pbGxpc2Vjb25kcyhzdGFydFRpbWUpIDogc3RhcnRUaW1lO1xuXG4gIHJldHVybiB7XG4gICAgYXR0cmlidXRlczogb3BcbiAgICAgID8ge1xuICAgICAgICAgIFtjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1BdOiBvcCxcbiAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICB9XG4gICAgICA6IGF0dHJpYnV0ZXMsXG4gICAga2luZCxcbiAgICBsaW5rcyxcbiAgICBzdGFydFRpbWU6IGZpeGVkU3RhcnRUaW1lLFxuICB9O1xufVxuXG5mdW5jdGlvbiBlbnN1cmVUaW1lc3RhbXBJbk1pbGxpc2Vjb25kcyh0aW1lc3RhbXApIHtcbiAgY29uc3QgaXNNcyA9IHRpbWVzdGFtcCA8IDk5OTk5OTk5OTk7XG4gIHJldHVybiBpc01zID8gdGltZXN0YW1wICogMTAwMCA6IHRpbWVzdGFtcDtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGV4dChzY29wZSwgZm9yY2VUcmFuc2FjdGlvbikge1xuICBjb25zdCBjdHggPSBnZXRDb250ZXh0Rm9yU2NvcGUoc2NvcGUpO1xuICBjb25zdCBwYXJlbnRTcGFuID0gYXBpLnRyYWNlLmdldFNwYW4oY3R4KTtcblxuICAvLyBJbiB0aGUgY2FzZSB0aGF0IHdlIGhhdmUgbm8gcGFyZW50IHNwYW4sIHdlIHN0YXJ0IGEgbmV3IHRyYWNlXG4gIC8vIE5vdGUgdGhhdCBpZiB3ZSBjb250aW51ZSBhIHRyYWNlLCB3ZSdsbCBhbHdheXMgaGF2ZSBhIHJlbW90ZSBwYXJlbnQgc3BhbiBoZXJlIGFueWhvd1xuICBpZiAoIXBhcmVudFNwYW4pIHtcbiAgICByZXR1cm4gY3R4O1xuICB9XG5cbiAgLy8gSWYgd2UgZG9uJ3Qgd2FudCB0byBmb3JjZSBhIHRyYW5zYWN0aW9uLCBhbmQgd2UgaGF2ZSBhIHBhcmVudCBzcGFuLCBhbGwgZ29vZCwgd2UganVzdCByZXR1cm4gYXMtaXMhXG4gIGlmICghZm9yY2VUcmFuc2FjdGlvbikge1xuICAgIHJldHVybiBjdHg7XG4gIH1cblxuICAvLyBFbHNlLCBpZiB3ZSBkbyBoYXZlIGEgcGFyZW50IHNwYW4gYnV0IHdhbnQgdG8gZm9yY2UgYSB0cmFuc2FjdGlvbiwgd2UgaGF2ZSB0byBzaW11bGF0ZSBhIFwicm9vdFwiIGNvbnRleHRcblxuICAvLyBFbHNlLCB3ZSBuZWVkIHRvIGRvIHR3byB0aGluZ3M6XG4gIC8vIDEuIFVuc2V0IHRoZSBwYXJlbnQgc3BhbiBmcm9tIHRoZSBjb250ZXh0LCBzbyB3ZSdsbCBjcmVhdGUgYSBuZXcgcm9vdCBzcGFuXG4gIC8vIDIuIEVuc3VyZSB0aGUgcHJvcGFnYXRpb24gY29udGV4dCBpcyBjb3JyZWN0LCBzbyB3ZSdsbCBjb250aW51ZSBmcm9tIHRoZSBwYXJlbnQgc3BhblxuICBjb25zdCBjdHhXaXRob3V0U3BhbiA9IGFwaS50cmFjZS5kZWxldGVTcGFuKGN0eCk7XG5cbiAgY29uc3QgeyBzcGFuSWQsIHRyYWNlSWQgfSA9IHBhcmVudFNwYW4uc3BhbkNvbnRleHQoKTtcbiAgY29uc3Qgc2FtcGxlZCA9IGdldFNhbXBsaW5nRGVjaXNpb24ocGFyZW50U3Bhbi5zcGFuQ29udGV4dCgpKTtcblxuICAvLyBJbiB0aGlzIGNhc2UsIHdoZW4gd2UgYXJlIGZvcmNpbmcgYSB0cmFuc2FjdGlvbiwgd2Ugd2FudCB0byB0cmVhdCB0aGlzIGxpa2UgY29udGludWluZyBhbiBpbmNvbWluZyB0cmFjZVxuICAvLyBzbyB3ZSBzZXQgdGhlIHRyYWNlU3RhdGUgYWNjb3JkaW5nIHRvIHRoZSByb290IHNwYW5cbiAgY29uc3Qgcm9vdFNwYW4gPSBjb3JlLmdldFJvb3RTcGFuKHBhcmVudFNwYW4pO1xuICBjb25zdCBkc2MgPSBjb3JlLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3Bhbihyb290U3Bhbik7XG5cbiAgY29uc3QgdHJhY2VTdGF0ZSA9IG1ha2VUcmFjZVN0YXRlKHtcbiAgICBkc2MsXG4gICAgc2FtcGxlZCxcbiAgfSk7XG5cbiAgY29uc3Qgc3Bhbk9wdGlvbnMgPSB7XG4gICAgdHJhY2VJZCxcbiAgICBzcGFuSWQsXG4gICAgaXNSZW1vdGU6IHRydWUsXG4gICAgdHJhY2VGbGFnczogc2FtcGxlZCA/IGFwaS5UcmFjZUZsYWdzLlNBTVBMRUQgOiBhcGkuVHJhY2VGbGFncy5OT05FLFxuICAgIHRyYWNlU3RhdGUsXG4gIH07XG5cbiAgY29uc3QgY3R4V2l0aFNwYW5Db250ZXh0ID0gYXBpLnRyYWNlLnNldFNwYW5Db250ZXh0KGN0eFdpdGhvdXRTcGFuLCBzcGFuT3B0aW9ucyk7XG5cbiAgcmV0dXJuIGN0eFdpdGhTcGFuQ29udGV4dDtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGV4dEZvclNjb3BlKHNjb3BlKSB7XG4gIGlmIChzY29wZSkge1xuICAgIGNvbnN0IGN0eCA9IGdldENvbnRleHRGcm9tU2NvcGUoc2NvcGUpO1xuICAgIGlmIChjdHgpIHtcbiAgICAgIHJldHVybiBjdHg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFwaS5jb250ZXh0LmFjdGl2ZSgpO1xufVxuXG4vKipcbiAqIENvbnRpbnVlIGEgdHJhY2UgZnJvbSBgc2VudHJ5LXRyYWNlYCBhbmQgYGJhZ2dhZ2VgIHZhbHVlcy5cbiAqIFRoZXNlIHZhbHVlcyBjYW4gYmUgb2J0YWluZWQgZnJvbSBpbmNvbWluZyByZXF1ZXN0IGhlYWRlcnMsIG9yIGluIHRoZSBicm93c2VyIGZyb20gYDxtZXRhIG5hbWU9XCJzZW50cnktdHJhY2VcIj5gXG4gKiBhbmQgYDxtZXRhIG5hbWU9XCJiYWdnYWdlXCI+YCBIVE1MIHRhZ3MuXG4gKlxuICogU3BhbnMgc3RhcnRlZCB3aXRoIGBzdGFydFNwYW5gLCBgc3RhcnRTcGFuTWFudWFsYCBhbmQgYHN0YXJ0SW5hY3RpdmVTcGFuYCwgd2l0aGluIHRoZSBjYWxsYmFjayB3aWxsIGF1dG9tYXRpY2FsbHlcbiAqIGJlIGF0dGFjaGVkIHRvIHRoZSBpbmNvbWluZyB0cmFjZS5cbiAqXG4gKiBUaGlzIGlzIGEgY3VzdG9tIHZlcnNpb24gb2YgYGNvbnRpbnVlVHJhY2VgIHRoYXQgaXMgdXNlZCBpbiBPVEVMLXBvd2VyZWQgZW52aXJvbm1lbnRzLlxuICogSXQgcHJvcGFnYXRlcyB0aGUgdHJhY2UgYXMgYSByZW1vdGUgc3BhbiwgaW4gYWRkaXRpb24gdG8gc2V0dGluZyBpdCBvbiB0aGUgcHJvcGFnYXRpb24gY29udGV4dC5cbiAqL1xuZnVuY3Rpb24gY29udGludWVUcmFjZShvcHRpb25zLCBjYWxsYmFjaykge1xuICByZXR1cm4gY29udGludWVUcmFjZUFzUmVtb3RlU3BhbihhcGkuY29udGV4dC5hY3RpdmUoKSwgb3B0aW9ucywgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIEdldCB0aGUgdHJhY2UgY29udGV4dCBmb3IgYSBnaXZlbiBzY29wZS5cbiAqIFdlIGhhdmUgYSBjdXN0b20gaW1wbGVtZW50YXRpb24gaGVyZSBiZWNhdXNlIHdlIG5lZWQgYW4gT1RFTC1zcGVjaWZpYyB3YXkgdG8gZ2V0IHRoZSBzcGFuIGZyb20gYSBzY29wZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VHJhY2VDb250ZXh0Rm9yU2NvcGUoXG4gIGNsaWVudCxcbiAgc2NvcGUsXG4pIHtcbiAgY29uc3QgY3R4ID0gZ2V0Q29udGV4dEZyb21TY29wZShzY29wZSk7XG4gIGNvbnN0IHNwYW4gPSBjdHggJiYgYXBpLnRyYWNlLmdldFNwYW4oY3R4KTtcblxuICBjb25zdCB0cmFjZUNvbnRleHQgPSBzcGFuID8gY29yZS5zcGFuVG9UcmFjZUNvbnRleHQoc3BhbikgOiBjb3JlLmdldFRyYWNlQ29udGV4dEZyb21TY29wZShzY29wZSk7XG5cbiAgY29uc3QgZHluYW1pY1NhbXBsaW5nQ29udGV4dCA9IHNwYW5cbiAgICA/IGNvcmUuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuKHNwYW4pXG4gICAgOiBjb3JlLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU2NvcGUoY2xpZW50LCBzY29wZSk7XG4gIHJldHVybiBbZHluYW1pY1NhbXBsaW5nQ29udGV4dCwgdHJhY2VDb250ZXh0XTtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0aXZlU3BhbldyYXBwZXIocGFyZW50U3Bhbikge1xuICByZXR1cm4gcGFyZW50U3BhbiAhPT0gdW5kZWZpbmVkXG4gICAgPyAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgcmV0dXJuIHdpdGhBY3RpdmVTcGFuKHBhcmVudFNwYW4sIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICA6IChjYWxsYmFjaykgPT4gY2FsbGJhY2soKTtcbn1cblxuLyoqIFN1cHByZXNzIHRyYWNpbmcgaW4gdGhlIGdpdmVuIGNhbGxiYWNrLCBlbnN1cmluZyBubyBzcGFucyBhcmUgZ2VuZXJhdGVkIGluc2lkZSBvZiBpdC4gKi9cbmZ1bmN0aW9uIHN1cHByZXNzVHJhY2luZyhjYWxsYmFjaykge1xuICBjb25zdCBjdHggPSBjb3JlJDEuc3VwcHJlc3NUcmFjaW5nKGFwaS5jb250ZXh0LmFjdGl2ZSgpKTtcbiAgcmV0dXJuIGFwaS5jb250ZXh0LndpdGgoY3R4LCBjYWxsYmFjayk7XG59XG5cbi8qKiBFbnN1cmUgdGhlIGB0cmFjZWAgY29udGV4dCBpcyBzZXQgb24gYWxsIGV2ZW50cy4gKi9cbmZ1bmN0aW9uIHNldHVwRXZlbnRDb250ZXh0VHJhY2UoY2xpZW50KSB7XG4gIGNsaWVudC5vbigncHJlcHJvY2Vzc0V2ZW50JywgZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNwYW4gPSBnZXRBY3RpdmVTcGFuKCk7XG4gICAgLy8gRm9yIHRyYW5zYWN0aW9uIGV2ZW50cywgdGhpcyBpcyBoYW5kbGVkIHNlcGFyYXRlbHlcbiAgICAvLyBCZWNhdXNlIHRoZSBhY3RpdmUgc3BhbiBtYXkgbm90IGJlIHRoZSBzcGFuIHRoYXQgaXMgYWN0dWFsbHkgdGhlIHRyYW5zYWN0aW9uIGV2ZW50XG4gICAgaWYgKCFzcGFuIHx8IGV2ZW50LnR5cGUgPT09ICd0cmFuc2FjdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBldmVudCBoYXMgYWxyZWFkeSBzZXQgYHRyYWNlYCBjb250ZXh0LCB1c2UgdGhhdCBvbmUuXG4gICAgZXZlbnQuY29udGV4dHMgPSB7XG4gICAgICB0cmFjZTogY29yZS5zcGFuVG9UcmFjZUNvbnRleHQoc3BhbiksXG4gICAgICAuLi5ldmVudC5jb250ZXh0cyxcbiAgICB9O1xuXG4gICAgY29uc3Qgcm9vdFNwYW4gPSBjb3JlLmdldFJvb3RTcGFuKHNwYW4pO1xuXG4gICAgZXZlbnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhID0ge1xuICAgICAgZHluYW1pY1NhbXBsaW5nQ29udGV4dDogY29yZS5nZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW4ocm9vdFNwYW4pLFxuICAgICAgLi4uZXZlbnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhLFxuICAgIH07XG5cbiAgICByZXR1cm4gZXZlbnQ7XG4gIH0pO1xufVxuXG4vKipcbiAqIE90ZWwtc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gb2YgYGdldFRyYWNlRGF0YWAuXG4gKiBAc2VlIGBAc2VudHJ5L2NvcmVgIHZlcnNpb24gb2YgYGdldFRyYWNlRGF0YWAgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0VHJhY2VEYXRhKHtcbiAgc3BhbixcbiAgc2NvcGUsXG4gIGNsaWVudCxcbn0gPSB7fSkge1xuICBsZXQgY3R4ID0gKHNjb3BlICYmIGdldENvbnRleHRGcm9tU2NvcGUoc2NvcGUpKSA/PyBhcGkuY29udGV4dC5hY3RpdmUoKTtcblxuICBpZiAoc3Bhbikge1xuICAgIGNvbnN0IHsgc2NvcGUgfSA9IGNvcmUuZ2V0Q2FwdHVyZWRTY29wZXNPblNwYW4oc3Bhbik7XG4gICAgLy8gZmFsbCBiYWNrIHRvIGN1cnJlbnQgY29udGV4dCBpZiBmb3Igd2hhdGV2ZXIgcmVhc29uIHdlIGNhbid0IGZpbmQgdGhlIG9uZSBvZiB0aGUgc3BhblxuICAgIGN0eCA9IChzY29wZSAmJiBnZXRDb250ZXh0RnJvbVNjb3BlKHNjb3BlKSkgfHwgYXBpLnRyYWNlLnNldFNwYW4oYXBpLmNvbnRleHQuYWN0aXZlKCksIHNwYW4pO1xuICB9XG5cbiAgY29uc3QgeyB0cmFjZUlkLCBzcGFuSWQsIHNhbXBsZWQsIGR5bmFtaWNTYW1wbGluZ0NvbnRleHQgfSA9IGdldEluamVjdGlvbkRhdGEoY3R4LCB7IHNjb3BlLCBjbGllbnQgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICAnc2VudHJ5LXRyYWNlJzogY29yZS5nZW5lcmF0ZVNlbnRyeVRyYWNlSGVhZGVyKHRyYWNlSWQsIHNwYW5JZCwgc2FtcGxlZCksXG4gICAgYmFnZ2FnZTogY29yZS5keW5hbWljU2FtcGxpbmdDb250ZXh0VG9TZW50cnlCYWdnYWdlSGVhZGVyKGR5bmFtaWNTYW1wbGluZ0NvbnRleHQpLFxuICB9O1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGFzeW5jIGNvbnRleHQgc3RyYXRlZ3kgdG8gdXNlIGZvbGxvdyB0aGUgT1RFTCBjb250ZXh0IHVuZGVyIHRoZSBob29kLlxuICogV2UgaGFuZGxlIGZvcmtpbmcgYSBodWIgaW5zaWRlIG9mIG91ciBjdXN0b20gT1RFTCBDb250ZXh0IE1hbmFnZXIgKC4vb3RlbENvbnRleHRNYW5hZ2VyLnRzKVxuICovXG5mdW5jdGlvbiBzZXRPcGVuVGVsZW1ldHJ5Q29udGV4dEFzeW5jQ29udGV4dFN0cmF0ZWd5KCkge1xuICBmdW5jdGlvbiBnZXRTY29wZXMoKSB7XG4gICAgY29uc3QgY3R4ID0gYXBpLmNvbnRleHQuYWN0aXZlKCk7XG4gICAgY29uc3Qgc2NvcGVzID0gZ2V0U2NvcGVzRnJvbUNvbnRleHQoY3R4KTtcblxuICAgIGlmIChzY29wZXMpIHtcbiAgICAgIHJldHVybiBzY29wZXM7XG4gICAgfVxuXG4gICAgLy8gZmFsbGJhY2sgYmVoYXZpb3I6XG4gICAgLy8gaWYsIGZvciB3aGF0ZXZlciByZWFzb24sIHdlIGNhbid0IGZpbmQgc2NvcGVzIG9uIHRoZSBjb250ZXh0IGhlcmUsIHdlIGhhdmUgdG8gZml4IHRoaXMgc29tZWhvd1xuICAgIHJldHVybiB7XG4gICAgICBzY29wZTogY29yZS5nZXREZWZhdWx0Q3VycmVudFNjb3BlKCksXG4gICAgICBpc29sYXRpb25TY29wZTogY29yZS5nZXREZWZhdWx0SXNvbGF0aW9uU2NvcGUoKSxcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd2l0aFNjb3BlKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgY3R4ID0gYXBpLmNvbnRleHQuYWN0aXZlKCk7XG5cbiAgICAvLyBXZSBkZXBlbmQgb24gdGhlIG90ZWxDb250ZXh0TWFuYWdlciB0byBoYW5kbGUgdGhlIGNvbnRleHQvaHViXG4gICAgLy8gV2Ugc2V0IHRoZSBgU0VOVFJZX0ZPUktfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZYCBjb250ZXh0IHZhbHVlLCB3aGljaCBpcyBwaWNrZWQgdXAgYnlcbiAgICAvLyB0aGUgT1RFTCBjb250ZXh0IG1hbmFnZXIsIHdoaWNoIHVzZXMgdGhlIHByZXNlbmNlIG9mIHRoaXMga2V5IHRvIGRldGVybWluZSBpZiBpdCBzaG91bGRcbiAgICAvLyBmb3JrIHRoZSBpc29sYXRpb24gc2NvcGUsIG9yIG5vdFxuICAgIC8vIGFzIGJ5IGRlZmF1bHQsIHdlIGRvbid0IHdhbnQgdG8gZm9yayB0aGlzLCB1bmxlc3MgdHJpZ2dlcmVkIGV4cGxpY2l0bHkgYnkgYHdpdGhTY29wZWBcbiAgICByZXR1cm4gYXBpLmNvbnRleHQud2l0aChjdHgsICgpID0+IHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhnZXRDdXJyZW50U2NvcGUoKSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB3aXRoU2V0U2NvcGUoc2NvcGUsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgY3R4ID0gZ2V0Q29udGV4dEZyb21TY29wZShzY29wZSkgfHwgYXBpLmNvbnRleHQuYWN0aXZlKCk7XG5cbiAgICAvLyBXZSBkZXBlbmQgb24gdGhlIG90ZWxDb250ZXh0TWFuYWdlciB0byBoYW5kbGUgdGhlIGNvbnRleHQvaHViXG4gICAgLy8gV2Ugc2V0IHRoZSBgU0VOVFJZX0ZPUktfU0VUX1NDT1BFX0NPTlRFWFRfS0VZYCBjb250ZXh0IHZhbHVlLCB3aGljaCBpcyBwaWNrZWQgdXAgYnlcbiAgICAvLyB0aGUgT1RFTCBjb250ZXh0IG1hbmFnZXIsIHdoaWNoIHBpY2tzIHVwIHRoaXMgc2NvcGUgYXMgdGhlIGN1cnJlbnQgc2NvcGVcbiAgICByZXR1cm4gYXBpLmNvbnRleHQud2l0aChjdHguc2V0VmFsdWUoU0VOVFJZX0ZPUktfU0VUX1NDT1BFX0NPTlRFWFRfS0VZLCBzY29wZSksICgpID0+IHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhzY29wZSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB3aXRoSXNvbGF0aW9uU2NvcGUoY2FsbGJhY2spIHtcbiAgICBjb25zdCBjdHggPSBhcGkuY29udGV4dC5hY3RpdmUoKTtcblxuICAgIC8vIFdlIGRlcGVuZCBvbiB0aGUgb3RlbENvbnRleHRNYW5hZ2VyIHRvIGhhbmRsZSB0aGUgY29udGV4dC9odWJcbiAgICAvLyBXZSBzZXQgdGhlIGBTRU5UUllfRk9SS19JU09MQVRJT05fU0NPUEVfQ09OVEVYVF9LRVlgIGNvbnRleHQgdmFsdWUsIHdoaWNoIGlzIHBpY2tlZCB1cCBieVxuICAgIC8vIHRoZSBPVEVMIGNvbnRleHQgbWFuYWdlciwgd2hpY2ggdXNlcyB0aGUgcHJlc2VuY2Ugb2YgdGhpcyBrZXkgdG8gZGV0ZXJtaW5lIGlmIGl0IHNob3VsZFxuICAgIC8vIGZvcmsgdGhlIGlzb2xhdGlvbiBzY29wZSwgb3Igbm90XG4gICAgcmV0dXJuIGFwaS5jb250ZXh0LndpdGgoY3R4LnNldFZhbHVlKFNFTlRSWV9GT1JLX0lTT0xBVElPTl9TQ09QRV9DT05URVhUX0tFWSwgdHJ1ZSksICgpID0+IHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhnZXRJc29sYXRpb25TY29wZSgpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpdGhTZXRJc29sYXRpb25TY29wZShpc29sYXRpb25TY29wZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBjdHggPSBhcGkuY29udGV4dC5hY3RpdmUoKTtcblxuICAgIC8vIFdlIGRlcGVuZCBvbiB0aGUgb3RlbENvbnRleHRNYW5hZ2VyIHRvIGhhbmRsZSB0aGUgY29udGV4dC9odWJcbiAgICAvLyBXZSBzZXQgdGhlIGBTRU5UUllfRk9SS19JU09MQVRJT05fU0NPUEVfQ09OVEVYVF9LRVlgIGNvbnRleHQgdmFsdWUsIHdoaWNoIGlzIHBpY2tlZCB1cCBieVxuICAgIC8vIHRoZSBPVEVMIGNvbnRleHQgbWFuYWdlciwgd2hpY2ggdXNlcyB0aGUgcHJlc2VuY2Ugb2YgdGhpcyBrZXkgdG8gZGV0ZXJtaW5lIGlmIGl0IHNob3VsZFxuICAgIC8vIGZvcmsgdGhlIGlzb2xhdGlvbiBzY29wZSwgb3Igbm90XG4gICAgcmV0dXJuIGFwaS5jb250ZXh0LndpdGgoY3R4LnNldFZhbHVlKFNFTlRSWV9GT1JLX1NFVF9JU09MQVRJT05fU0NPUEVfQ09OVEVYVF9LRVksIGlzb2xhdGlvblNjb3BlKSwgKCkgPT4ge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGdldElzb2xhdGlvblNjb3BlKCkpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudFNjb3BlKCkge1xuICAgIHJldHVybiBnZXRTY29wZXMoKS5zY29wZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldElzb2xhdGlvblNjb3BlKCkge1xuICAgIHJldHVybiBnZXRTY29wZXMoKS5pc29sYXRpb25TY29wZTtcbiAgfVxuXG4gIGNvcmUuc2V0QXN5bmNDb250ZXh0U3RyYXRlZ3koe1xuICAgIHdpdGhTY29wZSxcbiAgICB3aXRoU2V0U2NvcGUsXG4gICAgd2l0aFNldElzb2xhdGlvblNjb3BlLFxuICAgIHdpdGhJc29sYXRpb25TY29wZSxcbiAgICBnZXRDdXJyZW50U2NvcGUsXG4gICAgZ2V0SXNvbGF0aW9uU2NvcGUsXG4gICAgc3RhcnRTcGFuLFxuICAgIHN0YXJ0U3Bhbk1hbnVhbCxcbiAgICBzdGFydEluYWN0aXZlU3BhbixcbiAgICBnZXRBY3RpdmVTcGFuLFxuICAgIHN1cHByZXNzVHJhY2luZyxcbiAgICBnZXRUcmFjZURhdGEsXG4gICAgY29udGludWVUcmFjZSxcbiAgICAvLyBUaGUgdHlwZXMgaGVyZSBkb24ndCBmdWxseSBhbGlnbiwgYmVjYXVzZSBvdXIgb3duIGBTcGFuYCB0eXBlIGlzIG5hcnJvd2VyXG4gICAgLy8gdGhhbiB0aGUgT1RFTCBvbmUgLSBidXQgdGhpcyBpcyBPSyBmb3IgaGVyZSwgYXMgd2Ugbm93IHdlJ2xsIG9ubHkgaGF2ZSBPVEVMIHNwYW5zIHBhc3NlZCBhcm91bmRcbiAgICB3aXRoQWN0aXZlU3Bhbjogd2l0aEFjdGl2ZVNwYW4gLFxuICB9KTtcbn1cblxuLyoqXG4gKiBXcmFwIGFuIE9wZW5UZWxlbWV0cnkgQ29udGV4dE1hbmFnZXIgaW4gYSB3YXkgdGhhdCBlbnN1cmVzIHRoZSBjb250ZXh0IGlzIGtlcHQgaW4gc3luYyB3aXRoIHRoZSBTZW50cnkgU2NvcGUuXG4gKlxuICogVXNhZ2U6XG4gKiBpbXBvcnQgeyBBc3luY0xvY2FsU3RvcmFnZUNvbnRleHRNYW5hZ2VyIH0gZnJvbSAnQG9wZW50ZWxlbWV0cnkvY29udGV4dC1hc3luYy1ob29rcyc7XG4gKiBjb25zdCBTZW50cnlDb250ZXh0TWFuYWdlciA9IHdyYXBDb250ZXh0TWFuYWdlckNsYXNzKEFzeW5jTG9jYWxTdG9yYWdlQ29udGV4dE1hbmFnZXIpO1xuICogY29uc3QgY29udGV4dE1hbmFnZXIgPSBuZXcgU2VudHJ5Q29udGV4dE1hbmFnZXIoKTtcbiAqL1xuZnVuY3Rpb24gd3JhcENvbnRleHRNYW5hZ2VyQ2xhc3MoXG4gIENvbnRleHRNYW5hZ2VyQ2xhc3MsXG4pIHtcbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBjdXN0b20gQ29udGV4dE1hbmFnZXIgZm9yIE9wZW5UZWxlbWV0cnksIHdoaWNoIGV4dGVuZHMgdGhlIGRlZmF1bHQgQXN5bmNMb2NhbFN0b3JhZ2VDb250ZXh0TWFuYWdlci5cbiAgICogSXQgZW5zdXJlcyB0aGF0IHdlIGNyZWF0ZSBuZXcgc2NvcGVzIHBlciBjb250ZXh0LCBzbyB0aGF0IHRoZSBPVEVMIENvbnRleHQgJiB0aGUgU2VudHJ5IFNjb3BlIGFyZSBhbHdheXMgaW4gc3luYy5cbiAgICpcbiAgICogTm90ZSB0aGF0IHdlIGN1cnJlbnRseSBvbmx5IHN1cHBvcnQgQXN5bmNIb29rcyB3aXRoIHRoaXMsXG4gICAqIGJ1dCBzaW5jZSB0aGlzIHNob3VsZCB3b3JrIGZvciBOb2RlIDE0KyBhbnlob3cgdGhhdCBzaG91bGQgYmUgZ29vZCBlbm91Z2guXG4gICAqL1xuXG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMgZG9lcyBub3QgbGlrZSB0aGlzLCBidXQgd2Uga25vdyB0aGlzIGlzIGZpbmVcbiAgY2xhc3MgU2VudHJ5Q29udGV4dE1hbmFnZXIgZXh0ZW5kcyBDb250ZXh0TWFuYWdlckNsYXNzIHtcbiAgICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICBzZXRJc1NldHVwKCdTZW50cnlDb250ZXh0TWFuYWdlcicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVyd3JpdGUgd2l0aCgpIG9mIHRoZSBvcmlnaW5hbCBBc3luY0xvY2FsU3RvcmFnZUNvbnRleHRNYW5hZ2VyXG4gICAgICogdG8gZW5zdXJlIHdlIGFsc28gY3JlYXRlIG5ldyBzY29wZXMgcGVyIGNvbnRleHQuXG4gICAgICovXG4gICAgIHdpdGgoXG4gICAgICBjb250ZXh0LFxuICAgICAgZm4sXG4gICAgICB0aGlzQXJnLFxuICAgICAgLi4uYXJnc1xuICAgICkge1xuICAgICAgY29uc3QgY3VycmVudFNjb3BlcyA9IGdldFNjb3Blc0Zyb21Db250ZXh0KGNvbnRleHQpO1xuICAgICAgY29uc3QgY3VycmVudFNjb3BlID0gY3VycmVudFNjb3Blcz8uc2NvcGUgfHwgY29yZS5nZXRDdXJyZW50U2NvcGUoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRJc29sYXRpb25TY29wZSA9IGN1cnJlbnRTY29wZXM/Lmlzb2xhdGlvblNjb3BlIHx8IGNvcmUuZ2V0SXNvbGF0aW9uU2NvcGUoKTtcblxuICAgICAgY29uc3Qgc2hvdWxkRm9ya0lzb2xhdGlvblNjb3BlID0gY29udGV4dC5nZXRWYWx1ZShTRU5UUllfRk9SS19JU09MQVRJT05fU0NPUEVfQ09OVEVYVF9LRVkpID09PSB0cnVlO1xuICAgICAgY29uc3Qgc2NvcGUgPSBjb250ZXh0LmdldFZhbHVlKFNFTlRSWV9GT1JLX1NFVF9TQ09QRV9DT05URVhUX0tFWSkgO1xuICAgICAgY29uc3QgaXNvbGF0aW9uU2NvcGUgPSBjb250ZXh0LmdldFZhbHVlKFNFTlRSWV9GT1JLX1NFVF9JU09MQVRJT05fU0NPUEVfQ09OVEVYVF9LRVkpIDtcblxuICAgICAgY29uc3QgbmV3Q3VycmVudFNjb3BlID0gc2NvcGUgfHwgY3VycmVudFNjb3BlLmNsb25lKCk7XG4gICAgICBjb25zdCBuZXdJc29sYXRpb25TY29wZSA9XG4gICAgICAgIGlzb2xhdGlvblNjb3BlIHx8IChzaG91bGRGb3JrSXNvbGF0aW9uU2NvcGUgPyBjdXJyZW50SXNvbGF0aW9uU2NvcGUuY2xvbmUoKSA6IGN1cnJlbnRJc29sYXRpb25TY29wZSk7XG4gICAgICBjb25zdCBzY29wZXMgPSB7IHNjb3BlOiBuZXdDdXJyZW50U2NvcGUsIGlzb2xhdGlvblNjb3BlOiBuZXdJc29sYXRpb25TY29wZSB9O1xuXG4gICAgICBjb25zdCBjdHgxID0gc2V0U2NvcGVzT25Db250ZXh0KGNvbnRleHQsIHNjb3Blcyk7XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgdW5uZWVkZWQgdmFsdWVzIGFnYWluXG4gICAgICBjb25zdCBjdHgyID0gY3R4MVxuICAgICAgICAuZGVsZXRlVmFsdWUoU0VOVFJZX0ZPUktfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZKVxuICAgICAgICAuZGVsZXRlVmFsdWUoU0VOVFJZX0ZPUktfU0VUX1NDT1BFX0NPTlRFWFRfS0VZKVxuICAgICAgICAuZGVsZXRlVmFsdWUoU0VOVFJZX0ZPUktfU0VUX0lTT0xBVElPTl9TQ09QRV9DT05URVhUX0tFWSk7XG5cbiAgICAgIHNldENvbnRleHRPblNjb3BlKG5ld0N1cnJlbnRTY29wZSwgY3R4Mik7XG5cbiAgICAgIHJldHVybiBzdXBlci53aXRoKGN0eDIsIGZuLCB0aGlzQXJnLCAuLi5hcmdzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gU2VudHJ5Q29udGV4dE1hbmFnZXIgO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gcnVucyB0aHJvdWdoIGEgbGlzdCBvZiBPVEVMIFNwYW5zLCBhbmQgd3JhcHMgdGhlbSBpbiBhbiBgU3Bhbk5vZGVgXG4gKiB3aGVyZSBlYWNoIG5vZGUgaG9sZHMgYSByZWZlcmVuY2UgdG8gdGhlaXIgcGFyZW50IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdyb3VwU3BhbnNXaXRoUGFyZW50cyhzcGFucykge1xuICBjb25zdCBub2RlTWFwID0gbmV3IE1hcCgpO1xuXG4gIGZvciAoY29uc3Qgc3BhbiBvZiBzcGFucykge1xuICAgIGNyZWF0ZU9yVXBkYXRlU3Bhbk5vZGVBbmRSZWZzKG5vZGVNYXAsIHNwYW4pO1xuICB9XG5cbiAgcmV0dXJuIEFycmF5LmZyb20obm9kZU1hcCwgZnVuY3Rpb24gKFtfaWQsIHNwYW5Ob2RlXSkge1xuICAgIHJldHVybiBzcGFuTm9kZTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhpcyByZXR1cm5zIHRoZSBfbG9jYWxfIHBhcmVudCBJRCAtIGBwYXJlbnRJZGAgb24gdGhlIHNwYW4gbWF5IHBvaW50IHRvIGEgcmVtb3RlIHNwYW4uXG4gKi9cbmZ1bmN0aW9uIGdldExvY2FsUGFyZW50SWQoc3Bhbikge1xuICBjb25zdCBwYXJlbnRJc1JlbW90ZSA9IHNwYW4uYXR0cmlidXRlc1tTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1BBUkVOVF9JU19SRU1PVEVdID09PSB0cnVlO1xuICAvLyBJZiB0aGUgcGFyZW50SWQgaXMgdGhlIHRyYWNlIHBhcmVudCBJRCwgd2UgcHJldGVuZCBpdCdzIHVuZGVmaW5lZFxuICAvLyBBcyB0aGlzIG1lYW5zIHRoZSBwYXJlbnQgZXhpc3RzIHNvbWV3aGVyZSBlbHNlXG4gIHJldHVybiAhcGFyZW50SXNSZW1vdGUgPyBnZXRQYXJlbnRTcGFuSWQoc3BhbikgOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlU3Bhbk5vZGVBbmRSZWZzKG5vZGVNYXAsIHNwYW4pIHtcbiAgY29uc3QgaWQgPSBzcGFuLnNwYW5Db250ZXh0KCkuc3BhbklkO1xuICBjb25zdCBwYXJlbnRJZCA9IGdldExvY2FsUGFyZW50SWQoc3Bhbik7XG5cbiAgaWYgKCFwYXJlbnRJZCkge1xuICAgIGNyZWF0ZU9yVXBkYXRlTm9kZShub2RlTWFwLCB7IGlkLCBzcGFuLCBjaGlsZHJlbjogW10gfSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRWxzZSBtYWtlIHN1cmUgdG8gY3JlYXRlIHBhcmVudCBub2RlIGFzIHdlbGxcbiAgLy8gTm90ZSB0aGF0IHRoZSBwYXJlbnQgbWF5IG5vdCBrbm93IGl0J3MgcGFyZW50IF95ZXRfLCB0aGlzIG1heSBiZSB1cGRhdGVkIGluIGEgbGF0ZXIgcGFzc1xuICBjb25zdCBwYXJlbnROb2RlID0gY3JlYXRlT3JHZXRQYXJlbnROb2RlKG5vZGVNYXAsIHBhcmVudElkKTtcbiAgY29uc3Qgbm9kZSA9IGNyZWF0ZU9yVXBkYXRlTm9kZShub2RlTWFwLCB7IGlkLCBzcGFuLCBwYXJlbnROb2RlLCBjaGlsZHJlbjogW10gfSk7XG4gIHBhcmVudE5vZGUuY2hpbGRyZW4ucHVzaChub2RlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT3JHZXRQYXJlbnROb2RlKG5vZGVNYXAsIGlkKSB7XG4gIGNvbnN0IGV4aXN0aW5nID0gbm9kZU1hcC5nZXQoaWQpO1xuXG4gIGlmIChleGlzdGluZykge1xuICAgIHJldHVybiBleGlzdGluZztcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZU5vZGUobm9kZU1hcCwgeyBpZCwgY2hpbGRyZW46IFtdIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPclVwZGF0ZU5vZGUobm9kZU1hcCwgc3Bhbk5vZGUpIHtcbiAgY29uc3QgZXhpc3RpbmcgPSBub2RlTWFwLmdldChzcGFuTm9kZS5pZCk7XG5cbiAgLy8gSWYgc3BhbiBpcyBhbHJlYWR5IHNldCwgbm90aGluZyB0byBkbyBoZXJlXG4gIGlmIChleGlzdGluZz8uc3Bhbikge1xuICAgIHJldHVybiBleGlzdGluZztcbiAgfVxuXG4gIC8vIElmIGl0IGV4aXN0cyBidXQgc3BhbiBpcyBub3Qgc2V0IHlldCwgd2UgdXBkYXRlIGl0XG4gIGlmIChleGlzdGluZyAmJiAhZXhpc3Rpbmcuc3Bhbikge1xuICAgIGV4aXN0aW5nLnNwYW4gPSBzcGFuTm9kZS5zcGFuO1xuICAgIGV4aXN0aW5nLnBhcmVudE5vZGUgPSBzcGFuTm9kZS5wYXJlbnROb2RlO1xuICAgIHJldHVybiBleGlzdGluZztcbiAgfVxuXG4gIC8vIEVsc2UsIHdlIGNyZWF0ZSBhIG5ldyBvbmUuLi5cbiAgbm9kZU1hcC5zZXQoc3Bhbk5vZGUuaWQsIHNwYW5Ob2RlKTtcbiAgcmV0dXJuIHNwYW5Ob2RlO1xufVxuXG4vLyBjYW5vbmljYWxDb2Rlc0dycGNNYXAgbWFwcyBzb21lIEdSUEMgY29kZXMgdG8gU2VudHJ5J3Mgc3BhbiBzdGF0dXNlcy4gU2VlIGRlc2NyaXB0aW9uIGluIGdycGMgZG9jdW1lbnRhdGlvbi5cbmNvbnN0IGNhbm9uaWNhbEdycGNFcnJvckNvZGVzTWFwID0ge1xuICAnMSc6ICdjYW5jZWxsZWQnLFxuICAnMic6ICd1bmtub3duX2Vycm9yJyxcbiAgJzMnOiAnaW52YWxpZF9hcmd1bWVudCcsXG4gICc0JzogJ2RlYWRsaW5lX2V4Y2VlZGVkJyxcbiAgJzUnOiAnbm90X2ZvdW5kJyxcbiAgJzYnOiAnYWxyZWFkeV9leGlzdHMnLFxuICAnNyc6ICdwZXJtaXNzaW9uX2RlbmllZCcsXG4gICc4JzogJ3Jlc291cmNlX2V4aGF1c3RlZCcsXG4gICc5JzogJ2ZhaWxlZF9wcmVjb25kaXRpb24nLFxuICAnMTAnOiAnYWJvcnRlZCcsXG4gICcxMSc6ICdvdXRfb2ZfcmFuZ2UnLFxuICAnMTInOiAndW5pbXBsZW1lbnRlZCcsXG4gICcxMyc6ICdpbnRlcm5hbF9lcnJvcicsXG4gICcxNCc6ICd1bmF2YWlsYWJsZScsXG4gICcxNSc6ICdkYXRhX2xvc3MnLFxuICAnMTYnOiAndW5hdXRoZW50aWNhdGVkJyxcbn0gO1xuXG5jb25zdCBpc1N0YXR1c0Vycm9yTWVzc2FnZVZhbGlkID0gKG1lc3NhZ2UpID0+IHtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoY2Fub25pY2FsR3JwY0Vycm9yQ29kZXNNYXApLmluY2x1ZGVzKG1lc3NhZ2UgKTtcbn07XG5cbi8qKlxuICogR2V0IGEgU2VudHJ5IHNwYW4gc3RhdHVzIGZyb20gYW4gb3RlbCBzcGFuLlxuICovXG5mdW5jdGlvbiBtYXBTdGF0dXMoc3Bhbikge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gc3Bhbkhhc0F0dHJpYnV0ZXMoc3BhbikgPyBzcGFuLmF0dHJpYnV0ZXMgOiB7fTtcbiAgY29uc3Qgc3RhdHVzID0gc3Bhbkhhc1N0YXR1cyhzcGFuKSA/IHNwYW4uc3RhdHVzIDogdW5kZWZpbmVkO1xuXG4gIGlmIChzdGF0dXMpIHtcbiAgICAvLyBTaW5jZSBzcGFuIHN0YXR1cyBPSyBpcyBub3Qgc2V0IGJ5IGRlZmF1bHQsIHdlIGdpdmUgaXQgcHJpb3JpdHk6IGh0dHBzOi8vb3BlbnRlbGVtZXRyeS5pby9kb2NzL2NvbmNlcHRzL3NpZ25hbHMvdHJhY2VzLyNzcGFuLXN0YXR1c1xuICAgIGlmIChzdGF0dXMuY29kZSA9PT0gYXBpLlNwYW5TdGF0dXNDb2RlLk9LKSB7XG4gICAgICByZXR1cm4geyBjb2RlOiBjb3JlLlNQQU5fU1RBVFVTX09LIH07XG4gICAgICAvLyBJZiB0aGUgc3BhbiBpcyBhbHJlYWR5IG1hcmtlZCBhcyBlcnJvbmVvdXMgd2UgcmV0dXJuIHRoYXQgZXhhY3Qgc3RhdHVzXG4gICAgfSBlbHNlIGlmIChzdGF0dXMuY29kZSA9PT0gYXBpLlNwYW5TdGF0dXNDb2RlLkVSUk9SKSB7XG4gICAgICBpZiAodHlwZW9mIHN0YXR1cy5tZXNzYWdlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBpbmZlcnJlZFN0YXR1cyA9IGluZmVyU3RhdHVzRnJvbUF0dHJpYnV0ZXMoYXR0cmlidXRlcyk7XG4gICAgICAgIGlmIChpbmZlcnJlZFN0YXR1cykge1xuICAgICAgICAgIHJldHVybiBpbmZlcnJlZFN0YXR1cztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdHVzLm1lc3NhZ2UgJiYgaXNTdGF0dXNFcnJvck1lc3NhZ2VWYWxpZChzdGF0dXMubWVzc2FnZSkpIHtcbiAgICAgICAgcmV0dXJuIHsgY29kZTogY29yZS5TUEFOX1NUQVRVU19FUlJPUiwgbWVzc2FnZTogc3RhdHVzLm1lc3NhZ2UgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7IGNvZGU6IGNvcmUuU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6ICd1bmtub3duX2Vycm9yJyB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZSBzcGFuIHN0YXR1cyBpcyBVTlNFVCwgd2UgdHJ5IHRvIGluZmVyIGl0IGZyb20gSFRUUCBvciBHUlBDIHN0YXR1cyBjb2Rlcy5cbiAgY29uc3QgaW5mZXJyZWRTdGF0dXMgPSBpbmZlclN0YXR1c0Zyb21BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpO1xuXG4gIGlmIChpbmZlcnJlZFN0YXR1cykge1xuICAgIHJldHVybiBpbmZlcnJlZFN0YXR1cztcbiAgfVxuXG4gIC8vIFdlIGRlZmF1bHQgdG8gc2V0dGluZyB0aGUgc3BhbnMgc3RhdHVzIHRvIG9rLlxuICBpZiAoc3RhdHVzPy5jb2RlID09PSBhcGkuU3BhblN0YXR1c0NvZGUuVU5TRVQpIHtcbiAgICByZXR1cm4geyBjb2RlOiBjb3JlLlNQQU5fU1RBVFVTX09LIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgY29kZTogY29yZS5TUEFOX1NUQVRVU19FUlJPUiwgbWVzc2FnZTogJ3Vua25vd25fZXJyb3InIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5mZXJTdGF0dXNGcm9tQXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG4gIC8vIElmIHRoZSBzcGFuIHN0YXR1cyBpcyBVTlNFVCwgd2UgdHJ5IHRvIGluZmVyIGl0IGZyb20gSFRUUCBvciBHUlBDIHN0YXR1cyBjb2Rlcy5cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgY29uc3QgaHR0cENvZGVBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuQVRUUl9IVFRQX1JFU1BPTlNFX1NUQVRVU19DT0RFXSB8fCBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9TVEFUVVNfQ09ERV07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBjb25zdCBncnBjQ29kZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19SUENfR1JQQ19TVEFUVVNfQ09ERV07XG5cbiAgY29uc3QgbnVtYmVySHR0cENvZGUgPVxuICAgIHR5cGVvZiBodHRwQ29kZUF0dHJpYnV0ZSA9PT0gJ251bWJlcidcbiAgICAgID8gaHR0cENvZGVBdHRyaWJ1dGVcbiAgICAgIDogdHlwZW9mIGh0dHBDb2RlQXR0cmlidXRlID09PSAnc3RyaW5nJ1xuICAgICAgICA/IHBhcnNlSW50KGh0dHBDb2RlQXR0cmlidXRlKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICBpZiAodHlwZW9mIG51bWJlckh0dHBDb2RlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBjb3JlLmdldFNwYW5TdGF0dXNGcm9tSHR0cENvZGUobnVtYmVySHR0cENvZGUpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBncnBjQ29kZUF0dHJpYnV0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4geyBjb2RlOiBjb3JlLlNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiBjYW5vbmljYWxHcnBjRXJyb3JDb2Rlc01hcFtncnBjQ29kZUF0dHJpYnV0ZV0gfHwgJ3Vua25vd25fZXJyb3InIH07XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5jb25zdCBNQVhfU1BBTl9DT1VOVCA9IDEwMDA7XG5jb25zdCBERUZBVUxUX1RJTUVPVVQgPSAzMDA7IC8vIDUgbWluXG5cbi8qKlxuICogQSBTZW50cnktc3BlY2lmaWMgZXhwb3J0ZXIgdGhhdCBjb252ZXJ0cyBPcGVuVGVsZW1ldHJ5IFNwYW5zIHRvIFNlbnRyeSBTcGFucyAmIFRyYW5zYWN0aW9ucy5cbiAqL1xuY2xhc3MgU2VudHJ5U3BhbkV4cG9ydGVyIHtcbiAgLypcbiAgICogQSBxdWljayBleHBsYW5hdGlvbiBvbiB0aGUgYnVja2V0czogV2UgZG8gYnVja2V0aW5nIG9mIGZpbmlzaGVkIHNwYW5zIGZvciBlZmZpY2llbmN5LiBUaGlzIHNwYW4gZXhwb3J0ZXIgaXNcbiAgICogYWNjdW11bGF0aW5nIHNwYW5zIHVudGlsIGEgcm9vdCBzcGFuIGlzIGVuY291bnRlcmVkIGFuZCB0aGVuIGl0IGZsdXNoZXMgYWxsIHRoZSBzcGFucyB0aGF0IGFyZSBkZXNjZW5kYW50cyBvZiB0aGF0XG4gICAqIHJvb3Qgc3Bhbi4gQmVjYXVzZSBpdCBpcyB0b3RhbGx5IGluIHRoZSByZWFsbSBvZiBwb3NzaWJpbGl0aWVzIHRoYXQgcm9vdCBzcGFucyBhcmUgbmV2ZXIgZmluaXNoZWQsIGFuZCB3ZSBkb24ndFxuICAgKiB3YW50IHRvIGFjY3VtdWxhdGUgc3BhbnMgaW5kZWZpbml0ZWx5IGluIG1lbW9yeSwgd2UgbmVlZCB0byBwZXJpb2RpY2FsbHkgZXZhY3VhdGUgc3BhbnMuIE5haXZlbHkgd2UgY291bGQgc2ltcGx5XG4gICAqIHN0b3JlIHRoZSBzcGFucyBpbiBhbiBhcnJheSBhbmQgZWFjaCB0aW1lIGEgbmV3IHNwYW4gY29tZXMgaW4gd2UgY291bGQgaXRlcmF0ZSB0aHJvdWdoIHRoZSBlbnRpcmUgYXJyYXkgYW5kXG4gICAqIGV2YWN1YXRlIGFsbCBzcGFucyB0aGF0IGhhdmUgYW4gZW5kLXRpbWVzdGFtcCB0aGF0IGlzIG9sZGVyIHRoYW4gb3VyIGxpbWl0LiBUaGlzIGNvdWxkIGdldCBxdWl0ZSBleHBlbnNpdmUgYmVjYXVzZVxuICAgKiB3ZSB3b3VsZCBoYXZlIHRvIGl0ZXJhdGUgYSBwb3RlbnRpYWxseSBsYXJnZSBudW1iZXIgb2Ygc3BhbnMgZXZlcnkgdGltZSB3ZSBldmFjdWF0ZS4gV2Ugd2FudCB0byBhdm9pZCB0aGVzZSBsYXJnZVxuICAgKiBidXJzdHMgb2YgY29tcHV0YXRpb24uXG4gICAqXG4gICAqIEluc3RlYWQgd2UgZ28gZm9yIGEgYnVja2V0aW5nIGFwcHJvYWNoIGFuZCBwdXQgc3BhbnMgaW50byBidWNrZXRzLCBiYXNlZCBvbiB3aGF0IHNlY29uZFxuICAgKiAobW9kdWxvIHRoZSB0aW1lIGxpbWl0KSB0aGUgc3BhbiB3YXMgcHV0IGludG8gdGhlIGV4cG9ydGVyLiBXaXRoIGJ1Y2tldHMsIHdoZW4gd2UgZGVjaWRlIHRvIGV2YWN1YXRlLCB3ZSBjYW5cbiAgICogaXRlcmF0ZSB0aHJvdWdoIHRoZSBidWNrZXQgZW50cmllcyBpbnN0ZWFkLCB3aGljaCBoYXZlIGFuIHVwcGVyIGJvdW5kIG9mIGl0ZW1zLCBtYWtpbmcgdGhlIGV2YWN1YXRpb24gbXVjaCBtb3JlXG4gICAqIGVmZmljaWVudC4gQ2xlYW5pbmcgdXAgYWxzbyBiZWNvbWVzIG11Y2ggbW9yZSBlZmZpY2llbnQgc2luY2UgaXQgc2ltcGx5IGludm9sdmVzIGRlLXJlZmVyZW5jaW5nIGEgYnVja2V0IHdpdGhpbiB0aGVcbiAgICogYnVja2V0IGFycmF5LCBhbmQgbGV0dGluZyBnYXJiYWdlIGNvbGxlY3Rpb24gdGFrZSBjYXJlIG9mIHRoZSByZXN0LlxuICAgKi9cblxuICAvLyBFc3NlbnRpYWxseSBhIGEgc2V0IG9mIHNwYW4gaWRzIHRoYXQgYXJlIGFscmVhZHkgc2VudC4gVGhlIHZhbHVlcyBhcmUgZXhwaXJhdGlvblxuICAvLyB0aW1lcyBpbiB0aGlzIGNhY2hlIHNvIHdlIGRvbid0IGhvbGQgb250byB0aGVtIGluZGVmaW5pdGVseS5cblxuICAvKiBJbnRlcm5hbGx5LCB3ZSB1c2UgYSBkZWJvdW5jZWQgZmx1c2ggdG8gZ2l2ZSBzb21lIHdpZ2dsZSByb29tIHRvIHRoZSBzcGFuIHByb2Nlc3NvciB0byBhY2N1bXVsYXRlIG1vcmUgc3BhbnMuICovXG5cbiAgIGNvbnN0cnVjdG9yKG9wdGlvbnNcblxuKSB7XG4gICAgdGhpcy5fZmluaXNoZWRTcGFuQnVja2V0U2l6ZSA9IG9wdGlvbnM/LnRpbWVvdXQgfHwgREVGQVVMVF9USU1FT1VUO1xuICAgIHRoaXMuX2ZpbmlzaGVkU3BhbkJ1Y2tldHMgPSBuZXcgQXJyYXkodGhpcy5fZmluaXNoZWRTcGFuQnVja2V0U2l6ZSkuZmlsbCh1bmRlZmluZWQpO1xuICAgIHRoaXMuX2xhc3RDbGVhbnVwVGltZXN0YW1wSW5TID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgdGhpcy5fc3BhbnNUb0J1Y2tldEVudHJ5ID0gbmV3IFdlYWtNYXAoKTtcbiAgICB0aGlzLl9zZW50U3BhbnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fZGVib3VuY2VkRmx1c2ggPSBjb3JlLmRlYm91bmNlKHRoaXMuZmx1c2guYmluZCh0aGlzKSwgMSwgeyBtYXhXYWl0OiAxMDAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRXhwb3J0IGEgc2luZ2xlIHNwYW4uXG4gICAqIFRoaXMgaXMgY2FsbGVkIGJ5IHRoZSBzcGFuIHByb2Nlc3NvciB3aGVuZXZlciBhIHNwYW4gaXMgZW5kZWQuXG4gICAqL1xuICAgZXhwb3J0KHNwYW4pIHtcbiAgICBjb25zdCBjdXJyZW50VGltZXN0YW1wSW5TID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG5cbiAgICBpZiAodGhpcy5fbGFzdENsZWFudXBUaW1lc3RhbXBJblMgIT09IGN1cnJlbnRUaW1lc3RhbXBJblMpIHtcbiAgICAgIGxldCBkcm9wcGVkU3BhbkNvdW50ID0gMDtcbiAgICAgIHRoaXMuX2ZpbmlzaGVkU3BhbkJ1Y2tldHMuZm9yRWFjaCgoYnVja2V0LCBpKSA9PiB7XG4gICAgICAgIGlmIChidWNrZXQgJiYgYnVja2V0LnRpbWVzdGFtcEluUyA8PSBjdXJyZW50VGltZXN0YW1wSW5TIC0gdGhpcy5fZmluaXNoZWRTcGFuQnVja2V0U2l6ZSkge1xuICAgICAgICAgIGRyb3BwZWRTcGFuQ291bnQgKz0gYnVja2V0LnNwYW5zLnNpemU7XG4gICAgICAgICAgdGhpcy5fZmluaXNoZWRTcGFuQnVja2V0c1tpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoZHJvcHBlZFNwYW5Db3VudCA+IDApIHtcbiAgICAgICAgREVCVUdfQlVJTEQgJiZcbiAgICAgICAgICBjb3JlLmRlYnVnLmxvZyhcbiAgICAgICAgICAgIGBTcGFuRXhwb3J0ZXIgZHJvcHBlZCAke2Ryb3BwZWRTcGFuQ291bnR9IHNwYW5zIGJlY2F1c2UgdGhleSB3ZXJlIHBlbmRpbmcgZm9yIG1vcmUgdGhhbiAke3RoaXMuX2ZpbmlzaGVkU3BhbkJ1Y2tldFNpemV9IHNlY29uZHMuYCxcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGFzdENsZWFudXBUaW1lc3RhbXBJblMgPSBjdXJyZW50VGltZXN0YW1wSW5TO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnRCdWNrZXRJbmRleCA9IGN1cnJlbnRUaW1lc3RhbXBJblMgJSB0aGlzLl9maW5pc2hlZFNwYW5CdWNrZXRTaXplO1xuICAgIGNvbnN0IGN1cnJlbnRCdWNrZXQgPSB0aGlzLl9maW5pc2hlZFNwYW5CdWNrZXRzW2N1cnJlbnRCdWNrZXRJbmRleF0gfHwge1xuICAgICAgdGltZXN0YW1wSW5TOiBjdXJyZW50VGltZXN0YW1wSW5TLFxuICAgICAgc3BhbnM6IG5ldyBTZXQoKSxcbiAgICB9O1xuICAgIHRoaXMuX2ZpbmlzaGVkU3BhbkJ1Y2tldHNbY3VycmVudEJ1Y2tldEluZGV4XSA9IGN1cnJlbnRCdWNrZXQ7XG4gICAgY3VycmVudEJ1Y2tldC5zcGFucy5hZGQoc3Bhbik7XG4gICAgdGhpcy5fc3BhbnNUb0J1Y2tldEVudHJ5LnNldChzcGFuLCBjdXJyZW50QnVja2V0KTtcblxuICAgIC8vIElmIHRoZSBzcGFuIGRvZXNuJ3QgaGF2ZSBhIGxvY2FsIHBhcmVudCBJRCAoaXQncyBhIHJvb3Qgc3BhbiksIHdlJ3JlIGdvbm5hIGZsdXNoIGFsbCB0aGUgZW5kZWQgc3BhbnNcbiAgICBjb25zdCBsb2NhbFBhcmVudElkID0gZ2V0TG9jYWxQYXJlbnRJZChzcGFuKTtcbiAgICBpZiAoIWxvY2FsUGFyZW50SWQgfHwgdGhpcy5fc2VudFNwYW5zLmhhcyhsb2NhbFBhcmVudElkKSkge1xuICAgICAgdGhpcy5fZGVib3VuY2VkRmx1c2goKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJ5IHRvIGZsdXNoIGFueSBwZW5kaW5nIHNwYW5zIGltbWVkaWF0ZWx5LlxuICAgKiBUaGlzIGlzIGNhbGxlZCBpbnRlcm5hbGx5IGJ5IHRoZSBleHBvcnRlciAodmlhIF9kZWJvdW5jZWRGbHVzaCksXG4gICAqIGJ1dCBjYW4gYWxzbyBiZSB0cmlnZ2VyZWQgZXh0ZXJuYWxseSBpZiB3ZSBmb3JjZS1mbHVzaC5cbiAgICovXG4gICBmbHVzaCgpIHtcbiAgICBjb25zdCBmaW5pc2hlZFNwYW5zID0gdGhpcy5fZmluaXNoZWRTcGFuQnVja2V0cy5mbGF0TWFwKGJ1Y2tldCA9PiAoYnVja2V0ID8gQXJyYXkuZnJvbShidWNrZXQuc3BhbnMpIDogW10pKTtcblxuICAgIHRoaXMuX2ZsdXNoU2VudFNwYW5DYWNoZSgpO1xuICAgIGNvbnN0IHNlbnRTcGFucyA9IHRoaXMuX21heWJlU2VuZChmaW5pc2hlZFNwYW5zKTtcblxuICAgIGNvbnN0IHNlbnRTcGFuQ291bnQgPSBzZW50U3BhbnMuc2l6ZTtcbiAgICBjb25zdCByZW1haW5pbmdPcGVuU3BhbkNvdW50ID0gZmluaXNoZWRTcGFucy5sZW5ndGggLSBzZW50U3BhbkNvdW50O1xuICAgIERFQlVHX0JVSUxEICYmXG4gICAgICBjb3JlLmRlYnVnLmxvZyhcbiAgICAgICAgYFNwYW5FeHBvcnRlciBleHBvcnRlZCAke3NlbnRTcGFuQ291bnR9IHNwYW5zLCAke3JlbWFpbmluZ09wZW5TcGFuQ291bnR9IHNwYW5zIGFyZSB3YWl0aW5nIGZvciB0aGVpciBwYXJlbnQgc3BhbnMgdG8gZmluaXNoYCxcbiAgICAgICk7XG5cbiAgICBjb25zdCBleHBpcmF0aW9uRGF0ZSA9IERhdGUubm93KCkgKyBERUZBVUxUX1RJTUVPVVQgKiAxMDAwO1xuXG4gICAgZm9yIChjb25zdCBzcGFuIG9mIHNlbnRTcGFucykge1xuICAgICAgdGhpcy5fc2VudFNwYW5zLnNldChzcGFuLnNwYW5Db250ZXh0KCkuc3BhbklkLCBleHBpcmF0aW9uRGF0ZSk7XG4gICAgICBjb25zdCBidWNrZXRFbnRyeSA9IHRoaXMuX3NwYW5zVG9CdWNrZXRFbnRyeS5nZXQoc3Bhbik7XG4gICAgICBpZiAoYnVja2V0RW50cnkpIHtcbiAgICAgICAgYnVja2V0RW50cnkuc3BhbnMuZGVsZXRlKHNwYW4pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBDYW5jZWwgYSBwZW5kaW5nIGRlYm91bmNlZCBmbHVzaCwgaWYgdGhlcmUgaXMgb25lXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVsZXZhbnQgaWYgd2UgZGlyZWN0bHkgZmx1c2gsIGNpcmN1bXZlbnRpbmcgdGhlIGRlYm91bmNlXG4gICAgLy8gaW4gdGhhdCBjYXNlLCB3ZSB3YW50IHRvIGNhbmNlbCBhbnkgcGVuZGluZyBkZWJvdW5jZWQgZmx1c2hcbiAgICB0aGlzLl9kZWJvdW5jZWRGbHVzaC5jYW5jZWwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciB0aGUgZXhwb3J0ZXIuXG4gICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIHNwYW4gcHJvY2Vzc29yIGlzIHNodXQgZG93bi5cbiAgICovXG4gICBjbGVhcigpIHtcbiAgICB0aGlzLl9maW5pc2hlZFNwYW5CdWNrZXRzID0gdGhpcy5fZmluaXNoZWRTcGFuQnVja2V0cy5maWxsKHVuZGVmaW5lZCk7XG4gICAgdGhpcy5fc2VudFNwYW5zLmNsZWFyKCk7XG4gICAgdGhpcy5fZGVib3VuY2VkRmx1c2guY2FuY2VsKCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCB0aGUgZ2l2ZW4gc3BhbnMsIGJ1dCBvbmx5IGlmIHRoZXkgYXJlIHBhcnQgb2YgYSBmaW5pc2hlZCB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogUmV0dXJucyB0aGUgc2VudCBzcGFucy5cbiAgICogU3BhbnMgcmVtYWluIHVuc2VudCB3aGVuIHRoZWlyIHBhcmVudCBzcGFuIGlzIG5vdCB5ZXQgZmluaXNoZWQuXG4gICAqIFRoaXMgd2lsbCBoYXBwZW4gcmVndWxhcmx5LCBhcyBjaGlsZCBzcGFucyBhcmUgZ2VuZXJhbGx5IGZpbmlzaGVkIGJlZm9yZSB0aGVpciBwYXJlbnRzLlxuICAgKiBCdXQgaXQgX2NvdWxkXyBhbHNvIGhhcHBlbiBiZWNhdXNlLCBmb3Igd2hhdGV2ZXIgcmVhc29uLCBhIHBhcmVudCBzcGFuIHdhcyBsb3N0LlxuICAgKiBJbiB0aGlzIGNhc2UsIHdlJ2xsIGV2ZW50dWFsbHkgbmVlZCB0byBjbGVhbiB0aGlzIHVwLlxuICAgKi9cbiAgIF9tYXliZVNlbmQoc3BhbnMpIHtcbiAgICBjb25zdCBncm91cGVkID0gZ3JvdXBTcGFuc1dpdGhQYXJlbnRzKHNwYW5zKTtcbiAgICBjb25zdCBzZW50U3BhbnMgPSBuZXcgU2V0KCk7XG5cbiAgICBjb25zdCByb290Tm9kZXMgPSB0aGlzLl9nZXRDb21wbGV0ZWRSb290Tm9kZXMoZ3JvdXBlZCk7XG5cbiAgICBmb3IgKGNvbnN0IHJvb3Qgb2Ygcm9vdE5vZGVzKSB7XG4gICAgICBjb25zdCBzcGFuID0gcm9vdC5zcGFuO1xuICAgICAgc2VudFNwYW5zLmFkZChzcGFuKTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uRXZlbnQgPSBjcmVhdGVUcmFuc2FjdGlvbkZvck90ZWxTcGFuKHNwYW4pO1xuXG4gICAgICAvLyBBZGQgYW4gYXR0cmlidXRlIHRvIHRoZSB0cmFuc2FjdGlvbiBldmVudCB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gaXMgYW4gb3JwaGFuZWQgdHJhbnNhY3Rpb25cbiAgICAgIGlmIChyb290LnBhcmVudE5vZGUgJiYgdGhpcy5fc2VudFNwYW5zLmhhcyhyb290LnBhcmVudE5vZGUuaWQpKSB7XG4gICAgICAgIGNvbnN0IHRyYWNlRGF0YSA9IHRyYW5zYWN0aW9uRXZlbnQuY29udGV4dHM/LnRyYWNlPy5kYXRhO1xuICAgICAgICBpZiAodHJhY2VEYXRhKSB7XG4gICAgICAgICAgdHJhY2VEYXRhWydzZW50cnkucGFyZW50X3NwYW5fYWxyZWFkeV9zZW50J10gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFdlJ2xsIHJlY3Vyc2l2ZWx5IGFkZCBhbGwgdGhlIGNoaWxkIHNwYW5zIHRvIHRoaXMgYXJyYXlcbiAgICAgIGNvbnN0IHNwYW5zID0gdHJhbnNhY3Rpb25FdmVudC5zcGFucyB8fCBbXTtcblxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiByb290LmNoaWxkcmVuKSB7XG4gICAgICAgIGNyZWF0ZUFuZEZpbmlzaFNwYW5Gb3JPdGVsU3BhbihjaGlsZCwgc3BhbnMsIHNlbnRTcGFucyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNwYW5zLnNvcnQoKSBtdXRhdGVzIHRoZSBhcnJheSwgYnV0IHdlIGRvIG5vdCB1c2UgdGhpcyBhbnltb3JlIGFmdGVyIHRoaXMgcG9pbnRcbiAgICAgIC8vIHNvIHdlIGNhbiBzYWZlbHkgbXV0YXRlIGl0IGhlcmVcbiAgICAgIHRyYW5zYWN0aW9uRXZlbnQuc3BhbnMgPVxuICAgICAgICBzcGFucy5sZW5ndGggPiBNQVhfU1BBTl9DT1VOVFxuICAgICAgICAgID8gc3BhbnMuc29ydCgoYSwgYikgPT4gYS5zdGFydF90aW1lc3RhbXAgLSBiLnN0YXJ0X3RpbWVzdGFtcCkuc2xpY2UoMCwgTUFYX1NQQU5fQ09VTlQpXG4gICAgICAgICAgOiBzcGFucztcblxuICAgICAgY29uc3QgbWVhc3VyZW1lbnRzID0gY29yZS50aW1lZEV2ZW50c1RvTWVhc3VyZW1lbnRzKHNwYW4uZXZlbnRzKTtcbiAgICAgIGlmIChtZWFzdXJlbWVudHMpIHtcbiAgICAgICAgdHJhbnNhY3Rpb25FdmVudC5tZWFzdXJlbWVudHMgPSBtZWFzdXJlbWVudHM7XG4gICAgICB9XG5cbiAgICAgIGNvcmUuY2FwdHVyZUV2ZW50KHRyYW5zYWN0aW9uRXZlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBzZW50U3BhbnM7XG4gIH1cblxuICAvKiogUmVtb3ZlIFwiZXhwaXJlZFwiIHNwYW4gaWQgZW50cmllcyBmcm9tIHRoZSBfc2VudFNwYW5zIGNhY2hlLiAqL1xuICAgX2ZsdXNoU2VudFNwYW5DYWNoZSgpIHtcbiAgICBjb25zdCBjdXJyZW50VGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAvLyBOb3RlLCBpdCBpcyBzYWZlIHRvIGRlbGV0ZSBpdGVtcyBmcm9tIHRoZSBtYXAgYXMgd2UgZ286IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zNTk0Mzk5NS85MDI5N1xuICAgIGZvciAoY29uc3QgW3NwYW5JZCwgZXhwaXJhdGlvblRpbWVdIG9mIHRoaXMuX3NlbnRTcGFucy5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChleHBpcmF0aW9uVGltZSA8PSBjdXJyZW50VGltZXN0YW1wKSB7XG4gICAgICAgIHRoaXMuX3NlbnRTcGFucy5kZWxldGUoc3BhbklkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogQ2hlY2sgaWYgYSBub2RlIGlzIGEgY29tcGxldGVkIHJvb3Qgbm9kZSBvciBhIG5vZGUgd2hvc2UgcGFyZW50IGhhcyBhbHJlYWR5IGJlZW4gc2VudCAqL1xuICAgX25vZGVJc0NvbXBsZXRlZFJvb3ROb2RlT3JIYXNTZW50UGFyZW50KG5vZGUpIHtcbiAgICByZXR1cm4gISFub2RlLnNwYW4gJiYgKCFub2RlLnBhcmVudE5vZGUgfHwgdGhpcy5fc2VudFNwYW5zLmhhcyhub2RlLnBhcmVudE5vZGUuaWQpKTtcbiAgfVxuXG4gIC8qKiBHZXQgYWxsIGNvbXBsZXRlZCByb290IG5vZGVzIGZyb20gYSBsaXN0IG9mIG5vZGVzICovXG4gICBfZ2V0Q29tcGxldGVkUm9vdE5vZGVzKG5vZGVzKSB7XG4gICAgLy8gVE9ETzogV2Ugc2hvdWxkIGJlIGFibGUgdG8gcmVtb3ZlIHRoZSBleHBsaWNpdCBgbm9kZSBpcyBTcGFuTm9kZUNvbXBsZXRlZGAgdHlwZSBndWFyZFxuICAgIC8vICAgICAgIG9uY2Ugd2Ugc3RvcCBzdXBwb3J0aW5nIFRTIDwgNS41XG4gICAgcmV0dXJuIG5vZGVzLmZpbHRlcigobm9kZSkgPT4gdGhpcy5fbm9kZUlzQ29tcGxldGVkUm9vdE5vZGVPckhhc1NlbnRQYXJlbnQobm9kZSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3BhbihzcGFuKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBzcGFuLmF0dHJpYnV0ZXM7XG5cbiAgY29uc3Qgb3JpZ2luID0gYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOXSA7XG4gIGNvbnN0IG9wID0gYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1BdIDtcbiAgY29uc3Qgc291cmNlID0gYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFXSA7XG5cbiAgcmV0dXJuIHsgb3JpZ2luLCBvcCwgc291cmNlIH07XG59XG5cbi8qKiBFeHBvcnRlZCBvbmx5IGZvciB0ZXN0cy4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zYWN0aW9uRm9yT3RlbFNwYW4oc3Bhbikge1xuICBjb25zdCB7IG9wLCBkZXNjcmlwdGlvbiwgZGF0YSwgb3JpZ2luID0gJ21hbnVhbCcsIHNvdXJjZSB9ID0gZ2V0U3BhbkRhdGEoc3Bhbik7XG4gIGNvbnN0IGNhcHR1cmVkU3BhblNjb3BlcyA9IGNvcmUuZ2V0Q2FwdHVyZWRTY29wZXNPblNwYW4oc3BhbiApO1xuXG4gIGNvbnN0IHNhbXBsZVJhdGUgPSBzcGFuLmF0dHJpYnV0ZXNbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NBTVBMRV9SQVRFXSA7XG5cbiAgY29uc3QgYXR0cmlidXRlcyA9IHtcbiAgICBbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRV06IHNvdXJjZSxcbiAgICBbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NBTVBMRV9SQVRFXTogc2FtcGxlUmF0ZSxcbiAgICBbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09QXTogb3AsXG4gICAgW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU5dOiBvcmlnaW4sXG4gICAgLi4uZGF0YSxcbiAgICAuLi5yZW1vdmVTZW50cnlBdHRyaWJ1dGVzKHNwYW4uYXR0cmlidXRlcyksXG4gIH07XG5cbiAgY29uc3QgeyBsaW5rcyB9ID0gc3BhbjtcbiAgY29uc3QgeyB0cmFjZUlkOiB0cmFjZV9pZCwgc3BhbklkOiBzcGFuX2lkIH0gPSBzcGFuLnNwYW5Db250ZXh0KCk7XG5cbiAgLy8gSWYgcGFyZW50U3BhbklkRnJvbVRyYWNlU3RhdGUgaXMgZGVmaW5lZCBhdCBhbGwsIHdlIHdhbnQgaXQgdG8gdGFrZSBwcmVjZWRlbmNlXG4gIC8vIEluIHRoYXQgY2FzZSwgYW4gZW1wdHkgc3RyaW5nIHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBcIm5vIHBhcmVudCBzcGFuIGlkXCIsXG4gIC8vIGV2ZW4gaWYgYHNwYW4ucGFyZW50U3BhbklkYCBpcyBzZXRcbiAgLy8gdGhpcyBpcyB0aGUgY2FzZSB3aGVuIHdlIGFyZSBzdGFydGluZyBhIG5ldyB0cmFjZSwgd2hlcmUgd2UgaGF2ZSBhIHZpcnR1YWwgc3BhbiBiYXNlZCBvbiB0aGUgcHJvcGFnYXRpb25Db250ZXh0XG4gIC8vIFdlIG9ubHkgd2FudCB0byBjb250aW51ZSB0aGUgdHJhY2VJZCBpbiB0aGlzIGNhc2UsIGJ1dCBpZ25vcmUgdGhlIHBhcmVudCBzcGFuXG4gIGNvbnN0IHBhcmVudF9zcGFuX2lkID0gZ2V0UGFyZW50U3BhbklkKHNwYW4pO1xuXG4gIGNvbnN0IHN0YXR1cyA9IG1hcFN0YXR1cyhzcGFuKTtcblxuICBjb25zdCB0cmFjZUNvbnRleHQgPSB7XG4gICAgcGFyZW50X3NwYW5faWQsXG4gICAgc3Bhbl9pZCxcbiAgICB0cmFjZV9pZCxcbiAgICBkYXRhOiBhdHRyaWJ1dGVzLFxuICAgIG9yaWdpbixcbiAgICBvcCxcbiAgICBzdGF0dXM6IGNvcmUuZ2V0U3RhdHVzTWVzc2FnZShzdGF0dXMpLCAvLyBBcyBwZXIgcHJvdG9jb2wsIHNwYW4gc3RhdHVzIGlzIGFsbG93ZWQgdG8gYmUgdW5kZWZpbmVkXG4gICAgbGlua3M6IGNvcmUuY29udmVydFNwYW5MaW5rc0ZvckVudmVsb3BlKGxpbmtzKSxcbiAgfTtcblxuICBjb25zdCBzdGF0dXNDb2RlID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLkFUVFJfSFRUUF9SRVNQT05TRV9TVEFUVVNfQ09ERV07XG4gIGNvbnN0IHJlc3BvbnNlQ29udGV4dCA9IHR5cGVvZiBzdGF0dXNDb2RlID09PSAnbnVtYmVyJyA/IHsgcmVzcG9uc2U6IHsgc3RhdHVzX2NvZGU6IHN0YXR1c0NvZGUgfSB9IDogdW5kZWZpbmVkO1xuXG4gIGNvbnN0IHRyYW5zYWN0aW9uRXZlbnQgPSB7XG4gICAgY29udGV4dHM6IHtcbiAgICAgIHRyYWNlOiB0cmFjZUNvbnRleHQsXG4gICAgICBvdGVsOiB7XG4gICAgICAgIHJlc291cmNlOiBzcGFuLnJlc291cmNlLmF0dHJpYnV0ZXMsXG4gICAgICB9LFxuICAgICAgLi4ucmVzcG9uc2VDb250ZXh0LFxuICAgIH0sXG4gICAgc3BhbnM6IFtdLFxuICAgIHN0YXJ0X3RpbWVzdGFtcDogY29yZS5zcGFuVGltZUlucHV0VG9TZWNvbmRzKHNwYW4uc3RhcnRUaW1lKSxcbiAgICB0aW1lc3RhbXA6IGNvcmUuc3BhblRpbWVJbnB1dFRvU2Vjb25kcyhzcGFuLmVuZFRpbWUpLFxuICAgIHRyYW5zYWN0aW9uOiBkZXNjcmlwdGlvbixcbiAgICB0eXBlOiAndHJhbnNhY3Rpb24nLFxuICAgIHNka1Byb2Nlc3NpbmdNZXRhZGF0YToge1xuICAgICAgY2FwdHVyZWRTcGFuU2NvcGU6IGNhcHR1cmVkU3BhblNjb3Blcy5zY29wZSxcbiAgICAgIGNhcHR1cmVkU3Bhbklzb2xhdGlvblNjb3BlOiBjYXB0dXJlZFNwYW5TY29wZXMuaXNvbGF0aW9uU2NvcGUsXG4gICAgICBzYW1wbGVSYXRlLFxuICAgICAgZHluYW1pY1NhbXBsaW5nQ29udGV4dDogY29yZS5nZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW4oc3BhbiApLFxuICAgIH0sXG4gICAgLi4uKHNvdXJjZSAmJiB7XG4gICAgICB0cmFuc2FjdGlvbl9pbmZvOiB7XG4gICAgICAgIHNvdXJjZSxcbiAgICAgIH0sXG4gICAgfSksXG4gIH07XG5cbiAgcmV0dXJuIHRyYW5zYWN0aW9uRXZlbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFuZEZpbmlzaFNwYW5Gb3JPdGVsU3Bhbihub2RlLCBzcGFucywgc2VudFNwYW5zKSB7XG4gIGNvbnN0IHNwYW4gPSBub2RlLnNwYW47XG5cbiAgaWYgKHNwYW4pIHtcbiAgICBzZW50U3BhbnMuYWRkKHNwYW4pO1xuICB9XG5cbiAgY29uc3Qgc2hvdWxkRHJvcCA9ICFzcGFuO1xuXG4gIC8vIElmIHRoaXMgc3BhbiBzaG91bGQgYmUgZHJvcHBlZCwgd2Ugc3RpbGwgd2FudCB0byBjcmVhdGUgc3BhbnMgZm9yIHRoZSBjaGlsZHJlbiBvZiB0aGlzXG4gIGlmIChzaG91bGREcm9wKSB7XG4gICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGNyZWF0ZUFuZEZpbmlzaFNwYW5Gb3JPdGVsU3BhbihjaGlsZCwgc3BhbnMsIHNlbnRTcGFucyk7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc3Bhbl9pZCA9IHNwYW4uc3BhbkNvbnRleHQoKS5zcGFuSWQ7XG4gIGNvbnN0IHRyYWNlX2lkID0gc3Bhbi5zcGFuQ29udGV4dCgpLnRyYWNlSWQ7XG4gIGNvbnN0IHBhcmVudFNwYW5JZCA9IGdldFBhcmVudFNwYW5JZChzcGFuKTtcblxuICBjb25zdCB7IGF0dHJpYnV0ZXMsIHN0YXJ0VGltZSwgZW5kVGltZSwgbGlua3MgfSA9IHNwYW47XG5cbiAgY29uc3QgeyBvcCwgZGVzY3JpcHRpb24sIGRhdGEsIG9yaWdpbiA9ICdtYW51YWwnIH0gPSBnZXRTcGFuRGF0YShzcGFuKTtcbiAgY29uc3QgYWxsRGF0YSA9IHtcbiAgICBbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09SSUdJTl06IG9yaWdpbixcbiAgICBbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09QXTogb3AsXG4gICAgLi4ucmVtb3ZlU2VudHJ5QXR0cmlidXRlcyhhdHRyaWJ1dGVzKSxcbiAgICAuLi5kYXRhLFxuICB9O1xuXG4gIGNvbnN0IHN0YXR1cyA9IG1hcFN0YXR1cyhzcGFuKTtcblxuICBjb25zdCBzcGFuSlNPTiA9IHtcbiAgICBzcGFuX2lkLFxuICAgIHRyYWNlX2lkLFxuICAgIGRhdGE6IGFsbERhdGEsXG4gICAgZGVzY3JpcHRpb24sXG4gICAgcGFyZW50X3NwYW5faWQ6IHBhcmVudFNwYW5JZCxcbiAgICBzdGFydF90aW1lc3RhbXA6IGNvcmUuc3BhblRpbWVJbnB1dFRvU2Vjb25kcyhzdGFydFRpbWUpLFxuICAgIC8vIFRoaXMgaXMgWzAsMF0gYnkgZGVmYXVsdCBpbiBPVEVMLCBpbiB3aGljaCBjYXNlIHdlIHdhbnQgdG8gaW50ZXJwcmV0IHRoaXMgYXMgbm8gZW5kIHRpbWVcbiAgICB0aW1lc3RhbXA6IGNvcmUuc3BhblRpbWVJbnB1dFRvU2Vjb25kcyhlbmRUaW1lKSB8fCB1bmRlZmluZWQsXG4gICAgc3RhdHVzOiBjb3JlLmdldFN0YXR1c01lc3NhZ2Uoc3RhdHVzKSwgLy8gQXMgcGVyIHByb3RvY29sLCBzcGFuIHN0YXR1cyBpcyBhbGxvd2VkIHRvIGJlIHVuZGVmaW5lZFxuICAgIG9wLFxuICAgIG9yaWdpbixcbiAgICBtZWFzdXJlbWVudHM6IGNvcmUudGltZWRFdmVudHNUb01lYXN1cmVtZW50cyhzcGFuLmV2ZW50cyksXG4gICAgbGlua3M6IGNvcmUuY29udmVydFNwYW5MaW5rc0ZvckVudmVsb3BlKGxpbmtzKSxcbiAgfTtcblxuICBzcGFucy5wdXNoKHNwYW5KU09OKTtcblxuICBub2RlLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgIGNyZWF0ZUFuZEZpbmlzaFNwYW5Gb3JPdGVsU3BhbihjaGlsZCwgc3BhbnMsIHNlbnRTcGFucyk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRTcGFuRGF0YShzcGFuKVxuXG4ge1xuICBjb25zdCB7IG9wOiBkZWZpbmVkT3AsIHNvdXJjZTogZGVmaW5lZFNvdXJjZSwgb3JpZ2luIH0gPSBwYXJzZVNwYW4oc3Bhbik7XG4gIGNvbnN0IHsgb3A6IGluZmVycmVkT3AsIGRlc2NyaXB0aW9uLCBzb3VyY2U6IGluZmVycmVkU291cmNlLCBkYXRhOiBpbmZlcnJlZERhdGEgfSA9IHBhcnNlU3BhbkRlc2NyaXB0aW9uKHNwYW4pO1xuXG4gIGNvbnN0IG9wID0gZGVmaW5lZE9wIHx8IGluZmVycmVkT3A7XG4gIGNvbnN0IHNvdXJjZSA9IGRlZmluZWRTb3VyY2UgfHwgaW5mZXJyZWRTb3VyY2U7XG5cbiAgY29uc3QgZGF0YSA9IHsgLi4uaW5mZXJyZWREYXRhLCAuLi5nZXREYXRhKHNwYW4pIH07XG5cbiAgcmV0dXJuIHtcbiAgICBvcCxcbiAgICBkZXNjcmlwdGlvbixcbiAgICBzb3VyY2UsXG4gICAgb3JpZ2luLFxuICAgIGRhdGEsXG4gIH07XG59XG5cbi8qKlxuICogUmVtb3ZlIGN1c3RvbSBgc2VudHJ5LmAgYXR0cmlidXRlcyB3ZSBkbyBub3QgbmVlZCB0byBzZW5kLlxuICogVGhlc2UgYXJlIG1vcmUgY2FycmllciBhdHRyaWJ1dGVzIHdlIHVzZSBpbnNpZGUgb2YgdGhlIFNESywgd2UgZG8gbm90IG5lZWQgdG8gc2VuZCB0aGVtIHRvIHRoZSBBUEkuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZVNlbnRyeUF0dHJpYnV0ZXMoZGF0YSkge1xuICBjb25zdCBjbGVhbmVkRGF0YSA9IHsgLi4uZGF0YSB9O1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1keW5hbWljLWRlbGV0ZSAqL1xuICBkZWxldGUgY2xlYW5lZERhdGFbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NBTVBMRV9SQVRFXTtcbiAgZGVsZXRlIGNsZWFuZWREYXRhW1NFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfUEFSRU5UX0lTX1JFTU9URV07XG4gIGRlbGV0ZSBjbGVhbmVkRGF0YVtjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfQ1VTVE9NX1NQQU5fTkFNRV07XG4gIC8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWR5bmFtaWMtZGVsZXRlICovXG5cbiAgcmV0dXJuIGNsZWFuZWREYXRhO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhKHNwYW4pIHtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHNwYW4uYXR0cmlidXRlcztcbiAgY29uc3QgZGF0YSA9IHt9O1xuXG4gIGlmIChzcGFuLmtpbmQgIT09IGFwaS5TcGFuS2luZC5JTlRFUk5BTCkge1xuICAgIGRhdGFbJ290ZWwua2luZCddID0gYXBpLlNwYW5LaW5kW3NwYW4ua2luZF07XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgY29uc3QgbWF5YmVIdHRwU3RhdHVzQ29kZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19IVFRQX1NUQVRVU19DT0RFXTtcbiAgaWYgKG1heWJlSHR0cFN0YXR1c0NvZGVBdHRyaWJ1dGUpIHtcbiAgICBkYXRhW3NlbWFudGljQ29udmVudGlvbnMuQVRUUl9IVFRQX1JFU1BPTlNFX1NUQVRVU19DT0RFXSA9IG1heWJlSHR0cFN0YXR1c0NvZGVBdHRyaWJ1dGUgO1xuICB9XG5cbiAgY29uc3QgcmVxdWVzdERhdGEgPSBnZXRSZXF1ZXN0U3BhbkRhdGEoc3Bhbik7XG5cbiAgaWYgKHJlcXVlc3REYXRhLnVybCkge1xuICAgIGRhdGEudXJsID0gcmVxdWVzdERhdGEudXJsO1xuICB9XG5cbiAgaWYgKHJlcXVlc3REYXRhWydodHRwLnF1ZXJ5J10pIHtcbiAgICBkYXRhWydodHRwLnF1ZXJ5J10gPSByZXF1ZXN0RGF0YVsnaHR0cC5xdWVyeSddLnNsaWNlKDEpO1xuICB9XG4gIGlmIChyZXF1ZXN0RGF0YVsnaHR0cC5mcmFnbWVudCddKSB7XG4gICAgZGF0YVsnaHR0cC5mcmFnbWVudCddID0gcmVxdWVzdERhdGFbJ2h0dHAuZnJhZ21lbnQnXS5zbGljZSgxKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBvblNwYW5TdGFydChzcGFuLCBwYXJlbnRDb250ZXh0KSB7XG4gIC8vIFRoaXMgaXMgYSByZWxpYWJsZSB3YXkgdG8gZ2V0IHRoZSBwYXJlbnQgc3BhbiAtIGJlY2F1c2UgdGhpcyBpcyBleGFjdGx5IGhvdyB0aGUgcGFyZW50IGlzIGlkZW50aWZpZWQgaW4gdGhlIE9URUwgU0RLXG4gIGNvbnN0IHBhcmVudFNwYW4gPSBhcGkudHJhY2UuZ2V0U3BhbihwYXJlbnRDb250ZXh0KTtcblxuICBsZXQgc2NvcGVzID0gZ2V0U2NvcGVzRnJvbUNvbnRleHQocGFyZW50Q29udGV4dCk7XG5cbiAgLy8gV2UgbmVlZCBhY2Nlc3MgdG8gdGhlIHBhcmVudCBzcGFuIGluIG9yZGVyIHRvIGJlIGFibGUgdG8gbW92ZSB1cCB0aGUgc3BhbiB0cmVlIGZvciBicmVhZGNydW1ic1xuICBpZiAocGFyZW50U3BhbiAmJiAhcGFyZW50U3Bhbi5zcGFuQ29udGV4dCgpLmlzUmVtb3RlKSB7XG4gICAgY29yZS5hZGRDaGlsZFNwYW5Ub1NwYW4ocGFyZW50U3Bhbiwgc3Bhbik7XG4gIH1cblxuICAvLyBXZSBuZWVkIHRoaXMgaW4gdGhlIHNwYW4gZXhwb3J0ZXJcbiAgaWYgKHBhcmVudFNwYW4/LnNwYW5Db250ZXh0KCkuaXNSZW1vdGUpIHtcbiAgICBzcGFuLnNldEF0dHJpYnV0ZShTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1BBUkVOVF9JU19SRU1PVEUsIHRydWUpO1xuICB9XG5cbiAgLy8gVGhlIHJvb3QgY29udGV4dCBkb2VzIG5vdCBoYXZlIHNjb3BlcyBzdG9yZWQsIHNvIHdlIGNoZWNrIGZvciB0aGlzIHNwZWNpZmljYWxseVxuICAvLyBBcyBmYWxsYmFjayB3ZSBhdHRhY2ggdGhlIGdsb2JhbCBzY29wZXNcbiAgaWYgKHBhcmVudENvbnRleHQgPT09IGFwaS5ST09UX0NPTlRFWFQpIHtcbiAgICBzY29wZXMgPSB7XG4gICAgICBzY29wZTogY29yZS5nZXREZWZhdWx0Q3VycmVudFNjb3BlKCksXG4gICAgICBpc29sYXRpb25TY29wZTogY29yZS5nZXREZWZhdWx0SXNvbGF0aW9uU2NvcGUoKSxcbiAgICB9O1xuICB9XG5cbiAgLy8gV2UgbmVlZCB0aGUgc2NvcGUgYXQgdGltZSBvZiBzcGFuIGNyZWF0aW9uIGluIG9yZGVyIHRvIGFwcGx5IGl0IHRvIHRoZSBldmVudCB3aGVuIHRoZSBzcGFuIGlzIGZpbmlzaGVkXG4gIGlmIChzY29wZXMpIHtcbiAgICBjb3JlLnNldENhcHR1cmVkU2NvcGVzT25TcGFuKHNwYW4sIHNjb3Blcy5zY29wZSwgc2NvcGVzLmlzb2xhdGlvblNjb3BlKTtcbiAgfVxuXG4gIGNvcmUubG9nU3BhblN0YXJ0KHNwYW4pO1xuXG4gIGNvbnN0IGNsaWVudCA9IGNvcmUuZ2V0Q2xpZW50KCk7XG4gIGNsaWVudD8uZW1pdCgnc3BhblN0YXJ0Jywgc3Bhbik7XG59XG5cbmZ1bmN0aW9uIG9uU3BhbkVuZChzcGFuKSB7XG4gIGNvcmUubG9nU3BhbkVuZChzcGFuKTtcblxuICBjb25zdCBjbGllbnQgPSBjb3JlLmdldENsaWVudCgpO1xuICBjbGllbnQ/LmVtaXQoJ3NwYW5FbmQnLCBzcGFuKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBPcGVuVGVsZW1ldHJ5IFNwYW5zIHRvIFNlbnRyeSBTcGFucyBhbmQgc2VuZHMgdGhlbSB0byBTZW50cnkgdmlhXG4gKiB0aGUgU2VudHJ5IFNESy5cbiAqL1xuY2xhc3MgU2VudHJ5U3BhblByb2Nlc3NvciAge1xuXG4gICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc2V0SXNTZXR1cCgnU2VudHJ5U3BhblByb2Nlc3NvcicpO1xuICAgIHRoaXMuX2V4cG9ydGVyID0gbmV3IFNlbnRyeVNwYW5FeHBvcnRlcihvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIGFzeW5jIGZvcmNlRmx1c2goKSB7XG4gICAgdGhpcy5fZXhwb3J0ZXIuZmx1c2goKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIGFzeW5jIHNodXRkb3duKCkge1xuICAgIHRoaXMuX2V4cG9ydGVyLmNsZWFyKCk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBvblN0YXJ0KHNwYW4sIHBhcmVudENvbnRleHQpIHtcbiAgICBvblNwYW5TdGFydChzcGFuLCBwYXJlbnRDb250ZXh0KTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgb25FbmQoc3Bhbikge1xuICAgIG9uU3BhbkVuZChzcGFuKTtcblxuICAgIHRoaXMuX2V4cG9ydGVyLmV4cG9ydChzcGFuKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgY3VzdG9tIE9URUwgc2FtcGxlciB0aGF0IHVzZXMgU2VudHJ5IHNhbXBsaW5nIHJhdGVzIHRvIG1ha2UgaXRzIGRlY2lzaW9uXG4gKi9cbmNsYXNzIFNlbnRyeVNhbXBsZXIgIHtcblxuICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIHNldElzU2V0dXAoJ1NlbnRyeVNhbXBsZXInKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgc2hvdWxkU2FtcGxlKFxuICAgIGNvbnRleHQsXG4gICAgdHJhY2VJZCxcbiAgICBzcGFuTmFtZSxcbiAgICBzcGFuS2luZCxcbiAgICBzcGFuQXR0cmlidXRlcyxcbiAgICBfbGlua3MsXG4gICkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9jbGllbnQuZ2V0T3B0aW9ucygpO1xuXG4gICAgY29uc3QgcGFyZW50U3BhbiA9IGdldFZhbGlkU3Bhbihjb250ZXh0KTtcbiAgICBjb25zdCBwYXJlbnRDb250ZXh0ID0gcGFyZW50U3Bhbj8uc3BhbkNvbnRleHQoKTtcblxuICAgIGlmICghY29yZS5oYXNTcGFuc0VuYWJsZWQob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiB3cmFwU2FtcGxpbmdEZWNpc2lvbih7IGRlY2lzaW9uOiB1bmRlZmluZWQsIGNvbnRleHQsIHNwYW5BdHRyaWJ1dGVzIH0pO1xuICAgIH1cblxuICAgIC8vIGBBVFRSX0hUVFBfUkVRVUVTVF9NRVRIT0RgIGlzIHRoZSBuZXcgYXR0cmlidXRlLCBidXQgd2Ugc3RpbGwgc3VwcG9ydCB0aGUgb2xkIG9uZSwgYFNFTUFUVFJTX0hUVFBfTUVUSE9EYCwgZm9yIG5vdy5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICBjb25zdCBtYXliZVNwYW5IdHRwTWV0aG9kID0gc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19IVFRQX01FVEhPRF0gfHwgc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5BVFRSX0hUVFBfUkVRVUVTVF9NRVRIT0RdO1xuXG4gICAgLy8gSWYgd2UgaGF2ZSBhIGh0dHAuY2xpZW50IHNwYW4gdGhhdCBoYXMgbm8gbG9jYWwgcGFyZW50LCB3ZSBuZXZlciB3YW50IHRvIHNhbXBsZSBpdFxuICAgIC8vIGJ1dCB3ZSB3YW50IHRvIGxlYXZlIGRvd25zdHJlYW0gc2FtcGxpbmcgZGVjaXNpb25zIHVwIHRvIHRoZSBzZXJ2ZXJcbiAgICBpZiAoc3BhbktpbmQgPT09IGFwaS5TcGFuS2luZC5DTElFTlQgJiYgbWF5YmVTcGFuSHR0cE1ldGhvZCAmJiAoIXBhcmVudFNwYW4gfHwgcGFyZW50Q29udGV4dD8uaXNSZW1vdGUpKSB7XG4gICAgICByZXR1cm4gd3JhcFNhbXBsaW5nRGVjaXNpb24oeyBkZWNpc2lvbjogdW5kZWZpbmVkLCBjb250ZXh0LCBzcGFuQXR0cmlidXRlcyB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJlbnRTYW1wbGVkID0gcGFyZW50U3BhbiA/IGdldFBhcmVudFNhbXBsZWQocGFyZW50U3BhbiwgdHJhY2VJZCwgc3Bhbk5hbWUpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGlzUm9vdFNwYW4gPSAhcGFyZW50U3BhbiB8fCBwYXJlbnRDb250ZXh0Py5pc1JlbW90ZTtcblxuICAgIC8vIFdlIG9ubHkgc2FtcGxlIGJhc2VkIG9uIHBhcmFtZXRlcnMgKGxpa2UgdHJhY2VzU2FtcGxlUmF0ZSBvciB0cmFjZXNTYW1wbGVyKSBmb3Igcm9vdCBzcGFucyAod2hpY2ggaXMgZG9uZSBpbiBzYW1wbGVTcGFuKS5cbiAgICAvLyBOb24tcm9vdC1zcGFucyBzaW1wbHkgaW5oZXJpdCB0aGUgc2FtcGxpbmcgZGVjaXNpb24gZnJvbSB0aGVpciBwYXJlbnQuXG4gICAgaWYgKCFpc1Jvb3RTcGFuKSB7XG4gICAgICByZXR1cm4gd3JhcFNhbXBsaW5nRGVjaXNpb24oe1xuICAgICAgICBkZWNpc2lvbjogcGFyZW50U2FtcGxlZCA/IHNka1RyYWNlQmFzZS5TYW1wbGluZ0RlY2lzaW9uLlJFQ09SRF9BTkRfU0FNUExFRCA6IHNka1RyYWNlQmFzZS5TYW1wbGluZ0RlY2lzaW9uLk5PVF9SRUNPUkQsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHNwYW5BdHRyaWJ1dGVzLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gV2Ugd2FudCB0byBwYXNzIHRoZSBpbmZlcnJlZCBuYW1lICYgYXR0cmlidXRlcyB0byB0aGUgc2FtcGxlciBtZXRob2RcbiAgICBjb25zdCB7XG4gICAgICBkZXNjcmlwdGlvbjogaW5mZXJyZWRTcGFuTmFtZSxcbiAgICAgIGRhdGE6IGluZmVycmVkQXR0cmlidXRlcyxcbiAgICAgIG9wLFxuICAgIH0gPSBpbmZlclNwYW5EYXRhKHNwYW5OYW1lLCBzcGFuQXR0cmlidXRlcywgc3BhbktpbmQpO1xuXG4gICAgY29uc3QgbWVyZ2VkQXR0cmlidXRlcyA9IHtcbiAgICAgIC4uLmluZmVycmVkQXR0cmlidXRlcyxcbiAgICAgIC4uLnNwYW5BdHRyaWJ1dGVzLFxuICAgIH07XG5cbiAgICBpZiAob3ApIHtcbiAgICAgIG1lcmdlZEF0dHJpYnV0ZXNbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09QXSA9IG9wO1xuICAgIH1cblxuICAgIGNvbnN0IG11dGFibGVTYW1wbGluZ0RlY2lzaW9uID0geyBkZWNpc2lvbjogdHJ1ZSB9O1xuICAgIHRoaXMuX2NsaWVudC5lbWl0KFxuICAgICAgJ2JlZm9yZVNhbXBsaW5nJyxcbiAgICAgIHtcbiAgICAgICAgc3BhbkF0dHJpYnV0ZXM6IG1lcmdlZEF0dHJpYnV0ZXMsXG4gICAgICAgIHNwYW5OYW1lOiBpbmZlcnJlZFNwYW5OYW1lLFxuICAgICAgICBwYXJlbnRTYW1wbGVkOiBwYXJlbnRTYW1wbGVkLFxuICAgICAgICBwYXJlbnRDb250ZXh0OiBwYXJlbnRDb250ZXh0LFxuICAgICAgfSxcbiAgICAgIG11dGFibGVTYW1wbGluZ0RlY2lzaW9uLFxuICAgICk7XG4gICAgaWYgKCFtdXRhYmxlU2FtcGxpbmdEZWNpc2lvbi5kZWNpc2lvbikge1xuICAgICAgcmV0dXJuIHdyYXBTYW1wbGluZ0RlY2lzaW9uKHsgZGVjaXNpb246IHVuZGVmaW5lZCwgY29udGV4dCwgc3BhbkF0dHJpYnV0ZXMgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBpc29sYXRpb25TY29wZSB9ID0gZ2V0U2NvcGVzRnJvbUNvbnRleHQoY29udGV4dCkgPz8ge307XG5cbiAgICBjb25zdCBkc2NTdHJpbmcgPSBwYXJlbnRDb250ZXh0Py50cmFjZVN0YXRlID8gcGFyZW50Q29udGV4dC50cmFjZVN0YXRlLmdldChTRU5UUllfVFJBQ0VfU1RBVEVfRFNDKSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBkc2MgPSBkc2NTdHJpbmcgPyBjb3JlLmJhZ2dhZ2VIZWFkZXJUb0R5bmFtaWNTYW1wbGluZ0NvbnRleHQoZHNjU3RyaW5nKSA6IHVuZGVmaW5lZDtcblxuICAgIGNvbnN0IHNhbXBsZVJhbmQgPSBjb3JlLnBhcnNlU2FtcGxlUmF0ZShkc2M/LnNhbXBsZV9yYW5kKSA/PyBNYXRoLnJhbmRvbSgpO1xuXG4gICAgY29uc3QgW3NhbXBsZWQsIHNhbXBsZVJhdGUsIGxvY2FsU2FtcGxlUmF0ZVdhc0FwcGxpZWRdID0gY29yZS5zYW1wbGVTcGFuKFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogaW5mZXJyZWRTcGFuTmFtZSxcbiAgICAgICAgYXR0cmlidXRlczogbWVyZ2VkQXR0cmlidXRlcyxcbiAgICAgICAgbm9ybWFsaXplZFJlcXVlc3Q6IGlzb2xhdGlvblNjb3BlPy5nZXRTY29wZURhdGEoKS5zZGtQcm9jZXNzaW5nTWV0YWRhdGEubm9ybWFsaXplZFJlcXVlc3QsXG4gICAgICAgIHBhcmVudFNhbXBsZWQsXG4gICAgICAgIHBhcmVudFNhbXBsZVJhdGU6IGNvcmUucGFyc2VTYW1wbGVSYXRlKGRzYz8uc2FtcGxlX3JhdGUpLFxuICAgICAgfSxcbiAgICAgIHNhbXBsZVJhbmQsXG4gICAgKTtcblxuICAgIGNvbnN0IG1ldGhvZCA9IGAke21heWJlU3Bhbkh0dHBNZXRob2R9YC50b1VwcGVyQ2FzZSgpO1xuICAgIGlmIChtZXRob2QgPT09ICdPUFRJT05TJyB8fCBtZXRob2QgPT09ICdIRUFEJykge1xuICAgICAgREVCVUdfQlVJTEQgJiYgY29yZS5kZWJ1Zy5sb2coYFtUcmFjaW5nXSBOb3Qgc2FtcGxpbmcgc3BhbiBiZWNhdXNlIEhUVFAgbWV0aG9kIGlzICcke21ldGhvZH0nIGZvciAke3NwYW5OYW1lfWApO1xuXG4gICAgICByZXR1cm4gd3JhcFNhbXBsaW5nRGVjaXNpb24oe1xuICAgICAgICBkZWNpc2lvbjogc2RrVHJhY2VCYXNlLlNhbXBsaW5nRGVjaXNpb24uTk9UX1JFQ09SRCxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgc3BhbkF0dHJpYnV0ZXMsXG4gICAgICAgIHNhbXBsZVJhbmQsXG4gICAgICAgIGRvd25zdHJlYW1UcmFjZVNhbXBsZVJhdGU6IDAsIC8vIHdlIGRvbid0IHdhbnQgdG8gc2FtcGxlIGFueXRoaW5nIGluIHRoZSBkb3duc3RyZWFtIHRyYWNlIGVpdGhlclxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgIXNhbXBsZWQgJiZcbiAgICAgIC8vIFdlIGNoZWNrIGZvciBgcGFyZW50U2FtcGxlZCA9PT0gdW5kZWZpbmVkYCBiZWNhdXNlIHdlIG9ubHkgd2FudCB0byByZWNvcmQgY2xpZW50IHJlcG9ydHMgZm9yIHNwYW5zIHRoYXQgYXJlIHRyYWNlIHJvb3RzIChpZS4gd2hlbiB0aGVyZSB3YXMgaW5jb21pbmcgdHJhY2UpXG4gICAgICBwYXJlbnRTYW1wbGVkID09PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIERFQlVHX0JVSUxEICYmIGNvcmUuZGVidWcubG9nKCdbVHJhY2luZ10gRGlzY2FyZGluZyByb290IHNwYW4gYmVjYXVzZSBpdHMgdHJhY2Ugd2FzIG5vdCBjaG9zZW4gdG8gYmUgc2FtcGxlZC4nKTtcbiAgICAgIHRoaXMuX2NsaWVudC5yZWNvcmREcm9wcGVkRXZlbnQoJ3NhbXBsZV9yYXRlJywgJ3RyYW5zYWN0aW9uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLndyYXBTYW1wbGluZ0RlY2lzaW9uKHtcbiAgICAgICAgZGVjaXNpb246IHNhbXBsZWQgPyBzZGtUcmFjZUJhc2UuU2FtcGxpbmdEZWNpc2lvbi5SRUNPUkRfQU5EX1NBTVBMRUQgOiBzZGtUcmFjZUJhc2UuU2FtcGxpbmdEZWNpc2lvbi5OT1RfUkVDT1JELFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBzcGFuQXR0cmlidXRlcyxcbiAgICAgICAgc2FtcGxlUmFuZCxcbiAgICAgICAgZG93bnN0cmVhbVRyYWNlU2FtcGxlUmF0ZTogbG9jYWxTYW1wbGVSYXRlV2FzQXBwbGllZCA/IHNhbXBsZVJhdGUgOiB1bmRlZmluZWQsXG4gICAgICB9KSxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgLy8gV2Ugc2V0IHRoZSBzYW1wbGUgcmF0ZSBvbiB0aGUgc3BhbiB3aGVuIGEgbG9jYWwgc2FtcGxlIHJhdGUgd2FzIGFwcGxpZWQgdG8gYmV0dGVyIHVuZGVyc3RhbmQgaG93IHRyYWNlcyB3ZXJlIHNhbXBsZWQgaW4gU2VudHJ5XG4gICAgICAgIFtjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU0FNUExFX1JBVEVdOiBsb2NhbFNhbXBsZVJhdGVXYXNBcHBsaWVkID8gc2FtcGxlUmF0ZSA6IHVuZGVmaW5lZCxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIHRoZSBzYW1wbGVyIG5hbWUgb3Igc2hvcnQgZGVzY3JpcHRpb24gd2l0aCB0aGUgY29uZmlndXJhdGlvbi4gKi9cbiAgIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnU2VudHJ5U2FtcGxlcic7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50U2FtcGxlZChwYXJlbnRTcGFuLCB0cmFjZUlkLCBzcGFuTmFtZSkge1xuICBjb25zdCBwYXJlbnRDb250ZXh0ID0gcGFyZW50U3Bhbi5zcGFuQ29udGV4dCgpO1xuXG4gIC8vIE9ubHkgaW5oZXJpdCBzYW1wbGUgcmF0ZSBpZiBgdHJhY2VJZGAgaXMgdGhlIHNhbWVcbiAgLy8gTm90ZSBmb3IgdGVzdGluZzogYGlzU3BhbkNvbnRleHRWYWxpZCgpYCBjaGVja3MgdGhlIGZvcm1hdCBvZiB0aGUgdHJhY2VJZC9zcGFuSWQsIHNvIHdlIG5lZWQgdG8gcGFzcyB2YWxpZCBvbmVzXG4gIGlmIChhcGkuaXNTcGFuQ29udGV4dFZhbGlkKHBhcmVudENvbnRleHQpICYmIHBhcmVudENvbnRleHQudHJhY2VJZCA9PT0gdHJhY2VJZCkge1xuICAgIGlmIChwYXJlbnRDb250ZXh0LmlzUmVtb3RlKSB7XG4gICAgICBjb25zdCBwYXJlbnRTYW1wbGVkID0gZ2V0U2FtcGxpbmdEZWNpc2lvbihwYXJlbnRTcGFuLnNwYW5Db250ZXh0KCkpO1xuICAgICAgREVCVUdfQlVJTEQgJiZcbiAgICAgICAgY29yZS5kZWJ1Zy5sb2coYFtUcmFjaW5nXSBJbmhlcml0aW5nIHJlbW90ZSBwYXJlbnQncyBzYW1wbGVkIGRlY2lzaW9uIGZvciAke3NwYW5OYW1lfTogJHtwYXJlbnRTYW1wbGVkfWApO1xuICAgICAgcmV0dXJuIHBhcmVudFNhbXBsZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50U2FtcGxlZCA9IGdldFNhbXBsaW5nRGVjaXNpb24ocGFyZW50Q29udGV4dCk7XG4gICAgREVCVUdfQlVJTEQgJiYgY29yZS5kZWJ1Zy5sb2coYFtUcmFjaW5nXSBJbmhlcml0aW5nIHBhcmVudCdzIHNhbXBsZWQgZGVjaXNpb24gZm9yICR7c3Bhbk5hbWV9OiAke3BhcmVudFNhbXBsZWR9YCk7XG4gICAgcmV0dXJuIHBhcmVudFNhbXBsZWQ7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFdyYXAgYSBzYW1wbGluZyBkZWNpc2lvbiB3aXRoIGRhdGEgdGhhdCBTZW50cnkgbmVlZHMgdG8gd29yayBwcm9wZXJseSB3aXRoIGl0LlxuICogSWYgeW91IHBhc3MgYGRlY2lzaW9uOiB1bmRlZmluZWRgLCBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYE5PVF9SRUNPUkRJTkdgLCBidXQgaW4gY29udHJhc3QgdG8gcGFzc2luZyBgTk9UX1JFQ09SRElOR2BcbiAqIGl0IHdpbGwgbm90IHByb3BhZ2F0ZSB0aGlzIGRlY2lzaW9uIHRvIGRvd25zdHJlYW0gU2VudHJ5IFNES3MuXG4gKi9cbmZ1bmN0aW9uIHdyYXBTYW1wbGluZ0RlY2lzaW9uKHtcbiAgZGVjaXNpb24sXG4gIGNvbnRleHQsXG4gIHNwYW5BdHRyaWJ1dGVzLFxuICBzYW1wbGVSYW5kLFxuICBkb3duc3RyZWFtVHJhY2VTYW1wbGVSYXRlLFxufVxuXG4pIHtcbiAgbGV0IHRyYWNlU3RhdGUgPSBnZXRCYXNlVHJhY2VTdGF0ZShjb250ZXh0LCBzcGFuQXR0cmlidXRlcyk7XG5cbiAgLy8gV2Ugd2lsbCBvdmVycmlkZSB0aGUgcHJvcGFnYXRlZCBzYW1wbGUgcmF0ZSBkb3duc3RyZWFtIHdoZW5cbiAgLy8gLSB0aGUgdHJhY2VzU2FtcGxlUmF0ZSBpcyBhcHBsaWVkXG4gIC8vIC0gdGhlIHRyYWNlc1NhbXBsZXIgaXMgaW52b2tlZFxuICAvLyBTaW5jZSB1bnNhbXBsZWQgT1RFTCBzcGFucyAoTm9uUmVjb3JkaW5nU3BhbnMpIGNhbm5vdCBob2xkIGF0dHJpYnV0ZXMgd2UgbmVlZCB0byBzdG9yZSB0aGlzIG9uIHRoZSAodHJhY2UpY29udGV4dC5cbiAgaWYgKGRvd25zdHJlYW1UcmFjZVNhbXBsZVJhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHRyYWNlU3RhdGUgPSB0cmFjZVN0YXRlLnNldChTRU5UUllfVFJBQ0VfU1RBVEVfU0FNUExFX1JBVEUsIGAke2Rvd25zdHJlYW1UcmFjZVNhbXBsZVJhdGV9YCk7XG4gIH1cblxuICBpZiAoc2FtcGxlUmFuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdHJhY2VTdGF0ZSA9IHRyYWNlU3RhdGUuc2V0KFNFTlRSWV9UUkFDRV9TVEFURV9TQU1QTEVfUkFORCwgYCR7c2FtcGxlUmFuZH1gKTtcbiAgfVxuXG4gIC8vIElmIHRoZSBkZWNpc2lvbiBpcyB1bmRlZmluZWQsIHdlIHRyZWF0IGl0IGFzIE5PVF9SRUNPUkRJTkcsIGJ1dCB3ZSBkb24ndCBwcm9wYWdhdGUgdGhpcyBkZWNpc2lvbiB0byBkb3duc3RyZWFtIFNES3NcbiAgLy8gV2hpY2ggaXMgZG9uZSBieSBub3Qgc2V0dGluZyBgU0VOVFJZX1RSQUNFX1NUQVRFX1NBTVBMRURfTk9UX1JFQ09SRElOR2AgdHJhY2VTdGF0ZVxuICBpZiAoZGVjaXNpb24gPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHsgZGVjaXNpb246IHNka1RyYWNlQmFzZS5TYW1wbGluZ0RlY2lzaW9uLk5PVF9SRUNPUkQsIHRyYWNlU3RhdGUgfTtcbiAgfVxuXG4gIGlmIChkZWNpc2lvbiA9PT0gc2RrVHJhY2VCYXNlLlNhbXBsaW5nRGVjaXNpb24uTk9UX1JFQ09SRCkge1xuICAgIHJldHVybiB7IGRlY2lzaW9uLCB0cmFjZVN0YXRlOiB0cmFjZVN0YXRlLnNldChTRU5UUllfVFJBQ0VfU1RBVEVfU0FNUExFRF9OT1RfUkVDT1JESU5HLCAnMScpIH07XG4gIH1cblxuICByZXR1cm4geyBkZWNpc2lvbiwgdHJhY2VTdGF0ZSB9O1xufVxuXG5mdW5jdGlvbiBnZXRCYXNlVHJhY2VTdGF0ZShjb250ZXh0LCBzcGFuQXR0cmlidXRlcykge1xuICBjb25zdCBwYXJlbnRTcGFuID0gYXBpLnRyYWNlLmdldFNwYW4oY29udGV4dCk7XG4gIGNvbnN0IHBhcmVudENvbnRleHQgPSBwYXJlbnRTcGFuPy5zcGFuQ29udGV4dCgpO1xuXG4gIGxldCB0cmFjZVN0YXRlID0gcGFyZW50Q29udGV4dD8udHJhY2VTdGF0ZSB8fCBuZXcgY29yZSQxLlRyYWNlU3RhdGUoKTtcblxuICAvLyBXZSBhbHdheXMga2VlcCB0aGUgVVJMIG9uIHRoZSB0cmFjZSBzdGF0ZSwgc28gd2UgY2FuIGFjY2VzcyBpdCBpbiB0aGUgcHJvcGFnYXRvclxuICAvLyBgQVRUUl9VUkxfRlVMTGAgaXMgdGhlIG5ldyBhdHRyaWJ1dGUsIGJ1dCB3ZSBzdGlsbCBzdXBwb3J0IHRoZSBvbGQgb25lLCBgQVRUUl9IVFRQX1VSTGAsIGZvciBub3cuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBjb25zdCB1cmwgPSBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfVVJMXSB8fCBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLkFUVFJfVVJMX0ZVTExdO1xuICBpZiAodXJsICYmIHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJhY2VTdGF0ZSA9IHRyYWNlU3RhdGUuc2V0KFNFTlRSWV9UUkFDRV9TVEFURV9VUkwsIHVybCk7XG4gIH1cblxuICByZXR1cm4gdHJhY2VTdGF0ZTtcbn1cblxuLyoqXG4gKiBJZiB0aGUgYWN0aXZlIHNwYW4gaXMgaW52YWxpZCwgd2Ugd2FudCB0byBpZ25vcmUgaXQgYXMgcGFyZW50LlxuICogVGhpcyBhbGlnbnMgd2l0aCBob3cgb3RlbCB0cmFjZXJzIGFuZCBkZWZhdWx0IHNhbXBsZXJzIGhhbmRsZSB0aGVzZSBjYXNlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsaWRTcGFuKGNvbnRleHQpIHtcbiAgY29uc3Qgc3BhbiA9IGFwaS50cmFjZS5nZXRTcGFuKGNvbnRleHQpO1xuICByZXR1cm4gc3BhbiAmJiBhcGkuaXNTcGFuQ29udGV4dFZhbGlkKHNwYW4uc3BhbkNvbnRleHQoKSkgPyBzcGFuIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnRzLmdldENsaWVudCA9IGNvcmUuZ2V0Q2xpZW50O1xuZXhwb3J0cy5nZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW4gPSBjb3JlLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbjtcbmV4cG9ydHMuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9HUkFQSFFMX09QRVJBVElPTiA9IFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfR1JBUEhRTF9PUEVSQVRJT047XG5leHBvcnRzLlNlbnRyeVByb3BhZ2F0b3IgPSBTZW50cnlQcm9wYWdhdG9yO1xuZXhwb3J0cy5TZW50cnlTYW1wbGVyID0gU2VudHJ5U2FtcGxlcjtcbmV4cG9ydHMuU2VudHJ5U3BhblByb2Nlc3NvciA9IFNlbnRyeVNwYW5Qcm9jZXNzb3I7XG5leHBvcnRzLmNvbnRpbnVlVHJhY2UgPSBjb250aW51ZVRyYWNlO1xuZXhwb3J0cy5lbmhhbmNlRHNjV2l0aE9wZW5UZWxlbWV0cnlSb290U3Bhbk5hbWUgPSBlbmhhbmNlRHNjV2l0aE9wZW5UZWxlbWV0cnlSb290U3Bhbk5hbWU7XG5leHBvcnRzLmdldEFjdGl2ZVNwYW4gPSBnZXRBY3RpdmVTcGFuO1xuZXhwb3J0cy5nZXRSZXF1ZXN0U3BhbkRhdGEgPSBnZXRSZXF1ZXN0U3BhbkRhdGE7XG5leHBvcnRzLmdldFNjb3Blc0Zyb21Db250ZXh0ID0gZ2V0U2NvcGVzRnJvbUNvbnRleHQ7XG5leHBvcnRzLmdldFNwYW5LaW5kID0gZ2V0U3BhbktpbmQ7XG5leHBvcnRzLmdldFRyYWNlQ29udGV4dEZvclNjb3BlID0gZ2V0VHJhY2VDb250ZXh0Rm9yU2NvcGU7XG5leHBvcnRzLmlzU2VudHJ5UmVxdWVzdFNwYW4gPSBpc1NlbnRyeVJlcXVlc3RTcGFuO1xuZXhwb3J0cy5vcGVuVGVsZW1ldHJ5U2V0dXBDaGVjayA9IG9wZW5UZWxlbWV0cnlTZXR1cENoZWNrO1xuZXhwb3J0cy5zZXRPcGVuVGVsZW1ldHJ5Q29udGV4dEFzeW5jQ29udGV4dFN0cmF0ZWd5ID0gc2V0T3BlblRlbGVtZXRyeUNvbnRleHRBc3luY0NvbnRleHRTdHJhdGVneTtcbmV4cG9ydHMuc2V0dXBFdmVudENvbnRleHRUcmFjZSA9IHNldHVwRXZlbnRDb250ZXh0VHJhY2U7XG5leHBvcnRzLnNob3VsZFByb3BhZ2F0ZVRyYWNlRm9yVXJsID0gc2hvdWxkUHJvcGFnYXRlVHJhY2VGb3JVcmw7XG5leHBvcnRzLnNwYW5IYXNBdHRyaWJ1dGVzID0gc3Bhbkhhc0F0dHJpYnV0ZXM7XG5leHBvcnRzLnNwYW5IYXNFdmVudHMgPSBzcGFuSGFzRXZlbnRzO1xuZXhwb3J0cy5zcGFuSGFzS2luZCA9IHNwYW5IYXNLaW5kO1xuZXhwb3J0cy5zcGFuSGFzTmFtZSA9IHNwYW5IYXNOYW1lO1xuZXhwb3J0cy5zcGFuSGFzUGFyZW50SWQgPSBzcGFuSGFzUGFyZW50SWQ7XG5leHBvcnRzLnNwYW5IYXNTdGF0dXMgPSBzcGFuSGFzU3RhdHVzO1xuZXhwb3J0cy5zdGFydEluYWN0aXZlU3BhbiA9IHN0YXJ0SW5hY3RpdmVTcGFuO1xuZXhwb3J0cy5zdGFydFNwYW4gPSBzdGFydFNwYW47XG5leHBvcnRzLnN0YXJ0U3Bhbk1hbnVhbCA9IHN0YXJ0U3Bhbk1hbnVhbDtcbmV4cG9ydHMuc3VwcHJlc3NUcmFjaW5nID0gc3VwcHJlc3NUcmFjaW5nO1xuZXhwb3J0cy53aXRoQWN0aXZlU3BhbiA9IHdpdGhBY3RpdmVTcGFuO1xuZXhwb3J0cy53cmFwQ2xpZW50Q2xhc3MgPSB3cmFwQ2xpZW50Q2xhc3M7XG5leHBvcnRzLndyYXBDb250ZXh0TWFuYWdlckNsYXNzID0gd3JhcENvbnRleHRNYW5hZ2VyQ2xhc3M7XG5leHBvcnRzLndyYXBTYW1wbGluZ0RlY2lzaW9uID0gd3JhcFNhbXBsaW5nRGVjaXNpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(instrument)/../../node_modules/.pnpm/@sentry+opentelemetry@10.17.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.1_lnanjtbeaorg7cpyd6d5aj7lji/node_modules/@sentry/opentelemetry/build/cjs/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@sentry+opentelemetry@10.17.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.1_lnanjtbeaorg7cpyd6d5aj7lji/node_modules/@sentry/opentelemetry/build/cjs/index.js":
/*!***************************************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@sentry+opentelemetry@10.17.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.1_lnanjtbeaorg7cpyd6d5aj7lji/node_modules/@sentry/opentelemetry/build/cjs/index.js ***!
  \***************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst semanticConventions = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.37.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nconst core = __webpack_require__(/*! @sentry/core */ \"(rsc)/../../node_modules/.pnpm/@sentry+core@10.17.0/node_modules/@sentry/core/build/cjs/index.js\");\nconst api = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst core$1 = __webpack_require__(/*! @opentelemetry/core */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+core@2.1.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\nconst sdkTraceBase = __webpack_require__(/*! @opentelemetry/sdk-trace-base */ \"(rsc)/../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@2.1.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/index.js\");\n\n/** If this attribute is true, it means that the parent is a remote span. */\nconst SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE = 'sentry.parentIsRemote';\n\n// These are not standardized yet, but used by the graphql instrumentation\nconst SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION = 'sentry.graphql.operation';\n\n/**\n * Get the parent span id from a span.\n * In OTel v1, the parent span id is accessed as `parentSpanId`\n * In OTel v2, the parent span id is accessed as `spanId` on the `parentSpanContext`\n */\nfunction getParentSpanId(span) {\n  if ('parentSpanId' in span) {\n    return span.parentSpanId ;\n  } else if ('parentSpanContext' in span) {\n    return (span.parentSpanContext )?.spanId;\n  }\n\n  return undefined;\n}\n\n/**\n * Check if a given span has attributes.\n * This is necessary because the base `Span` type does not have attributes,\n * so in places where we are passed a generic span, we need to check if we want to access them.\n */\nfunction spanHasAttributes(\n  span,\n) {\n  const castSpan = span ;\n  return !!castSpan.attributes && typeof castSpan.attributes === 'object';\n}\n\n/**\n * Check if a given span has a kind.\n * This is necessary because the base `Span` type does not have a kind,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasKind(span) {\n  const castSpan = span ;\n  return typeof castSpan.kind === 'number';\n}\n\n/**\n * Check if a given span has a status.\n * This is necessary because the base `Span` type does not have a status,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasStatus(\n  span,\n) {\n  const castSpan = span ;\n  return !!castSpan.status;\n}\n\n/**\n * Check if a given span has a name.\n * This is necessary because the base `Span` type does not have a name,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasName(span) {\n  const castSpan = span ;\n  return !!castSpan.name;\n}\n\n/**\n * Check if a given span has a kind.\n * This is necessary because the base `Span` type does not have a kind,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasParentId(\n  span,\n) {\n  const castSpan = span ;\n  return !!getParentSpanId(castSpan);\n}\n\n/**\n * Check if a given span has events.\n * This is necessary because the base `Span` type does not have events,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasEvents(\n  span,\n) {\n  const castSpan = span ;\n  return Array.isArray(castSpan.events);\n}\n\n/**\n * Get sanitizied request data from an OTEL span.\n */\nfunction getRequestSpanData(span) {\n  // The base `Span` type has no `attributes`, so we need to guard here against that\n  if (!spanHasAttributes(span)) {\n    return {};\n  }\n\n  // eslint-disable-next-line deprecation/deprecation\n  const maybeUrlAttribute = (span.attributes[semanticConventions.ATTR_URL_FULL] || span.attributes[semanticConventions.SEMATTRS_HTTP_URL])\n\n;\n\n  const data = {\n    url: maybeUrlAttribute,\n    // eslint-disable-next-line deprecation/deprecation\n    'http.method': (span.attributes[semanticConventions.ATTR_HTTP_REQUEST_METHOD] || span.attributes[semanticConventions.SEMATTRS_HTTP_METHOD])\n\n,\n  };\n\n  // Default to GET if URL is set but method is not\n  if (!data['http.method'] && data.url) {\n    data['http.method'] = 'GET';\n  }\n\n  try {\n    if (typeof maybeUrlAttribute === 'string') {\n      const url = core.parseUrl(maybeUrlAttribute);\n\n      data.url = core.getSanitizedUrlString(url);\n\n      if (url.search) {\n        data['http.query'] = url.search;\n      }\n      if (url.hash) {\n        data['http.fragment'] = url.hash;\n      }\n    }\n  } catch {\n    // ignore\n  }\n\n  return data;\n}\n\n// Typescript complains if we do not use `...args: any[]` for the mixin, with:\n// A mixin class must have a constructor with a single rest parameter of type 'any[]'.ts(2545)\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\n * Wrap an Client class with things we need for OpenTelemetry support.\n * Make sure that the Client class passed in is non-abstract!\n *\n * Usage:\n * const OpenTelemetryClient = getWrappedClientClass(NodeClient);\n * const client = new OpenTelemetryClient(options);\n */\nfunction wrapClientClass\n\n(ClientClass) {\n  // @ts-expect-error We just assume that this is non-abstract, if you pass in an abstract class this would make it non-abstract\n  class OpenTelemetryClient extends ClientClass  {\n\n     constructor(...args) {\n      super(...args);\n    }\n\n    /** Get the OTEL tracer. */\n     get tracer() {\n      if (this._tracer) {\n        return this._tracer;\n      }\n\n      const name = '@sentry/opentelemetry';\n      const version = core.SDK_VERSION;\n      const tracer = api.trace.getTracer(name, version);\n      this._tracer = tracer;\n\n      return tracer;\n    }\n\n    /**\n     * @inheritDoc\n     */\n     async flush(timeout) {\n      const provider = this.traceProvider;\n      await provider?.forceFlush();\n      return super.flush(timeout);\n    }\n  }\n\n  return OpenTelemetryClient ;\n}\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\n/**\n * Get the span kind from a span.\n * For whatever reason, this is not public API on the generic \"Span\" type,\n * so we need to check if we actually have a `SDKTraceBaseSpan` where we can fetch this from.\n * Otherwise, we fall back to `SpanKind.INTERNAL`.\n */\nfunction getSpanKind(span) {\n  if (spanHasKind(span)) {\n    return span.kind;\n  }\n\n  return api.SpanKind.INTERNAL;\n}\n\nconst SENTRY_TRACE_HEADER = 'sentry-trace';\nconst SENTRY_BAGGAGE_HEADER = 'baggage';\n\nconst SENTRY_TRACE_STATE_DSC = 'sentry.dsc';\nconst SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING = 'sentry.sampled_not_recording';\nconst SENTRY_TRACE_STATE_URL = 'sentry.url';\nconst SENTRY_TRACE_STATE_SAMPLE_RAND = 'sentry.sample_rand';\nconst SENTRY_TRACE_STATE_SAMPLE_RATE = 'sentry.sample_rate';\n\nconst SENTRY_SCOPES_CONTEXT_KEY = api.createContextKey('sentry_scopes');\n\nconst SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY = api.createContextKey('sentry_fork_isolation_scope');\n\nconst SENTRY_FORK_SET_SCOPE_CONTEXT_KEY = api.createContextKey('sentry_fork_set_scope');\n\nconst SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY = api.createContextKey('sentry_fork_set_isolation_scope');\n\nconst SCOPE_CONTEXT_FIELD = '_scopeContext';\n\n/**\n * Try to get the current scopes from the given OTEL context.\n * This requires a Context Manager that was wrapped with getWrappedContextManager.\n */\nfunction getScopesFromContext(context) {\n  return context.getValue(SENTRY_SCOPES_CONTEXT_KEY) ;\n}\n\n/**\n * Set the current scopes on an OTEL context.\n * This will return a forked context with the Propagation Context set.\n */\nfunction setScopesOnContext(context, scopes) {\n  return context.setValue(SENTRY_SCOPES_CONTEXT_KEY, scopes);\n}\n\n/**\n * Set the context on the scope so we can later look it up.\n * We need this to get the context from the scope in the `trace` functions.\n */\nfunction setContextOnScope(scope, context) {\n  core.addNonEnumerableProperty(scope, SCOPE_CONTEXT_FIELD, context);\n}\n\n/**\n * Get the context related to a scope.\n */\nfunction getContextFromScope(scope) {\n  return (scope )[SCOPE_CONTEXT_FIELD];\n}\n\n/**\n *\n * @param otelSpan Checks whether a given OTEL Span is an http request to sentry.\n * @returns boolean\n */\nfunction isSentryRequestSpan(span) {\n  if (!spanHasAttributes(span)) {\n    return false;\n  }\n\n  const { attributes } = span;\n\n  // `ATTR_URL_FULL` is the new attribute, but we still support the old one, `ATTR_HTTP_URL`, for now.\n  // eslint-disable-next-line deprecation/deprecation\n  const httpUrl = attributes[semanticConventions.SEMATTRS_HTTP_URL] || attributes[semanticConventions.ATTR_URL_FULL];\n\n  if (!httpUrl) {\n    return false;\n  }\n\n  return core.isSentryRequestUrl(httpUrl.toString(), core.getClient());\n}\n\n/**\n * OpenTelemetry only knows about SAMPLED or NONE decision,\n * but for us it is important to differentiate between unset and unsampled.\n *\n * Both of these are identified as `traceFlags === TracegFlags.NONE`,\n * but we additionally look at a special trace state to differentiate between them.\n */\nfunction getSamplingDecision(spanContext) {\n  const { traceFlags, traceState } = spanContext;\n\n  const sampledNotRecording = traceState ? traceState.get(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING) === '1' : false;\n\n  // If trace flag is `SAMPLED`, we interpret this as sampled\n  // If it is `NONE`, it could mean either it was sampled to be not recorder, or that it was not sampled at all\n  // For us this is an important difference, sow e look at the SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING\n  // to identify which it is\n  if (traceFlags === api.TraceFlags.SAMPLED) {\n    return true;\n  }\n\n  if (sampledNotRecording) {\n    return false;\n  }\n\n  // Fall back to DSC as a last resort, that may also contain `sampled`...\n  const dscString = traceState ? traceState.get(SENTRY_TRACE_STATE_DSC) : undefined;\n  const dsc = dscString ? core.baggageHeaderToDynamicSamplingContext(dscString) : undefined;\n\n  if (dsc?.sampled === 'true') {\n    return true;\n  }\n  if (dsc?.sampled === 'false') {\n    return false;\n  }\n\n  return undefined;\n}\n\n/**\n * Infer the op & description for a set of name, attributes and kind of a span.\n */\nfunction inferSpanData(spanName, attributes, kind) {\n  // if http.method exists, this is an http request span\n  // eslint-disable-next-line deprecation/deprecation\n  const httpMethod = attributes[semanticConventions.ATTR_HTTP_REQUEST_METHOD] || attributes[semanticConventions.SEMATTRS_HTTP_METHOD];\n  if (httpMethod) {\n    return descriptionForHttpMethod({ attributes, name: spanName, kind }, httpMethod);\n  }\n\n  // eslint-disable-next-line deprecation/deprecation\n  const dbSystem = attributes[semanticConventions.SEMATTRS_DB_SYSTEM];\n  const opIsCache =\n    typeof attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_OP] === 'string' &&\n    attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_OP].startsWith('cache.');\n\n  // If db.type exists then this is a database call span\n  // If the Redis DB is used as a cache, the span description should not be changed\n  if (dbSystem && !opIsCache) {\n    return descriptionForDbSystem({ attributes, name: spanName });\n  }\n\n  const customSourceOrRoute = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === 'custom' ? 'custom' : 'route';\n\n  // If rpc.service exists then this is a rpc call span.\n  // eslint-disable-next-line deprecation/deprecation\n  const rpcService = attributes[semanticConventions.SEMATTRS_RPC_SERVICE];\n  if (rpcService) {\n    return {\n      ...getUserUpdatedNameAndSource(spanName, attributes, 'route'),\n      op: 'rpc',\n    };\n  }\n\n  // If messaging.system exists then this is a messaging system span.\n  // eslint-disable-next-line deprecation/deprecation\n  const messagingSystem = attributes[semanticConventions.SEMATTRS_MESSAGING_SYSTEM];\n  if (messagingSystem) {\n    return {\n      ...getUserUpdatedNameAndSource(spanName, attributes, customSourceOrRoute),\n      op: 'message',\n    };\n  }\n\n  // If faas.trigger exists then this is a function as a service span.\n  // eslint-disable-next-line deprecation/deprecation\n  const faasTrigger = attributes[semanticConventions.SEMATTRS_FAAS_TRIGGER];\n  if (faasTrigger) {\n    return {\n      ...getUserUpdatedNameAndSource(spanName, attributes, customSourceOrRoute),\n      op: faasTrigger.toString(),\n    };\n  }\n\n  return { op: undefined, description: spanName, source: 'custom' };\n}\n\n/**\n * Extract better op/description from an otel span.\n *\n * Does not overwrite the span name if the source is already set to custom to ensure\n * that user-updated span names are preserved. In this case, we only adjust the op but\n * leave span description and source unchanged.\n *\n * Based on https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/7422ce2a06337f68a59b552b8c5a2ac125d6bae5/exporter/sentryexporter/sentry_exporter.go#L306\n */\nfunction parseSpanDescription(span) {\n  const attributes = spanHasAttributes(span) ? span.attributes : {};\n  const name = spanHasName(span) ? span.name : '<unknown>';\n  const kind = getSpanKind(span);\n\n  return inferSpanData(name, attributes, kind);\n}\n\nfunction descriptionForDbSystem({ attributes, name }) {\n  // if we already have a custom name, we don't overwrite it but only set the op\n  const userDefinedName = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n  if (typeof userDefinedName === 'string') {\n    return {\n      op: 'db',\n      description: userDefinedName,\n      source: (attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] ) || 'custom',\n    };\n  }\n\n  // if we already have the source set to custom, we don't overwrite the span description but only set the op\n  if (attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === 'custom') {\n    return { op: 'db', description: name, source: 'custom' };\n  }\n\n  // Use DB statement (Ex \"SELECT * FROM table\") if possible as description.\n  // eslint-disable-next-line deprecation/deprecation\n  const statement = attributes[semanticConventions.SEMATTRS_DB_STATEMENT];\n\n  const description = statement ? statement.toString() : name;\n\n  return { op: 'db', description, source: 'task' };\n}\n\n/** Only exported for tests. */\nfunction descriptionForHttpMethod(\n  { name, kind, attributes },\n  httpMethod,\n) {\n  const opParts = ['http'];\n\n  switch (kind) {\n    case api.SpanKind.CLIENT:\n      opParts.push('client');\n      break;\n    case api.SpanKind.SERVER:\n      opParts.push('server');\n      break;\n  }\n\n  // Spans for HTTP requests we have determined to be prefetch requests will have a `.prefetch` postfix in the op\n  if (attributes['sentry.http.prefetch']) {\n    opParts.push('prefetch');\n  }\n\n  const { urlPath, url, query, fragment, hasRoute } = getSanitizedUrl(attributes, kind);\n\n  if (!urlPath) {\n    return { ...getUserUpdatedNameAndSource(name, attributes), op: opParts.join('.') };\n  }\n\n  const graphqlOperationsAttribute = attributes[SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION];\n\n  // Ex. GET /api/users\n  const baseDescription = `${httpMethod} ${urlPath}`;\n\n  // When the http span has a graphql operation, append it to the description\n  // We add these in the graphqlIntegration\n  const inferredDescription = graphqlOperationsAttribute\n    ? `${baseDescription} (${getGraphqlOperationNamesFromAttribute(graphqlOperationsAttribute)})`\n    : baseDescription;\n\n  // If `httpPath` is a root path, then we can categorize the transaction source as route.\n  const inferredSource = hasRoute || urlPath === '/' ? 'route' : 'url';\n\n  const data = {};\n\n  if (url) {\n    data.url = url;\n  }\n  if (query) {\n    data['http.query'] = query;\n  }\n  if (fragment) {\n    data['http.fragment'] = fragment;\n  }\n\n  // If the span kind is neither client nor server, we use the original name\n  // this infers that somebody manually started this span, in which case we don't want to overwrite the name\n  const isClientOrServerKind = kind === api.SpanKind.CLIENT || kind === api.SpanKind.SERVER;\n\n  // If the span is an auto-span (=it comes from one of our instrumentations),\n  // we always want to infer the name\n  // this is necessary because some of the auto-instrumentation we use uses kind=INTERNAL\n  const origin = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] || 'manual';\n  const isManualSpan = !`${origin}`.startsWith('auto');\n\n  // If users (or in very rare occasions we) set the source to custom, we don't overwrite the name\n  const alreadyHasCustomSource = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === 'custom';\n  const customSpanName = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n\n  const useInferredDescription =\n    !alreadyHasCustomSource && customSpanName == null && (isClientOrServerKind || !isManualSpan);\n\n  const { description, source } = useInferredDescription\n    ? { description: inferredDescription, source: inferredSource }\n    : getUserUpdatedNameAndSource(name, attributes);\n\n  return {\n    op: opParts.join('.'),\n    description,\n    source,\n    data,\n  };\n}\n\nfunction getGraphqlOperationNamesFromAttribute(attr) {\n  if (Array.isArray(attr)) {\n    const sorted = attr.slice().sort();\n\n    // Up to 5 items, we just add all of them\n    if (sorted.length <= 5) {\n      return sorted.join(', ');\n    } else {\n      // Else, we add the first 5 and the diff of other operations\n      return `${sorted.slice(0, 5).join(', ')}, +${sorted.length - 5}`;\n    }\n  }\n\n  return `${attr}`;\n}\n\n/** Exported for tests only */\nfunction getSanitizedUrl(\n  attributes,\n  kind,\n)\n\n {\n  // This is the relative path of the URL, e.g. /sub\n  // eslint-disable-next-line deprecation/deprecation\n  const httpTarget = attributes[semanticConventions.SEMATTRS_HTTP_TARGET];\n  // This is the full URL, including host & query params etc., e.g. https://example.com/sub?foo=bar\n  // eslint-disable-next-line deprecation/deprecation\n  const httpUrl = attributes[semanticConventions.SEMATTRS_HTTP_URL] || attributes[semanticConventions.ATTR_URL_FULL];\n  // This is the normalized route name - may not always be available!\n  const httpRoute = attributes[semanticConventions.ATTR_HTTP_ROUTE];\n\n  const parsedUrl = typeof httpUrl === 'string' ? core.parseUrl(httpUrl) : undefined;\n  const url = parsedUrl ? core.getSanitizedUrlString(parsedUrl) : undefined;\n  const query = parsedUrl?.search || undefined;\n  const fragment = parsedUrl?.hash || undefined;\n\n  if (typeof httpRoute === 'string') {\n    return { urlPath: httpRoute, url, query, fragment, hasRoute: true };\n  }\n\n  if (kind === api.SpanKind.SERVER && typeof httpTarget === 'string') {\n    return { urlPath: core.stripUrlQueryAndFragment(httpTarget), url, query, fragment, hasRoute: false };\n  }\n\n  if (parsedUrl) {\n    return { urlPath: url, url, query, fragment, hasRoute: false };\n  }\n\n  // fall back to target even for client spans, if no URL is present\n  if (typeof httpTarget === 'string') {\n    return { urlPath: core.stripUrlQueryAndFragment(httpTarget), url, query, fragment, hasRoute: false };\n  }\n\n  return { urlPath: undefined, url, query, fragment, hasRoute: false };\n}\n\n/**\n * Because Otel instrumentation sometimes mutates span names via `span.updateName`, the only way\n * to ensure that a user-set span name is preserved is to store it as a tmp attribute on the span.\n * We delete this attribute once we're done with it when preparing the event envelope.\n *\n * This temp attribute always takes precedence over the original name.\n *\n * We also need to take care of setting the correct source. Users can always update the source\n * after updating the name, so we need to respect that.\n *\n * @internal exported only for testing\n */\nfunction getUserUpdatedNameAndSource(\n  originalName,\n  attributes,\n  fallbackSource = 'custom',\n)\n\n {\n  const source = (attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] ) || fallbackSource;\n  const description = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n\n  if (description && typeof description === 'string') {\n    return {\n      description,\n      source,\n    };\n  }\n\n  return { description: originalName, source };\n}\n\n/**\n * Setup a DSC handler on the passed client,\n * ensuring that the transaction name is inferred from the span correctly.\n */\nfunction enhanceDscWithOpenTelemetryRootSpanName(client) {\n  client.on('createDsc', (dsc, rootSpan) => {\n    if (!rootSpan) {\n      return;\n    }\n\n    // We want to overwrite the transaction on the DSC that is created by default in core\n    // The reason for this is that we want to infer the span name, not use the initial one\n    // Otherwise, we'll get names like \"GET\" instead of e.g. \"GET /foo\"\n    // `parseSpanDescription` takes the attributes of the span into account for the name\n    // This mutates the passed-in DSC\n\n    const jsonSpan = core.spanToJSON(rootSpan);\n    const attributes = jsonSpan.data;\n    const source = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n\n    const { description } = spanHasName(rootSpan) ? parseSpanDescription(rootSpan) : { description: undefined };\n    if (source !== 'url' && description) {\n      dsc.transaction = description;\n    }\n\n    // Also ensure sampling decision is correctly inferred\n    // In core, we use `spanIsSampled`, which just looks at the trace flags\n    // but in OTEL, we use a slightly more complex logic to be able to differntiate between unsampled and deferred sampling\n    if (core.hasSpansEnabled()) {\n      const sampled = getSamplingDecision(rootSpan.spanContext());\n      dsc.sampled = sampled == undefined ? undefined : String(sampled);\n    }\n  });\n}\n\n/**\n * Returns the currently active span.\n */\nfunction getActiveSpan() {\n  return api.trace.getActiveSpan();\n}\n\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nconst DEBUG_BUILD = (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__);\n\n/**\n * Generate a TraceState for the given data.\n */\nfunction makeTraceState({\n  dsc,\n  sampled,\n}\n\n) {\n  // We store the DSC as OTEL trace state on the span context\n  const dscString = dsc ? core.dynamicSamplingContextToSentryBaggageHeader(dsc) : undefined;\n\n  const traceStateBase = new core$1.TraceState();\n\n  const traceStateWithDsc = dscString ? traceStateBase.set(SENTRY_TRACE_STATE_DSC, dscString) : traceStateBase;\n\n  // We also specifically want to store if this is sampled to be not recording,\n  // or unsampled (=could be either sampled or not)\n  return sampled === false ? traceStateWithDsc.set(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING, '1') : traceStateWithDsc;\n}\n\nconst setupElements = new Set();\n\n/** Get all the OpenTelemetry elements that have been set up. */\nfunction openTelemetrySetupCheck() {\n  return Array.from(setupElements);\n}\n\n/** Mark an OpenTelemetry element as setup. */\nfunction setIsSetup(element) {\n  setupElements.add(element);\n}\n\n/**\n * Injects and extracts `sentry-trace` and `baggage` headers from carriers.\n */\nclass SentryPropagator extends core$1.W3CBaggagePropagator {\n  /** A map of URLs that have already been checked for if they match tracePropagationTargets. */\n\n   constructor() {\n    super();\n    setIsSetup('SentryPropagator');\n\n    // We're caching results so we don't have to recompute regexp every time we create a request.\n    this._urlMatchesTargetsMap = new core.LRUMap(100);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   inject(context, carrier, setter) {\n    if (core$1.isTracingSuppressed(context)) {\n      DEBUG_BUILD && core.debug.log('[Tracing] Not injecting trace data for url because tracing is suppressed.');\n      return;\n    }\n\n    const activeSpan = api.trace.getSpan(context);\n    const url = activeSpan && getCurrentURL(activeSpan);\n\n    const tracePropagationTargets = core.getClient()?.getOptions()?.tracePropagationTargets;\n    if (!shouldPropagateTraceForUrl(url, tracePropagationTargets, this._urlMatchesTargetsMap)) {\n      DEBUG_BUILD &&\n        core.debug.log('[Tracing] Not injecting trace data for url because it does not match tracePropagationTargets:', url);\n      return;\n    }\n\n    const existingBaggageHeader = getExistingBaggage(carrier);\n    let baggage = api.propagation.getBaggage(context) || api.propagation.createBaggage({});\n\n    const { dynamicSamplingContext, traceId, spanId, sampled } = getInjectionData(context);\n\n    if (existingBaggageHeader) {\n      const baggageEntries = core.parseBaggageHeader(existingBaggageHeader);\n\n      if (baggageEntries) {\n        Object.entries(baggageEntries).forEach(([key, value]) => {\n          baggage = baggage.setEntry(key, { value });\n        });\n      }\n    }\n\n    if (dynamicSamplingContext) {\n      baggage = Object.entries(dynamicSamplingContext).reduce((b, [dscKey, dscValue]) => {\n        if (dscValue) {\n          return b.setEntry(`${core.SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`, { value: dscValue });\n        }\n        return b;\n      }, baggage);\n    }\n\n    // We also want to avoid setting the default OTEL trace ID, if we get that for whatever reason\n    if (traceId && traceId !== api.INVALID_TRACEID) {\n      setter.set(carrier, SENTRY_TRACE_HEADER, core.generateSentryTraceHeader(traceId, spanId, sampled));\n    }\n\n    super.inject(api.propagation.setBaggage(context, baggage), carrier, setter);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   extract(context, carrier, getter) {\n    const maybeSentryTraceHeader = getter.get(carrier, SENTRY_TRACE_HEADER);\n    const baggage = getter.get(carrier, SENTRY_BAGGAGE_HEADER);\n\n    const sentryTrace = maybeSentryTraceHeader\n      ? Array.isArray(maybeSentryTraceHeader)\n        ? maybeSentryTraceHeader[0]\n        : maybeSentryTraceHeader\n      : undefined;\n\n    // Add remote parent span context\n    // If there is no incoming trace, this will return the context as-is\n    return ensureScopesOnContext(getContextWithRemoteActiveSpan(context, { sentryTrace, baggage }));\n  }\n\n  /**\n   * @inheritDoc\n   */\n   fields() {\n    return [SENTRY_TRACE_HEADER, SENTRY_BAGGAGE_HEADER];\n  }\n}\n\nconst NOT_PROPAGATED_MESSAGE =\n  '[Tracing] Not injecting trace data for url because it does not match tracePropagationTargets:';\n\n/**\n * Check if a given URL should be propagated to or not.\n * If no url is defined, or no trace propagation targets are defined, this will always return `true`.\n * You can also optionally provide a decision map, to cache decisions and avoid repeated regex lookups.\n */\nfunction shouldPropagateTraceForUrl(\n  url,\n  tracePropagationTargets,\n  decisionMap,\n) {\n  if (typeof url !== 'string' || !tracePropagationTargets) {\n    return true;\n  }\n\n  const cachedDecision = decisionMap?.get(url);\n  if (cachedDecision !== undefined) {\n    DEBUG_BUILD && !cachedDecision && core.debug.log(NOT_PROPAGATED_MESSAGE, url);\n    return cachedDecision;\n  }\n\n  const decision = core.stringMatchesSomePattern(url, tracePropagationTargets);\n  decisionMap?.set(url, decision);\n\n  DEBUG_BUILD && !decision && core.debug.log(NOT_PROPAGATED_MESSAGE, url);\n  return decision;\n}\n\n/**\n * Get propagation injection data for the given context.\n * The additional options can be passed to override the scope and client that is otherwise derived from the context.\n */\nfunction getInjectionData(\n  context,\n  options = {},\n)\n\n {\n  const span = api.trace.getSpan(context);\n\n  // If we have a remote span, the spanId should be considered as the parentSpanId, not spanId itself\n  // Instead, we use a virtual (generated) spanId for propagation\n  if (span?.spanContext().isRemote) {\n    const spanContext = span.spanContext();\n    const dynamicSamplingContext = core.getDynamicSamplingContextFromSpan(span);\n\n    return {\n      dynamicSamplingContext,\n      traceId: spanContext.traceId,\n      spanId: undefined,\n      sampled: getSamplingDecision(spanContext), // TODO: Do we need to change something here?\n    };\n  }\n\n  // If we have a local span, we just use this\n  if (span) {\n    const spanContext = span.spanContext();\n    const dynamicSamplingContext = core.getDynamicSamplingContextFromSpan(span);\n\n    return {\n      dynamicSamplingContext,\n      traceId: spanContext.traceId,\n      spanId: spanContext.spanId,\n      sampled: getSamplingDecision(spanContext), // TODO: Do we need to change something here?\n    };\n  }\n\n  // Else we try to use the propagation context from the scope\n  // The only scenario where this should happen is when we neither have a span, nor an incoming trace\n  const scope = options.scope || getScopesFromContext(context)?.scope || core.getCurrentScope();\n  const client = options.client || core.getClient();\n\n  const propagationContext = scope.getPropagationContext();\n  const dynamicSamplingContext = client ? core.getDynamicSamplingContextFromScope(client, scope) : undefined;\n  return {\n    dynamicSamplingContext,\n    traceId: propagationContext.traceId,\n    spanId: propagationContext.propagationSpanId,\n    sampled: propagationContext.sampled,\n  };\n}\n\nfunction getContextWithRemoteActiveSpan(\n  ctx,\n  { sentryTrace, baggage },\n) {\n  const propagationContext = core.propagationContextFromHeaders(sentryTrace, baggage);\n\n  const { traceId, parentSpanId, sampled, dsc } = propagationContext;\n\n  const client = core.getClient();\n  const incomingDsc = core.baggageHeaderToDynamicSamplingContext(baggage);\n\n  // We only want to set the virtual span if we are continuing a concrete trace\n  // Otherwise, we ignore the incoming trace here, e.g. if we have no trace headers\n  if (!parentSpanId || (client && !core.shouldContinueTrace(client, incomingDsc?.org_id))) {\n    return ctx;\n  }\n\n  const spanContext = generateRemoteSpanContext({\n    traceId,\n    spanId: parentSpanId,\n    sampled,\n    dsc,\n  });\n\n  return api.trace.setSpanContext(ctx, spanContext);\n}\n\n/**\n * Takes trace strings and propagates them as a remote active span.\n * This should be used in addition to `continueTrace` in OTEL-powered environments.\n */\nfunction continueTraceAsRemoteSpan(\n  ctx,\n  options,\n  callback,\n) {\n  const ctxWithSpanContext = ensureScopesOnContext(getContextWithRemoteActiveSpan(ctx, options));\n\n  return api.context.with(ctxWithSpanContext, callback);\n}\n\nfunction ensureScopesOnContext(ctx) {\n  // If there are no scopes yet on the context, ensure we have them\n  const scopes = getScopesFromContext(ctx);\n  const newScopes = {\n    // If we have no scope here, this is most likely either the root context or a context manually derived from it\n    // In this case, we want to fork the current scope, to ensure we do not pollute the root scope\n    scope: scopes ? scopes.scope : core.getCurrentScope().clone(),\n    isolationScope: scopes ? scopes.isolationScope : core.getIsolationScope(),\n  };\n\n  return setScopesOnContext(ctx, newScopes);\n}\n\n/** Try to get the existing baggage header so we can merge this in. */\nfunction getExistingBaggage(carrier) {\n  try {\n    const baggage = (carrier )[SENTRY_BAGGAGE_HEADER];\n    return Array.isArray(baggage) ? baggage.join(',') : baggage;\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * It is pretty tricky to get access to the outgoing request URL of a request in the propagator.\n * As we only have access to the context of the span to be sent and the carrier (=headers),\n * but the span may be unsampled and thus have no attributes.\n *\n * So we use the following logic:\n * 1. If we have an active span, we check if it has a URL attribute.\n * 2. Else, if the active span has no URL attribute (e.g. it is unsampled), we check a special trace state (which we set in our sampler).\n */\nfunction getCurrentURL(span) {\n  const spanData = core.spanToJSON(span).data;\n  // `ATTR_URL_FULL` is the new attribute, but we still support the old one, `SEMATTRS_HTTP_URL`, for now.\n  // eslint-disable-next-line deprecation/deprecation\n  const urlAttribute = spanData[semanticConventions.SEMATTRS_HTTP_URL] || spanData[semanticConventions.ATTR_URL_FULL];\n  if (typeof urlAttribute === 'string') {\n    return urlAttribute;\n  }\n\n  // Also look at the traceState, which we may set in the sampler even for unsampled spans\n  const urlTraceState = span.spanContext().traceState?.get(SENTRY_TRACE_STATE_URL);\n  if (urlTraceState) {\n    return urlTraceState;\n  }\n\n  return undefined;\n}\n\nfunction generateRemoteSpanContext({\n  spanId,\n  traceId,\n  sampled,\n  dsc,\n}\n\n) {\n  // We store the DSC as OTEL trace state on the span context\n  const traceState = makeTraceState({\n    dsc,\n    sampled,\n  });\n\n  const spanContext = {\n    traceId,\n    spanId,\n    isRemote: true,\n    traceFlags: sampled ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE,\n    traceState,\n  };\n\n  return spanContext;\n}\n\n/**\n * Wraps a function with a transaction/span and finishes the span after the function is done.\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * If you want to create a span that is not set as active, use {@link startInactiveSpan}.\n *\n * You'll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startSpan(options, callback) {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !api.trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? core$1.suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    return tracer.startActiveSpan(name, spanOptions, ctx, span => {\n      return core.handleCallbackErrors(\n        () => callback(span),\n        () => {\n          // Only set the span status to ERROR when there wasn't any status set before, in order to avoid stomping useful span statuses\n          if (core.spanToJSON(span).status === undefined) {\n            span.setStatus({ code: api.SpanStatusCode.ERROR });\n          }\n        },\n        () => span.end(),\n      );\n    });\n  });\n}\n\n/**\n * Similar to `Sentry.startSpan`. Wraps a function with a span, but does not finish the span\n * after the function is done automatically. You'll have to call `span.end()` manually.\n *\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * You'll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startSpanManual(\n  options,\n  callback,\n) {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !api.trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? core$1.suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    return tracer.startActiveSpan(name, spanOptions, ctx, span => {\n      return core.handleCallbackErrors(\n        () => callback(span, () => span.end()),\n        () => {\n          // Only set the span status to ERROR when there wasn't any status set before, in order to avoid stomping useful span statuses\n          if (core.spanToJSON(span).status === undefined) {\n            span.setStatus({ code: api.SpanStatusCode.ERROR });\n          }\n        },\n      );\n    });\n  });\n}\n\n/**\n * Creates a span. This span is not set as active, so will not get automatic instrumentation spans\n * as children or be able to be accessed via `Sentry.getActiveSpan()`.\n *\n * If you want to create a span that is set as active, use {@link startSpan}.\n *\n * This function will always return a span,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startInactiveSpan(options) {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !api.trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? core$1.suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    const span = tracer.startSpan(name, spanOptions, ctx);\n\n    return span;\n  });\n}\n\n/**\n * Forks the current scope and sets the provided span as active span in the context of the provided callback. Can be\n * passed `null` to start an entirely new span tree.\n *\n * @param span Spans started in the context of the provided callback will be children of this span. If `null` is passed,\n * spans started within the callback will be root spans.\n * @param callback Execution context in which the provided span will be active. Is passed the newly forked scope.\n * @returns the value returned from the provided callback function.\n */\nfunction withActiveSpan(span, callback) {\n  const newContextWithActiveSpan = span ? api.trace.setSpan(api.context.active(), span) : api.trace.deleteSpan(api.context.active());\n  return api.context.with(newContextWithActiveSpan, () => callback(core.getCurrentScope()));\n}\n\nfunction getTracer() {\n  const client = core.getClient();\n  return client?.tracer || api.trace.getTracer('@sentry/opentelemetry', core.SDK_VERSION);\n}\n\nfunction getSpanOptions(options) {\n  const { startTime, attributes, kind, op, links } = options;\n\n  // OTEL expects timestamps in ms, not seconds\n  const fixedStartTime = typeof startTime === 'number' ? ensureTimestampInMilliseconds(startTime) : startTime;\n\n  return {\n    attributes: op\n      ? {\n          [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n          ...attributes,\n        }\n      : attributes,\n    kind,\n    links,\n    startTime: fixedStartTime,\n  };\n}\n\nfunction ensureTimestampInMilliseconds(timestamp) {\n  const isMs = timestamp < 9999999999;\n  return isMs ? timestamp * 1000 : timestamp;\n}\n\nfunction getContext(scope, forceTransaction) {\n  const ctx = getContextForScope(scope);\n  const parentSpan = api.trace.getSpan(ctx);\n\n  // In the case that we have no parent span, we start a new trace\n  // Note that if we continue a trace, we'll always have a remote parent span here anyhow\n  if (!parentSpan) {\n    return ctx;\n  }\n\n  // If we don't want to force a transaction, and we have a parent span, all good, we just return as-is!\n  if (!forceTransaction) {\n    return ctx;\n  }\n\n  // Else, if we do have a parent span but want to force a transaction, we have to simulate a \"root\" context\n\n  // Else, we need to do two things:\n  // 1. Unset the parent span from the context, so we'll create a new root span\n  // 2. Ensure the propagation context is correct, so we'll continue from the parent span\n  const ctxWithoutSpan = api.trace.deleteSpan(ctx);\n\n  const { spanId, traceId } = parentSpan.spanContext();\n  const sampled = getSamplingDecision(parentSpan.spanContext());\n\n  // In this case, when we are forcing a transaction, we want to treat this like continuing an incoming trace\n  // so we set the traceState according to the root span\n  const rootSpan = core.getRootSpan(parentSpan);\n  const dsc = core.getDynamicSamplingContextFromSpan(rootSpan);\n\n  const traceState = makeTraceState({\n    dsc,\n    sampled,\n  });\n\n  const spanOptions = {\n    traceId,\n    spanId,\n    isRemote: true,\n    traceFlags: sampled ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE,\n    traceState,\n  };\n\n  const ctxWithSpanContext = api.trace.setSpanContext(ctxWithoutSpan, spanOptions);\n\n  return ctxWithSpanContext;\n}\n\nfunction getContextForScope(scope) {\n  if (scope) {\n    const ctx = getContextFromScope(scope);\n    if (ctx) {\n      return ctx;\n    }\n  }\n\n  return api.context.active();\n}\n\n/**\n * Continue a trace from `sentry-trace` and `baggage` values.\n * These values can be obtained from incoming request headers, or in the browser from `<meta name=\"sentry-trace\">`\n * and `<meta name=\"baggage\">` HTML tags.\n *\n * Spans started with `startSpan`, `startSpanManual` and `startInactiveSpan`, within the callback will automatically\n * be attached to the incoming trace.\n *\n * This is a custom version of `continueTrace` that is used in OTEL-powered environments.\n * It propagates the trace as a remote span, in addition to setting it on the propagation context.\n */\nfunction continueTrace(options, callback) {\n  return continueTraceAsRemoteSpan(api.context.active(), options, callback);\n}\n\n/**\n * Get the trace context for a given scope.\n * We have a custom implementation here because we need an OTEL-specific way to get the span from a scope.\n */\nfunction getTraceContextForScope(\n  client,\n  scope,\n) {\n  const ctx = getContextFromScope(scope);\n  const span = ctx && api.trace.getSpan(ctx);\n\n  const traceContext = span ? core.spanToTraceContext(span) : core.getTraceContextFromScope(scope);\n\n  const dynamicSamplingContext = span\n    ? core.getDynamicSamplingContextFromSpan(span)\n    : core.getDynamicSamplingContextFromScope(client, scope);\n  return [dynamicSamplingContext, traceContext];\n}\n\nfunction getActiveSpanWrapper(parentSpan) {\n  return parentSpan !== undefined\n    ? (callback) => {\n        return withActiveSpan(parentSpan, callback);\n      }\n    : (callback) => callback();\n}\n\n/** Suppress tracing in the given callback, ensuring no spans are generated inside of it. */\nfunction suppressTracing(callback) {\n  const ctx = core$1.suppressTracing(api.context.active());\n  return api.context.with(ctx, callback);\n}\n\n/** Ensure the `trace` context is set on all events. */\nfunction setupEventContextTrace(client) {\n  client.on('preprocessEvent', event => {\n    const span = getActiveSpan();\n    // For transaction events, this is handled separately\n    // Because the active span may not be the span that is actually the transaction event\n    if (!span || event.type === 'transaction') {\n      return;\n    }\n\n    // If event has already set `trace` context, use that one.\n    event.contexts = {\n      trace: core.spanToTraceContext(span),\n      ...event.contexts,\n    };\n\n    const rootSpan = core.getRootSpan(span);\n\n    event.sdkProcessingMetadata = {\n      dynamicSamplingContext: core.getDynamicSamplingContextFromSpan(rootSpan),\n      ...event.sdkProcessingMetadata,\n    };\n\n    return event;\n  });\n}\n\n/**\n * Otel-specific implementation of `getTraceData`.\n * @see `@sentry/core` version of `getTraceData` for more information\n */\nfunction getTraceData({\n  span,\n  scope,\n  client,\n} = {}) {\n  let ctx = (scope && getContextFromScope(scope)) ?? api.context.active();\n\n  if (span) {\n    const { scope } = core.getCapturedScopesOnSpan(span);\n    // fall back to current context if for whatever reason we can't find the one of the span\n    ctx = (scope && getContextFromScope(scope)) || api.trace.setSpan(api.context.active(), span);\n  }\n\n  const { traceId, spanId, sampled, dynamicSamplingContext } = getInjectionData(ctx, { scope, client });\n\n  return {\n    'sentry-trace': core.generateSentryTraceHeader(traceId, spanId, sampled),\n    baggage: core.dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext),\n  };\n}\n\n/**\n * Sets the async context strategy to use follow the OTEL context under the hood.\n * We handle forking a hub inside of our custom OTEL Context Manager (./otelContextManager.ts)\n */\nfunction setOpenTelemetryContextAsyncContextStrategy() {\n  function getScopes() {\n    const ctx = api.context.active();\n    const scopes = getScopesFromContext(ctx);\n\n    if (scopes) {\n      return scopes;\n    }\n\n    // fallback behavior:\n    // if, for whatever reason, we can't find scopes on the context here, we have to fix this somehow\n    return {\n      scope: core.getDefaultCurrentScope(),\n      isolationScope: core.getDefaultIsolationScope(),\n    };\n  }\n\n  function withScope(callback) {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    // as by default, we don't want to fork this, unless triggered explicitly by `withScope`\n    return api.context.with(ctx, () => {\n      return callback(getCurrentScope());\n    });\n  }\n\n  function withSetScope(scope, callback) {\n    const ctx = getContextFromScope(scope) || api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_SET_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which picks up this scope as the current scope\n    return api.context.with(ctx.setValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY, scope), () => {\n      return callback(scope);\n    });\n  }\n\n  function withIsolationScope(callback) {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    return api.context.with(ctx.setValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY, true), () => {\n      return callback(getIsolationScope());\n    });\n  }\n\n  function withSetIsolationScope(isolationScope, callback) {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    return api.context.with(ctx.setValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY, isolationScope), () => {\n      return callback(getIsolationScope());\n    });\n  }\n\n  function getCurrentScope() {\n    return getScopes().scope;\n  }\n\n  function getIsolationScope() {\n    return getScopes().isolationScope;\n  }\n\n  core.setAsyncContextStrategy({\n    withScope,\n    withSetScope,\n    withSetIsolationScope,\n    withIsolationScope,\n    getCurrentScope,\n    getIsolationScope,\n    startSpan,\n    startSpanManual,\n    startInactiveSpan,\n    getActiveSpan,\n    suppressTracing,\n    getTraceData,\n    continueTrace,\n    // The types here don't fully align, because our own `Span` type is narrower\n    // than the OTEL one - but this is OK for here, as we now we'll only have OTEL spans passed around\n    withActiveSpan: withActiveSpan ,\n  });\n}\n\n/**\n * Wrap an OpenTelemetry ContextManager in a way that ensures the context is kept in sync with the Sentry Scope.\n *\n * Usage:\n * import { AsyncLocalStorageContextManager } from '@opentelemetry/context-async-hooks';\n * const SentryContextManager = wrapContextManagerClass(AsyncLocalStorageContextManager);\n * const contextManager = new SentryContextManager();\n */\nfunction wrapContextManagerClass(\n  ContextManagerClass,\n) {\n  /**\n   * This is a custom ContextManager for OpenTelemetry, which extends the default AsyncLocalStorageContextManager.\n   * It ensures that we create new scopes per context, so that the OTEL Context & the Sentry Scope are always in sync.\n   *\n   * Note that we currently only support AsyncHooks with this,\n   * but since this should work for Node 14+ anyhow that should be good enough.\n   */\n\n  // @ts-expect-error TS does not like this, but we know this is fine\n  class SentryContextManager extends ContextManagerClass {\n     constructor(...args) {\n      super(...args);\n      setIsSetup('SentryContextManager');\n    }\n    /**\n     * Overwrite with() of the original AsyncLocalStorageContextManager\n     * to ensure we also create new scopes per context.\n     */\n     with(\n      context,\n      fn,\n      thisArg,\n      ...args\n    ) {\n      const currentScopes = getScopesFromContext(context);\n      const currentScope = currentScopes?.scope || core.getCurrentScope();\n      const currentIsolationScope = currentScopes?.isolationScope || core.getIsolationScope();\n\n      const shouldForkIsolationScope = context.getValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY) === true;\n      const scope = context.getValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY) ;\n      const isolationScope = context.getValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY) ;\n\n      const newCurrentScope = scope || currentScope.clone();\n      const newIsolationScope =\n        isolationScope || (shouldForkIsolationScope ? currentIsolationScope.clone() : currentIsolationScope);\n      const scopes = { scope: newCurrentScope, isolationScope: newIsolationScope };\n\n      const ctx1 = setScopesOnContext(context, scopes);\n\n      // Remove the unneeded values again\n      const ctx2 = ctx1\n        .deleteValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY)\n        .deleteValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY)\n        .deleteValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY);\n\n      setContextOnScope(newCurrentScope, ctx2);\n\n      return super.with(ctx2, fn, thisArg, ...args);\n    }\n  }\n\n  return SentryContextManager ;\n}\n\n/**\n * This function runs through a list of OTEL Spans, and wraps them in an `SpanNode`\n * where each node holds a reference to their parent node.\n */\nfunction groupSpansWithParents(spans) {\n  const nodeMap = new Map();\n\n  for (const span of spans) {\n    createOrUpdateSpanNodeAndRefs(nodeMap, span);\n  }\n\n  return Array.from(nodeMap, function ([_id, spanNode]) {\n    return spanNode;\n  });\n}\n\n/**\n * This returns the _local_ parent ID - `parentId` on the span may point to a remote span.\n */\nfunction getLocalParentId(span) {\n  const parentIsRemote = span.attributes[SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE] === true;\n  // If the parentId is the trace parent ID, we pretend it's undefined\n  // As this means the parent exists somewhere else\n  return !parentIsRemote ? getParentSpanId(span) : undefined;\n}\n\nfunction createOrUpdateSpanNodeAndRefs(nodeMap, span) {\n  const id = span.spanContext().spanId;\n  const parentId = getLocalParentId(span);\n\n  if (!parentId) {\n    createOrUpdateNode(nodeMap, { id, span, children: [] });\n    return;\n  }\n\n  // Else make sure to create parent node as well\n  // Note that the parent may not know it's parent _yet_, this may be updated in a later pass\n  const parentNode = createOrGetParentNode(nodeMap, parentId);\n  const node = createOrUpdateNode(nodeMap, { id, span, parentNode, children: [] });\n  parentNode.children.push(node);\n}\n\nfunction createOrGetParentNode(nodeMap, id) {\n  const existing = nodeMap.get(id);\n\n  if (existing) {\n    return existing;\n  }\n\n  return createOrUpdateNode(nodeMap, { id, children: [] });\n}\n\nfunction createOrUpdateNode(nodeMap, spanNode) {\n  const existing = nodeMap.get(spanNode.id);\n\n  // If span is already set, nothing to do here\n  if (existing?.span) {\n    return existing;\n  }\n\n  // If it exists but span is not set yet, we update it\n  if (existing && !existing.span) {\n    existing.span = spanNode.span;\n    existing.parentNode = spanNode.parentNode;\n    return existing;\n  }\n\n  // Else, we create a new one...\n  nodeMap.set(spanNode.id, spanNode);\n  return spanNode;\n}\n\n// canonicalCodesGrpcMap maps some GRPC codes to Sentry's span statuses. See description in grpc documentation.\nconst canonicalGrpcErrorCodesMap = {\n  '1': 'cancelled',\n  '2': 'unknown_error',\n  '3': 'invalid_argument',\n  '4': 'deadline_exceeded',\n  '5': 'not_found',\n  '6': 'already_exists',\n  '7': 'permission_denied',\n  '8': 'resource_exhausted',\n  '9': 'failed_precondition',\n  '10': 'aborted',\n  '11': 'out_of_range',\n  '12': 'unimplemented',\n  '13': 'internal_error',\n  '14': 'unavailable',\n  '15': 'data_loss',\n  '16': 'unauthenticated',\n} ;\n\nconst isStatusErrorMessageValid = (message) => {\n  return Object.values(canonicalGrpcErrorCodesMap).includes(message );\n};\n\n/**\n * Get a Sentry span status from an otel span.\n */\nfunction mapStatus(span) {\n  const attributes = spanHasAttributes(span) ? span.attributes : {};\n  const status = spanHasStatus(span) ? span.status : undefined;\n\n  if (status) {\n    // Since span status OK is not set by default, we give it priority: https://opentelemetry.io/docs/concepts/signals/traces/#span-status\n    if (status.code === api.SpanStatusCode.OK) {\n      return { code: core.SPAN_STATUS_OK };\n      // If the span is already marked as erroneous we return that exact status\n    } else if (status.code === api.SpanStatusCode.ERROR) {\n      if (typeof status.message === 'undefined') {\n        const inferredStatus = inferStatusFromAttributes(attributes);\n        if (inferredStatus) {\n          return inferredStatus;\n        }\n      }\n\n      if (status.message && isStatusErrorMessageValid(status.message)) {\n        return { code: core.SPAN_STATUS_ERROR, message: status.message };\n      } else {\n        return { code: core.SPAN_STATUS_ERROR, message: 'unknown_error' };\n      }\n    }\n  }\n\n  // If the span status is UNSET, we try to infer it from HTTP or GRPC status codes.\n  const inferredStatus = inferStatusFromAttributes(attributes);\n\n  if (inferredStatus) {\n    return inferredStatus;\n  }\n\n  // We default to setting the spans status to ok.\n  if (status?.code === api.SpanStatusCode.UNSET) {\n    return { code: core.SPAN_STATUS_OK };\n  } else {\n    return { code: core.SPAN_STATUS_ERROR, message: 'unknown_error' };\n  }\n}\n\nfunction inferStatusFromAttributes(attributes) {\n  // If the span status is UNSET, we try to infer it from HTTP or GRPC status codes.\n\n  // eslint-disable-next-line deprecation/deprecation\n  const httpCodeAttribute = attributes[semanticConventions.ATTR_HTTP_RESPONSE_STATUS_CODE] || attributes[semanticConventions.SEMATTRS_HTTP_STATUS_CODE];\n  // eslint-disable-next-line deprecation/deprecation\n  const grpcCodeAttribute = attributes[semanticConventions.SEMATTRS_RPC_GRPC_STATUS_CODE];\n\n  const numberHttpCode =\n    typeof httpCodeAttribute === 'number'\n      ? httpCodeAttribute\n      : typeof httpCodeAttribute === 'string'\n        ? parseInt(httpCodeAttribute)\n        : undefined;\n\n  if (typeof numberHttpCode === 'number') {\n    return core.getSpanStatusFromHttpCode(numberHttpCode);\n  }\n\n  if (typeof grpcCodeAttribute === 'string') {\n    return { code: core.SPAN_STATUS_ERROR, message: canonicalGrpcErrorCodesMap[grpcCodeAttribute] || 'unknown_error' };\n  }\n\n  return undefined;\n}\n\nconst MAX_SPAN_COUNT = 1000;\nconst DEFAULT_TIMEOUT = 300; // 5 min\n\n/**\n * A Sentry-specific exporter that converts OpenTelemetry Spans to Sentry Spans & Transactions.\n */\nclass SentrySpanExporter {\n  /*\n   * A quick explanation on the buckets: We do bucketing of finished spans for efficiency. This span exporter is\n   * accumulating spans until a root span is encountered and then it flushes all the spans that are descendants of that\n   * root span. Because it is totally in the realm of possibilities that root spans are never finished, and we don't\n   * want to accumulate spans indefinitely in memory, we need to periodically evacuate spans. Naively we could simply\n   * store the spans in an array and each time a new span comes in we could iterate through the entire array and\n   * evacuate all spans that have an end-timestamp that is older than our limit. This could get quite expensive because\n   * we would have to iterate a potentially large number of spans every time we evacuate. We want to avoid these large\n   * bursts of computation.\n   *\n   * Instead we go for a bucketing approach and put spans into buckets, based on what second\n   * (modulo the time limit) the span was put into the exporter. With buckets, when we decide to evacuate, we can\n   * iterate through the bucket entries instead, which have an upper bound of items, making the evacuation much more\n   * efficient. Cleaning up also becomes much more efficient since it simply involves de-referencing a bucket within the\n   * bucket array, and letting garbage collection take care of the rest.\n   */\n\n  // Essentially a a set of span ids that are already sent. The values are expiration\n  // times in this cache so we don't hold onto them indefinitely.\n\n  /* Internally, we use a debounced flush to give some wiggle room to the span processor to accumulate more spans. */\n\n   constructor(options\n\n) {\n    this._finishedSpanBucketSize = options?.timeout || DEFAULT_TIMEOUT;\n    this._finishedSpanBuckets = new Array(this._finishedSpanBucketSize).fill(undefined);\n    this._lastCleanupTimestampInS = Math.floor(Date.now() / 1000);\n    this._spansToBucketEntry = new WeakMap();\n    this._sentSpans = new Map();\n    this._debouncedFlush = core.debounce(this.flush.bind(this), 1, { maxWait: 100 });\n  }\n\n  /**\n   * Export a single span.\n   * This is called by the span processor whenever a span is ended.\n   */\n   export(span) {\n    const currentTimestampInS = Math.floor(Date.now() / 1000);\n\n    if (this._lastCleanupTimestampInS !== currentTimestampInS) {\n      let droppedSpanCount = 0;\n      this._finishedSpanBuckets.forEach((bucket, i) => {\n        if (bucket && bucket.timestampInS <= currentTimestampInS - this._finishedSpanBucketSize) {\n          droppedSpanCount += bucket.spans.size;\n          this._finishedSpanBuckets[i] = undefined;\n        }\n      });\n      if (droppedSpanCount > 0) {\n        DEBUG_BUILD &&\n          core.debug.log(\n            `SpanExporter dropped ${droppedSpanCount} spans because they were pending for more than ${this._finishedSpanBucketSize} seconds.`,\n          );\n      }\n      this._lastCleanupTimestampInS = currentTimestampInS;\n    }\n\n    const currentBucketIndex = currentTimestampInS % this._finishedSpanBucketSize;\n    const currentBucket = this._finishedSpanBuckets[currentBucketIndex] || {\n      timestampInS: currentTimestampInS,\n      spans: new Set(),\n    };\n    this._finishedSpanBuckets[currentBucketIndex] = currentBucket;\n    currentBucket.spans.add(span);\n    this._spansToBucketEntry.set(span, currentBucket);\n\n    // If the span doesn't have a local parent ID (it's a root span), we're gonna flush all the ended spans\n    const localParentId = getLocalParentId(span);\n    if (!localParentId || this._sentSpans.has(localParentId)) {\n      this._debouncedFlush();\n    }\n  }\n\n  /**\n   * Try to flush any pending spans immediately.\n   * This is called internally by the exporter (via _debouncedFlush),\n   * but can also be triggered externally if we force-flush.\n   */\n   flush() {\n    const finishedSpans = this._finishedSpanBuckets.flatMap(bucket => (bucket ? Array.from(bucket.spans) : []));\n\n    this._flushSentSpanCache();\n    const sentSpans = this._maybeSend(finishedSpans);\n\n    const sentSpanCount = sentSpans.size;\n    const remainingOpenSpanCount = finishedSpans.length - sentSpanCount;\n    DEBUG_BUILD &&\n      core.debug.log(\n        `SpanExporter exported ${sentSpanCount} spans, ${remainingOpenSpanCount} spans are waiting for their parent spans to finish`,\n      );\n\n    const expirationDate = Date.now() + DEFAULT_TIMEOUT * 1000;\n\n    for (const span of sentSpans) {\n      this._sentSpans.set(span.spanContext().spanId, expirationDate);\n      const bucketEntry = this._spansToBucketEntry.get(span);\n      if (bucketEntry) {\n        bucketEntry.spans.delete(span);\n      }\n    }\n    // Cancel a pending debounced flush, if there is one\n    // This can be relevant if we directly flush, circumventing the debounce\n    // in that case, we want to cancel any pending debounced flush\n    this._debouncedFlush.cancel();\n  }\n\n  /**\n   * Clear the exporter.\n   * This is called when the span processor is shut down.\n   */\n   clear() {\n    this._finishedSpanBuckets = this._finishedSpanBuckets.fill(undefined);\n    this._sentSpans.clear();\n    this._debouncedFlush.cancel();\n  }\n\n  /**\n   * Send the given spans, but only if they are part of a finished transaction.\n   *\n   * Returns the sent spans.\n   * Spans remain unsent when their parent span is not yet finished.\n   * This will happen regularly, as child spans are generally finished before their parents.\n   * But it _could_ also happen because, for whatever reason, a parent span was lost.\n   * In this case, we'll eventually need to clean this up.\n   */\n   _maybeSend(spans) {\n    const grouped = groupSpansWithParents(spans);\n    const sentSpans = new Set();\n\n    const rootNodes = this._getCompletedRootNodes(grouped);\n\n    for (const root of rootNodes) {\n      const span = root.span;\n      sentSpans.add(span);\n      const transactionEvent = createTransactionForOtelSpan(span);\n\n      // Add an attribute to the transaction event to indicate that this transaction is an orphaned transaction\n      if (root.parentNode && this._sentSpans.has(root.parentNode.id)) {\n        const traceData = transactionEvent.contexts?.trace?.data;\n        if (traceData) {\n          traceData['sentry.parent_span_already_sent'] = true;\n        }\n      }\n\n      // We'll recursively add all the child spans to this array\n      const spans = transactionEvent.spans || [];\n\n      for (const child of root.children) {\n        createAndFinishSpanForOtelSpan(child, spans, sentSpans);\n      }\n\n      // spans.sort() mutates the array, but we do not use this anymore after this point\n      // so we can safely mutate it here\n      transactionEvent.spans =\n        spans.length > MAX_SPAN_COUNT\n          ? spans.sort((a, b) => a.start_timestamp - b.start_timestamp).slice(0, MAX_SPAN_COUNT)\n          : spans;\n\n      const measurements = core.timedEventsToMeasurements(span.events);\n      if (measurements) {\n        transactionEvent.measurements = measurements;\n      }\n\n      core.captureEvent(transactionEvent);\n    }\n\n    return sentSpans;\n  }\n\n  /** Remove \"expired\" span id entries from the _sentSpans cache. */\n   _flushSentSpanCache() {\n    const currentTimestamp = Date.now();\n    // Note, it is safe to delete items from the map as we go: https://stackoverflow.com/a/35943995/90297\n    for (const [spanId, expirationTime] of this._sentSpans.entries()) {\n      if (expirationTime <= currentTimestamp) {\n        this._sentSpans.delete(spanId);\n      }\n    }\n  }\n\n  /** Check if a node is a completed root node or a node whose parent has already been sent */\n   _nodeIsCompletedRootNodeOrHasSentParent(node) {\n    return !!node.span && (!node.parentNode || this._sentSpans.has(node.parentNode.id));\n  }\n\n  /** Get all completed root nodes from a list of nodes */\n   _getCompletedRootNodes(nodes) {\n    // TODO: We should be able to remove the explicit `node is SpanNodeCompleted` type guard\n    //       once we stop supporting TS < 5.5\n    return nodes.filter((node) => this._nodeIsCompletedRootNodeOrHasSentParent(node));\n  }\n}\n\nfunction parseSpan(span) {\n  const attributes = span.attributes;\n\n  const origin = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] ;\n  const op = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_OP] ;\n  const source = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] ;\n\n  return { origin, op, source };\n}\n\n/** Exported only for tests. */\nfunction createTransactionForOtelSpan(span) {\n  const { op, description, data, origin = 'manual', source } = getSpanData(span);\n  const capturedSpanScopes = core.getCapturedScopesOnSpan(span );\n\n  const sampleRate = span.attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE] ;\n\n  const attributes = {\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: sampleRate,\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: origin,\n    ...data,\n    ...removeSentryAttributes(span.attributes),\n  };\n\n  const { links } = span;\n  const { traceId: trace_id, spanId: span_id } = span.spanContext();\n\n  // If parentSpanIdFromTraceState is defined at all, we want it to take precedence\n  // In that case, an empty string should be interpreted as \"no parent span id\",\n  // even if `span.parentSpanId` is set\n  // this is the case when we are starting a new trace, where we have a virtual span based on the propagationContext\n  // We only want to continue the traceId in this case, but ignore the parent span\n  const parent_span_id = getParentSpanId(span);\n\n  const status = mapStatus(span);\n\n  const traceContext = {\n    parent_span_id,\n    span_id,\n    trace_id,\n    data: attributes,\n    origin,\n    op,\n    status: core.getStatusMessage(status), // As per protocol, span status is allowed to be undefined\n    links: core.convertSpanLinksForEnvelope(links),\n  };\n\n  const statusCode = attributes[semanticConventions.ATTR_HTTP_RESPONSE_STATUS_CODE];\n  const responseContext = typeof statusCode === 'number' ? { response: { status_code: statusCode } } : undefined;\n\n  const transactionEvent = {\n    contexts: {\n      trace: traceContext,\n      otel: {\n        resource: span.resource.attributes,\n      },\n      ...responseContext,\n    },\n    spans: [],\n    start_timestamp: core.spanTimeInputToSeconds(span.startTime),\n    timestamp: core.spanTimeInputToSeconds(span.endTime),\n    transaction: description,\n    type: 'transaction',\n    sdkProcessingMetadata: {\n      capturedSpanScope: capturedSpanScopes.scope,\n      capturedSpanIsolationScope: capturedSpanScopes.isolationScope,\n      sampleRate,\n      dynamicSamplingContext: core.getDynamicSamplingContextFromSpan(span ),\n    },\n    ...(source && {\n      transaction_info: {\n        source,\n      },\n    }),\n  };\n\n  return transactionEvent;\n}\n\nfunction createAndFinishSpanForOtelSpan(node, spans, sentSpans) {\n  const span = node.span;\n\n  if (span) {\n    sentSpans.add(span);\n  }\n\n  const shouldDrop = !span;\n\n  // If this span should be dropped, we still want to create spans for the children of this\n  if (shouldDrop) {\n    node.children.forEach(child => {\n      createAndFinishSpanForOtelSpan(child, spans, sentSpans);\n    });\n    return;\n  }\n\n  const span_id = span.spanContext().spanId;\n  const trace_id = span.spanContext().traceId;\n  const parentSpanId = getParentSpanId(span);\n\n  const { attributes, startTime, endTime, links } = span;\n\n  const { op, description, data, origin = 'manual' } = getSpanData(span);\n  const allData = {\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: origin,\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n    ...removeSentryAttributes(attributes),\n    ...data,\n  };\n\n  const status = mapStatus(span);\n\n  const spanJSON = {\n    span_id,\n    trace_id,\n    data: allData,\n    description,\n    parent_span_id: parentSpanId,\n    start_timestamp: core.spanTimeInputToSeconds(startTime),\n    // This is [0,0] by default in OTEL, in which case we want to interpret this as no end time\n    timestamp: core.spanTimeInputToSeconds(endTime) || undefined,\n    status: core.getStatusMessage(status), // As per protocol, span status is allowed to be undefined\n    op,\n    origin,\n    measurements: core.timedEventsToMeasurements(span.events),\n    links: core.convertSpanLinksForEnvelope(links),\n  };\n\n  spans.push(spanJSON);\n\n  node.children.forEach(child => {\n    createAndFinishSpanForOtelSpan(child, spans, sentSpans);\n  });\n}\n\nfunction getSpanData(span)\n\n {\n  const { op: definedOp, source: definedSource, origin } = parseSpan(span);\n  const { op: inferredOp, description, source: inferredSource, data: inferredData } = parseSpanDescription(span);\n\n  const op = definedOp || inferredOp;\n  const source = definedSource || inferredSource;\n\n  const data = { ...inferredData, ...getData(span) };\n\n  return {\n    op,\n    description,\n    source,\n    origin,\n    data,\n  };\n}\n\n/**\n * Remove custom `sentry.` attributes we do not need to send.\n * These are more carrier attributes we use inside of the SDK, we do not need to send them to the API.\n */\nfunction removeSentryAttributes(data) {\n  const cleanedData = { ...data };\n\n  /* eslint-disable @typescript-eslint/no-dynamic-delete */\n  delete cleanedData[core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE];\n  delete cleanedData[SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE];\n  delete cleanedData[core.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n  /* eslint-enable @typescript-eslint/no-dynamic-delete */\n\n  return cleanedData;\n}\n\nfunction getData(span) {\n  const attributes = span.attributes;\n  const data = {};\n\n  if (span.kind !== api.SpanKind.INTERNAL) {\n    data['otel.kind'] = api.SpanKind[span.kind];\n  }\n\n  // eslint-disable-next-line deprecation/deprecation\n  const maybeHttpStatusCodeAttribute = attributes[semanticConventions.SEMATTRS_HTTP_STATUS_CODE];\n  if (maybeHttpStatusCodeAttribute) {\n    data[semanticConventions.ATTR_HTTP_RESPONSE_STATUS_CODE] = maybeHttpStatusCodeAttribute ;\n  }\n\n  const requestData = getRequestSpanData(span);\n\n  if (requestData.url) {\n    data.url = requestData.url;\n  }\n\n  if (requestData['http.query']) {\n    data['http.query'] = requestData['http.query'].slice(1);\n  }\n  if (requestData['http.fragment']) {\n    data['http.fragment'] = requestData['http.fragment'].slice(1);\n  }\n\n  return data;\n}\n\nfunction onSpanStart(span, parentContext) {\n  // This is a reliable way to get the parent span - because this is exactly how the parent is identified in the OTEL SDK\n  const parentSpan = api.trace.getSpan(parentContext);\n\n  let scopes = getScopesFromContext(parentContext);\n\n  // We need access to the parent span in order to be able to move up the span tree for breadcrumbs\n  if (parentSpan && !parentSpan.spanContext().isRemote) {\n    core.addChildSpanToSpan(parentSpan, span);\n  }\n\n  // We need this in the span exporter\n  if (parentSpan?.spanContext().isRemote) {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE, true);\n  }\n\n  // The root context does not have scopes stored, so we check for this specifically\n  // As fallback we attach the global scopes\n  if (parentContext === api.ROOT_CONTEXT) {\n    scopes = {\n      scope: core.getDefaultCurrentScope(),\n      isolationScope: core.getDefaultIsolationScope(),\n    };\n  }\n\n  // We need the scope at time of span creation in order to apply it to the event when the span is finished\n  if (scopes) {\n    core.setCapturedScopesOnSpan(span, scopes.scope, scopes.isolationScope);\n  }\n\n  core.logSpanStart(span);\n\n  const client = core.getClient();\n  client?.emit('spanStart', span);\n}\n\nfunction onSpanEnd(span) {\n  core.logSpanEnd(span);\n\n  const client = core.getClient();\n  client?.emit('spanEnd', span);\n}\n\n/**\n * Converts OpenTelemetry Spans to Sentry Spans and sends them to Sentry via\n * the Sentry SDK.\n */\nclass SentrySpanProcessor  {\n\n   constructor(options) {\n    setIsSetup('SentrySpanProcessor');\n    this._exporter = new SentrySpanExporter(options);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   async forceFlush() {\n    this._exporter.flush();\n  }\n\n  /**\n   * @inheritDoc\n   */\n   async shutdown() {\n    this._exporter.clear();\n  }\n\n  /**\n   * @inheritDoc\n   */\n   onStart(span, parentContext) {\n    onSpanStart(span, parentContext);\n  }\n\n  /** @inheritDoc */\n   onEnd(span) {\n    onSpanEnd(span);\n\n    this._exporter.export(span);\n  }\n}\n\n/**\n * A custom OTEL sampler that uses Sentry sampling rates to make its decision\n */\nclass SentrySampler  {\n\n   constructor(client) {\n    this._client = client;\n    setIsSetup('SentrySampler');\n  }\n\n  /** @inheritDoc */\n   shouldSample(\n    context,\n    traceId,\n    spanName,\n    spanKind,\n    spanAttributes,\n    _links,\n  ) {\n    const options = this._client.getOptions();\n\n    const parentSpan = getValidSpan(context);\n    const parentContext = parentSpan?.spanContext();\n\n    if (!core.hasSpansEnabled(options)) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    // `ATTR_HTTP_REQUEST_METHOD` is the new attribute, but we still support the old one, `SEMATTRS_HTTP_METHOD`, for now.\n    // eslint-disable-next-line deprecation/deprecation\n    const maybeSpanHttpMethod = spanAttributes[semanticConventions.SEMATTRS_HTTP_METHOD] || spanAttributes[semanticConventions.ATTR_HTTP_REQUEST_METHOD];\n\n    // If we have a http.client span that has no local parent, we never want to sample it\n    // but we want to leave downstream sampling decisions up to the server\n    if (spanKind === api.SpanKind.CLIENT && maybeSpanHttpMethod && (!parentSpan || parentContext?.isRemote)) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    const parentSampled = parentSpan ? getParentSampled(parentSpan, traceId, spanName) : undefined;\n    const isRootSpan = !parentSpan || parentContext?.isRemote;\n\n    // We only sample based on parameters (like tracesSampleRate or tracesSampler) for root spans (which is done in sampleSpan).\n    // Non-root-spans simply inherit the sampling decision from their parent.\n    if (!isRootSpan) {\n      return wrapSamplingDecision({\n        decision: parentSampled ? sdkTraceBase.SamplingDecision.RECORD_AND_SAMPLED : sdkTraceBase.SamplingDecision.NOT_RECORD,\n        context,\n        spanAttributes,\n      });\n    }\n\n    // We want to pass the inferred name & attributes to the sampler method\n    const {\n      description: inferredSpanName,\n      data: inferredAttributes,\n      op,\n    } = inferSpanData(spanName, spanAttributes, spanKind);\n\n    const mergedAttributes = {\n      ...inferredAttributes,\n      ...spanAttributes,\n    };\n\n    if (op) {\n      mergedAttributes[core.SEMANTIC_ATTRIBUTE_SENTRY_OP] = op;\n    }\n\n    const mutableSamplingDecision = { decision: true };\n    this._client.emit(\n      'beforeSampling',\n      {\n        spanAttributes: mergedAttributes,\n        spanName: inferredSpanName,\n        parentSampled: parentSampled,\n        parentContext: parentContext,\n      },\n      mutableSamplingDecision,\n    );\n    if (!mutableSamplingDecision.decision) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    const { isolationScope } = getScopesFromContext(context) ?? {};\n\n    const dscString = parentContext?.traceState ? parentContext.traceState.get(SENTRY_TRACE_STATE_DSC) : undefined;\n    const dsc = dscString ? core.baggageHeaderToDynamicSamplingContext(dscString) : undefined;\n\n    const sampleRand = core.parseSampleRate(dsc?.sample_rand) ?? Math.random();\n\n    const [sampled, sampleRate, localSampleRateWasApplied] = core.sampleSpan(\n      options,\n      {\n        name: inferredSpanName,\n        attributes: mergedAttributes,\n        normalizedRequest: isolationScope?.getScopeData().sdkProcessingMetadata.normalizedRequest,\n        parentSampled,\n        parentSampleRate: core.parseSampleRate(dsc?.sample_rate),\n      },\n      sampleRand,\n    );\n\n    const method = `${maybeSpanHttpMethod}`.toUpperCase();\n    if (method === 'OPTIONS' || method === 'HEAD') {\n      DEBUG_BUILD && core.debug.log(`[Tracing] Not sampling span because HTTP method is '${method}' for ${spanName}`);\n\n      return wrapSamplingDecision({\n        decision: sdkTraceBase.SamplingDecision.NOT_RECORD,\n        context,\n        spanAttributes,\n        sampleRand,\n        downstreamTraceSampleRate: 0, // we don't want to sample anything in the downstream trace either\n      });\n    }\n\n    if (\n      !sampled &&\n      // We check for `parentSampled === undefined` because we only want to record client reports for spans that are trace roots (ie. when there was incoming trace)\n      parentSampled === undefined\n    ) {\n      DEBUG_BUILD && core.debug.log('[Tracing] Discarding root span because its trace was not chosen to be sampled.');\n      this._client.recordDroppedEvent('sample_rate', 'transaction');\n    }\n\n    return {\n      ...wrapSamplingDecision({\n        decision: sampled ? sdkTraceBase.SamplingDecision.RECORD_AND_SAMPLED : sdkTraceBase.SamplingDecision.NOT_RECORD,\n        context,\n        spanAttributes,\n        sampleRand,\n        downstreamTraceSampleRate: localSampleRateWasApplied ? sampleRate : undefined,\n      }),\n      attributes: {\n        // We set the sample rate on the span when a local sample rate was applied to better understand how traces were sampled in Sentry\n        [core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: localSampleRateWasApplied ? sampleRate : undefined,\n      },\n    };\n  }\n\n  /** Returns the sampler name or short description with the configuration. */\n   toString() {\n    return 'SentrySampler';\n  }\n}\n\nfunction getParentSampled(parentSpan, traceId, spanName) {\n  const parentContext = parentSpan.spanContext();\n\n  // Only inherit sample rate if `traceId` is the same\n  // Note for testing: `isSpanContextValid()` checks the format of the traceId/spanId, so we need to pass valid ones\n  if (api.isSpanContextValid(parentContext) && parentContext.traceId === traceId) {\n    if (parentContext.isRemote) {\n      const parentSampled = getSamplingDecision(parentSpan.spanContext());\n      DEBUG_BUILD &&\n        core.debug.log(`[Tracing] Inheriting remote parent's sampled decision for ${spanName}: ${parentSampled}`);\n      return parentSampled;\n    }\n\n    const parentSampled = getSamplingDecision(parentContext);\n    DEBUG_BUILD && core.debug.log(`[Tracing] Inheriting parent's sampled decision for ${spanName}: ${parentSampled}`);\n    return parentSampled;\n  }\n\n  return undefined;\n}\n\n/**\n * Wrap a sampling decision with data that Sentry needs to work properly with it.\n * If you pass `decision: undefined`, it will be treated as `NOT_RECORDING`, but in contrast to passing `NOT_RECORDING`\n * it will not propagate this decision to downstream Sentry SDKs.\n */\nfunction wrapSamplingDecision({\n  decision,\n  context,\n  spanAttributes,\n  sampleRand,\n  downstreamTraceSampleRate,\n}\n\n) {\n  let traceState = getBaseTraceState(context, spanAttributes);\n\n  // We will override the propagated sample rate downstream when\n  // - the tracesSampleRate is applied\n  // - the tracesSampler is invoked\n  // Since unsampled OTEL spans (NonRecordingSpans) cannot hold attributes we need to store this on the (trace)context.\n  if (downstreamTraceSampleRate !== undefined) {\n    traceState = traceState.set(SENTRY_TRACE_STATE_SAMPLE_RATE, `${downstreamTraceSampleRate}`);\n  }\n\n  if (sampleRand !== undefined) {\n    traceState = traceState.set(SENTRY_TRACE_STATE_SAMPLE_RAND, `${sampleRand}`);\n  }\n\n  // If the decision is undefined, we treat it as NOT_RECORDING, but we don't propagate this decision to downstream SDKs\n  // Which is done by not setting `SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING` traceState\n  if (decision == undefined) {\n    return { decision: sdkTraceBase.SamplingDecision.NOT_RECORD, traceState };\n  }\n\n  if (decision === sdkTraceBase.SamplingDecision.NOT_RECORD) {\n    return { decision, traceState: traceState.set(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING, '1') };\n  }\n\n  return { decision, traceState };\n}\n\nfunction getBaseTraceState(context, spanAttributes) {\n  const parentSpan = api.trace.getSpan(context);\n  const parentContext = parentSpan?.spanContext();\n\n  let traceState = parentContext?.traceState || new core$1.TraceState();\n\n  // We always keep the URL on the trace state, so we can access it in the propagator\n  // `ATTR_URL_FULL` is the new attribute, but we still support the old one, `ATTR_HTTP_URL`, for now.\n  // eslint-disable-next-line deprecation/deprecation\n  const url = spanAttributes[semanticConventions.SEMATTRS_HTTP_URL] || spanAttributes[semanticConventions.ATTR_URL_FULL];\n  if (url && typeof url === 'string') {\n    traceState = traceState.set(SENTRY_TRACE_STATE_URL, url);\n  }\n\n  return traceState;\n}\n\n/**\n * If the active span is invalid, we want to ignore it as parent.\n * This aligns with how otel tracers and default samplers handle these cases.\n */\nfunction getValidSpan(context) {\n  const span = api.trace.getSpan(context);\n  return span && api.isSpanContextValid(span.spanContext()) ? span : undefined;\n}\n\nexports.getClient = core.getClient;\nexports.getDynamicSamplingContextFromSpan = core.getDynamicSamplingContextFromSpan;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION = SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION;\nexports.SentryPropagator = SentryPropagator;\nexports.SentrySampler = SentrySampler;\nexports.SentrySpanProcessor = SentrySpanProcessor;\nexports.continueTrace = continueTrace;\nexports.enhanceDscWithOpenTelemetryRootSpanName = enhanceDscWithOpenTelemetryRootSpanName;\nexports.getActiveSpan = getActiveSpan;\nexports.getRequestSpanData = getRequestSpanData;\nexports.getScopesFromContext = getScopesFromContext;\nexports.getSpanKind = getSpanKind;\nexports.getTraceContextForScope = getTraceContextForScope;\nexports.isSentryRequestSpan = isSentryRequestSpan;\nexports.openTelemetrySetupCheck = openTelemetrySetupCheck;\nexports.setOpenTelemetryContextAsyncContextStrategy = setOpenTelemetryContextAsyncContextStrategy;\nexports.setupEventContextTrace = setupEventContextTrace;\nexports.shouldPropagateTraceForUrl = shouldPropagateTraceForUrl;\nexports.spanHasAttributes = spanHasAttributes;\nexports.spanHasEvents = spanHasEvents;\nexports.spanHasKind = spanHasKind;\nexports.spanHasName = spanHasName;\nexports.spanHasParentId = spanHasParentId;\nexports.spanHasStatus = spanHasStatus;\nexports.startInactiveSpan = startInactiveSpan;\nexports.startSpan = startSpan;\nexports.startSpanManual = startSpanManual;\nexports.suppressTracing = suppressTracing;\nexports.withActiveSpan = withActiveSpan;\nexports.wrapClientClass = wrapClientClass;\nexports.wrapContextManagerClass = wrapContextManagerClass;\nexports.wrapSamplingDecision = wrapSamplingDecision;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzZW50cnkrb3BlbnRlbGVtZXRyeUAxMC4xNy4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMF9Ab3BlbnRlbGVtZXRyeStjb250ZXh0LWFzeW5jLWhvb2tzQDIuMV9sbmFuanRiZWFvcmc3Y3B5ZDZkNWFqN2xqaS9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L2J1aWxkL2Nqcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSw0QkFBNEIsbUJBQU8sQ0FBQywwTEFBcUM7QUFDekUsYUFBYSxtQkFBTyxDQUFDLHNIQUFjO0FBQ25DLFlBQVksbUJBQU8sQ0FBQyxzSUFBb0I7QUFDeEMsZUFBZSxtQkFBTyxDQUFDLGtLQUFxQjtBQUM1QyxxQkFBcUIsbUJBQU8sQ0FBQyxnTUFBK0I7O0FBRTVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGFBQWE7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7O0FBRW5DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxrQ0FBa0M7QUFDeEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsNEJBQTRCO0FBQ2hFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtDQUFrQyxrQkFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsSUFBSSx3QkFBd0I7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSwwQ0FBMEM7O0FBRXBEO0FBQ0EsYUFBYTtBQUNiOztBQUVBOztBQUVBO0FBQ0EsNkJBQTZCLFlBQVksRUFBRSxRQUFROztBQUVuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlCQUFpQixHQUFHLGtFQUFrRTtBQUMvRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTzs7QUFFbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsVUFBVSxzQkFBc0I7QUFDaEMsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxnQkFBZ0IsOEJBQThCLEtBQUssa0JBQWtCO0FBQ3JFO0FBQ0E7O0FBRUEsWUFBWSxLQUFLO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUEsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVksY0FBYyw2REFBNkQ7QUFDdkY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUZBQXlGOztBQUV6RixZQUFZLG1EQUFtRDs7QUFFL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLCtCQUErQixFQUFFLE9BQU8sS0FBSyxpQkFBaUI7QUFDN0Y7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyRUFBMkUsc0JBQXNCO0FBQ2pHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxzQkFBc0I7QUFDMUI7QUFDQTs7QUFFQSxVQUFVLHNDQUFzQzs7QUFFaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHdCQUF3QjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxxQ0FBcUM7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdDQUFnQztBQUM3RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxxQ0FBcUM7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdDQUFnQztBQUM3RDtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsZ0JBQWdCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLHFDQUFxQzs7QUFFL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUseUNBQXlDOztBQUVuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGtCQUFrQjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBOztBQUVBLFVBQVUsbURBQW1ELDBCQUEwQixlQUFlOztBQUV0RztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0NBQWtDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0Msd0JBQXdCO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG9DQUFvQztBQUNqRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxrQkFBa0I7QUFDekQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLFFBQVE7QUFDUixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsSUFBSTtBQUNKLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLGNBQWM7QUFDbkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0IsZ0RBQWdELDhCQUE4QjtBQUNwSTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGVBQWUsU0FBUyx3QkFBd0I7QUFDakY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLFVBQVUsbURBQW1EO0FBQzdEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxRQUFRO0FBQ2xCLFVBQVUscUNBQXFDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2REFBNkQsWUFBWSw0QkFBNEI7O0FBRXJHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFVBQVUsd0NBQXdDOztBQUVsRCxVQUFVLDJDQUEyQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQSxVQUFVLCtDQUErQztBQUN6RCxVQUFVLDBFQUEwRTs7QUFFcEY7QUFDQTs7QUFFQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLDhDQUE4QztBQUNsRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDhDQUE4QztBQUNsRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDhDQUE4QztBQUNsRjs7QUFFQSxZQUFZLGlCQUFpQjs7QUFFN0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBLDJGQUEyRixPQUFPLFFBQVEsU0FBUzs7QUFFbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixTQUFTLElBQUksY0FBYztBQUMvRztBQUNBOztBQUVBO0FBQ0Esd0ZBQXdGLFNBQVMsSUFBSSxjQUFjO0FBQ25IO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLDBCQUEwQjtBQUM3Rjs7QUFFQTtBQUNBLG1FQUFtRSxXQUFXO0FBQzlFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakIseUNBQXlDO0FBQ3pDLG1EQUFtRDtBQUNuRCx3QkFBd0I7QUFDeEIscUJBQXFCO0FBQ3JCLDJCQUEyQjtBQUMzQixxQkFBcUI7QUFDckIsK0NBQStDO0FBQy9DLHFCQUFxQjtBQUNyQiwwQkFBMEI7QUFDMUIsNEJBQTRCO0FBQzVCLG1CQUFtQjtBQUNuQiwrQkFBK0I7QUFDL0IsMkJBQTJCO0FBQzNCLCtCQUErQjtBQUMvQixtREFBbUQ7QUFDbkQsOEJBQThCO0FBQzlCLGtDQUFrQztBQUNsQyx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQix5QkFBeUI7QUFDekIsaUJBQWlCO0FBQ2pCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2QiwrQkFBK0I7QUFDL0IsNEJBQTRCO0FBQzVCIiwic291cmNlcyI6WyIvVXNlcnMvY29keWRlYXJrbGFuZC9zZW50cnl2aWJlL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5K29wZW50ZWxlbWV0cnlAMTAuMTcuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjBfQG9wZW50ZWxlbWV0cnkrY29udGV4dC1hc3luYy1ob29rc0AyLjFfbG5hbmp0YmVhb3JnN2NweWQ2ZDVhajdsamkvbm9kZV9tb2R1bGVzL0BzZW50cnkvb3BlbnRlbGVtZXRyeS9idWlsZC9janMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IHNlbWFudGljQ29udmVudGlvbnMgPSByZXF1aXJlKCdAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9ucycpO1xuY29uc3QgY29yZSA9IHJlcXVpcmUoJ0BzZW50cnkvY29yZScpO1xuY29uc3QgYXBpID0gcmVxdWlyZSgnQG9wZW50ZWxlbWV0cnkvYXBpJyk7XG5jb25zdCBjb3JlJDEgPSByZXF1aXJlKCdAb3BlbnRlbGVtZXRyeS9jb3JlJyk7XG5jb25zdCBzZGtUcmFjZUJhc2UgPSByZXF1aXJlKCdAb3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZScpO1xuXG4vKiogSWYgdGhpcyBhdHRyaWJ1dGUgaXMgdHJ1ZSwgaXQgbWVhbnMgdGhhdCB0aGUgcGFyZW50IGlzIGEgcmVtb3RlIHNwYW4uICovXG5jb25zdCBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1BBUkVOVF9JU19SRU1PVEUgPSAnc2VudHJ5LnBhcmVudElzUmVtb3RlJztcblxuLy8gVGhlc2UgYXJlIG5vdCBzdGFuZGFyZGl6ZWQgeWV0LCBidXQgdXNlZCBieSB0aGUgZ3JhcGhxbCBpbnN0cnVtZW50YXRpb25cbmNvbnN0IFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfR1JBUEhRTF9PUEVSQVRJT04gPSAnc2VudHJ5LmdyYXBocWwub3BlcmF0aW9uJztcblxuLyoqXG4gKiBHZXQgdGhlIHBhcmVudCBzcGFuIGlkIGZyb20gYSBzcGFuLlxuICogSW4gT1RlbCB2MSwgdGhlIHBhcmVudCBzcGFuIGlkIGlzIGFjY2Vzc2VkIGFzIGBwYXJlbnRTcGFuSWRgXG4gKiBJbiBPVGVsIHYyLCB0aGUgcGFyZW50IHNwYW4gaWQgaXMgYWNjZXNzZWQgYXMgYHNwYW5JZGAgb24gdGhlIGBwYXJlbnRTcGFuQ29udGV4dGBcbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50U3BhbklkKHNwYW4pIHtcbiAgaWYgKCdwYXJlbnRTcGFuSWQnIGluIHNwYW4pIHtcbiAgICByZXR1cm4gc3Bhbi5wYXJlbnRTcGFuSWQgO1xuICB9IGVsc2UgaWYgKCdwYXJlbnRTcGFuQ29udGV4dCcgaW4gc3Bhbikge1xuICAgIHJldHVybiAoc3Bhbi5wYXJlbnRTcGFuQ29udGV4dCApPy5zcGFuSWQ7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgZ2l2ZW4gc3BhbiBoYXMgYXR0cmlidXRlcy5cbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdGhlIGJhc2UgYFNwYW5gIHR5cGUgZG9lcyBub3QgaGF2ZSBhdHRyaWJ1dGVzLFxuICogc28gaW4gcGxhY2VzIHdoZXJlIHdlIGFyZSBwYXNzZWQgYSBnZW5lcmljIHNwYW4sIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2Ugd2FudCB0byBhY2Nlc3MgdGhlbS5cbiAqL1xuZnVuY3Rpb24gc3Bhbkhhc0F0dHJpYnV0ZXMoXG4gIHNwYW4sXG4pIHtcbiAgY29uc3QgY2FzdFNwYW4gPSBzcGFuIDtcbiAgcmV0dXJuICEhY2FzdFNwYW4uYXR0cmlidXRlcyAmJiB0eXBlb2YgY2FzdFNwYW4uYXR0cmlidXRlcyA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBnaXZlbiBzcGFuIGhhcyBhIGtpbmQuXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBiYXNlIGBTcGFuYCB0eXBlIGRvZXMgbm90IGhhdmUgYSBraW5kLFxuICogc28gaW4gcGxhY2VzIHdoZXJlIHdlIGFyZSBwYXNzZWQgYSBnZW5lcmljIHNwYW4sIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2Ugd2FudCB0byBhY2Nlc3MgaXQuXG4gKi9cbmZ1bmN0aW9uIHNwYW5IYXNLaW5kKHNwYW4pIHtcbiAgY29uc3QgY2FzdFNwYW4gPSBzcGFuIDtcbiAgcmV0dXJuIHR5cGVvZiBjYXN0U3Bhbi5raW5kID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGdpdmVuIHNwYW4gaGFzIGEgc3RhdHVzLlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB0aGUgYmFzZSBgU3BhbmAgdHlwZSBkb2VzIG5vdCBoYXZlIGEgc3RhdHVzLFxuICogc28gaW4gcGxhY2VzIHdoZXJlIHdlIGFyZSBwYXNzZWQgYSBnZW5lcmljIHNwYW4sIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2Ugd2FudCB0byBhY2Nlc3MgaXQuXG4gKi9cbmZ1bmN0aW9uIHNwYW5IYXNTdGF0dXMoXG4gIHNwYW4sXG4pIHtcbiAgY29uc3QgY2FzdFNwYW4gPSBzcGFuIDtcbiAgcmV0dXJuICEhY2FzdFNwYW4uc3RhdHVzO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgZ2l2ZW4gc3BhbiBoYXMgYSBuYW1lLlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB0aGUgYmFzZSBgU3BhbmAgdHlwZSBkb2VzIG5vdCBoYXZlIGEgbmFtZSxcbiAqIHNvIGluIHBsYWNlcyB3aGVyZSB3ZSBhcmUgcGFzc2VkIGEgZ2VuZXJpYyBzcGFuLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIHdhbnQgdG8gYWNjZXNzIGl0LlxuICovXG5mdW5jdGlvbiBzcGFuSGFzTmFtZShzcGFuKSB7XG4gIGNvbnN0IGNhc3RTcGFuID0gc3BhbiA7XG4gIHJldHVybiAhIWNhc3RTcGFuLm5hbWU7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBnaXZlbiBzcGFuIGhhcyBhIGtpbmQuXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBiYXNlIGBTcGFuYCB0eXBlIGRvZXMgbm90IGhhdmUgYSBraW5kLFxuICogc28gaW4gcGxhY2VzIHdoZXJlIHdlIGFyZSBwYXNzZWQgYSBnZW5lcmljIHNwYW4sIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2Ugd2FudCB0byBhY2Nlc3MgaXQuXG4gKi9cbmZ1bmN0aW9uIHNwYW5IYXNQYXJlbnRJZChcbiAgc3Bhbixcbikge1xuICBjb25zdCBjYXN0U3BhbiA9IHNwYW4gO1xuICByZXR1cm4gISFnZXRQYXJlbnRTcGFuSWQoY2FzdFNwYW4pO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgZ2l2ZW4gc3BhbiBoYXMgZXZlbnRzLlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB0aGUgYmFzZSBgU3BhbmAgdHlwZSBkb2VzIG5vdCBoYXZlIGV2ZW50cyxcbiAqIHNvIGluIHBsYWNlcyB3aGVyZSB3ZSBhcmUgcGFzc2VkIGEgZ2VuZXJpYyBzcGFuLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIHdhbnQgdG8gYWNjZXNzIGl0LlxuICovXG5mdW5jdGlvbiBzcGFuSGFzRXZlbnRzKFxuICBzcGFuLFxuKSB7XG4gIGNvbnN0IGNhc3RTcGFuID0gc3BhbiA7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGNhc3RTcGFuLmV2ZW50cyk7XG59XG5cbi8qKlxuICogR2V0IHNhbml0aXppZWQgcmVxdWVzdCBkYXRhIGZyb20gYW4gT1RFTCBzcGFuLlxuICovXG5mdW5jdGlvbiBnZXRSZXF1ZXN0U3BhbkRhdGEoc3Bhbikge1xuICAvLyBUaGUgYmFzZSBgU3BhbmAgdHlwZSBoYXMgbm8gYGF0dHJpYnV0ZXNgLCBzbyB3ZSBuZWVkIHRvIGd1YXJkIGhlcmUgYWdhaW5zdCB0aGF0XG4gIGlmICghc3Bhbkhhc0F0dHJpYnV0ZXMoc3BhbikpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgY29uc3QgbWF5YmVVcmxBdHRyaWJ1dGUgPSAoc3Bhbi5hdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuQVRUUl9VUkxfRlVMTF0gfHwgc3Bhbi5hdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9VUkxdKVxuXG47XG5cbiAgY29uc3QgZGF0YSA9IHtcbiAgICB1cmw6IG1heWJlVXJsQXR0cmlidXRlLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgICdodHRwLm1ldGhvZCc6IChzcGFuLmF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5BVFRSX0hUVFBfUkVRVUVTVF9NRVRIT0RdIHx8IHNwYW4uYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfTUVUSE9EXSlcblxuLFxuICB9O1xuXG4gIC8vIERlZmF1bHQgdG8gR0VUIGlmIFVSTCBpcyBzZXQgYnV0IG1ldGhvZCBpcyBub3RcbiAgaWYgKCFkYXRhWydodHRwLm1ldGhvZCddICYmIGRhdGEudXJsKSB7XG4gICAgZGF0YVsnaHR0cC5tZXRob2QnXSA9ICdHRVQnO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIG1heWJlVXJsQXR0cmlidXRlID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgdXJsID0gY29yZS5wYXJzZVVybChtYXliZVVybEF0dHJpYnV0ZSk7XG5cbiAgICAgIGRhdGEudXJsID0gY29yZS5nZXRTYW5pdGl6ZWRVcmxTdHJpbmcodXJsKTtcblxuICAgICAgaWYgKHVybC5zZWFyY2gpIHtcbiAgICAgICAgZGF0YVsnaHR0cC5xdWVyeSddID0gdXJsLnNlYXJjaDtcbiAgICAgIH1cbiAgICAgIGlmICh1cmwuaGFzaCkge1xuICAgICAgICBkYXRhWydodHRwLmZyYWdtZW50J10gPSB1cmwuaGFzaDtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2gge1xuICAgIC8vIGlnbm9yZVxuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8vIFR5cGVzY3JpcHQgY29tcGxhaW5zIGlmIHdlIGRvIG5vdCB1c2UgYC4uLmFyZ3M6IGFueVtdYCBmb3IgdGhlIG1peGluLCB3aXRoOlxuLy8gQSBtaXhpbiBjbGFzcyBtdXN0IGhhdmUgYSBjb25zdHJ1Y3RvciB3aXRoIGEgc2luZ2xlIHJlc3QgcGFyYW1ldGVyIG9mIHR5cGUgJ2FueVtdJy50cygyNTQ1KVxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuXG4vKipcbiAqIFdyYXAgYW4gQ2xpZW50IGNsYXNzIHdpdGggdGhpbmdzIHdlIG5lZWQgZm9yIE9wZW5UZWxlbWV0cnkgc3VwcG9ydC5cbiAqIE1ha2Ugc3VyZSB0aGF0IHRoZSBDbGllbnQgY2xhc3MgcGFzc2VkIGluIGlzIG5vbi1hYnN0cmFjdCFcbiAqXG4gKiBVc2FnZTpcbiAqIGNvbnN0IE9wZW5UZWxlbWV0cnlDbGllbnQgPSBnZXRXcmFwcGVkQ2xpZW50Q2xhc3MoTm9kZUNsaWVudCk7XG4gKiBjb25zdCBjbGllbnQgPSBuZXcgT3BlblRlbGVtZXRyeUNsaWVudChvcHRpb25zKTtcbiAqL1xuZnVuY3Rpb24gd3JhcENsaWVudENsYXNzXG5cbihDbGllbnRDbGFzcykge1xuICAvLyBAdHMtZXhwZWN0LWVycm9yIFdlIGp1c3QgYXNzdW1lIHRoYXQgdGhpcyBpcyBub24tYWJzdHJhY3QsIGlmIHlvdSBwYXNzIGluIGFuIGFic3RyYWN0IGNsYXNzIHRoaXMgd291bGQgbWFrZSBpdCBub24tYWJzdHJhY3RcbiAgY2xhc3MgT3BlblRlbGVtZXRyeUNsaWVudCBleHRlbmRzIENsaWVudENsYXNzICB7XG5cbiAgICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgfVxuXG4gICAgLyoqIEdldCB0aGUgT1RFTCB0cmFjZXIuICovXG4gICAgIGdldCB0cmFjZXIoKSB7XG4gICAgICBpZiAodGhpcy5fdHJhY2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFjZXI7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5hbWUgPSAnQHNlbnRyeS9vcGVudGVsZW1ldHJ5JztcbiAgICAgIGNvbnN0IHZlcnNpb24gPSBjb3JlLlNES19WRVJTSU9OO1xuICAgICAgY29uc3QgdHJhY2VyID0gYXBpLnRyYWNlLmdldFRyYWNlcihuYW1lLCB2ZXJzaW9uKTtcbiAgICAgIHRoaXMuX3RyYWNlciA9IHRyYWNlcjtcblxuICAgICAgcmV0dXJuIHRyYWNlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgICBhc3luYyBmbHVzaCh0aW1lb3V0KSB7XG4gICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMudHJhY2VQcm92aWRlcjtcbiAgICAgIGF3YWl0IHByb3ZpZGVyPy5mb3JjZUZsdXNoKCk7XG4gICAgICByZXR1cm4gc3VwZXIuZmx1c2godGltZW91dCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIE9wZW5UZWxlbWV0cnlDbGllbnQgO1xufVxuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5cbi8qKlxuICogR2V0IHRoZSBzcGFuIGtpbmQgZnJvbSBhIHNwYW4uXG4gKiBGb3Igd2hhdGV2ZXIgcmVhc29uLCB0aGlzIGlzIG5vdCBwdWJsaWMgQVBJIG9uIHRoZSBnZW5lcmljIFwiU3BhblwiIHR5cGUsXG4gKiBzbyB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGFjdHVhbGx5IGhhdmUgYSBgU0RLVHJhY2VCYXNlU3BhbmAgd2hlcmUgd2UgY2FuIGZldGNoIHRoaXMgZnJvbS5cbiAqIE90aGVyd2lzZSwgd2UgZmFsbCBiYWNrIHRvIGBTcGFuS2luZC5JTlRFUk5BTGAuXG4gKi9cbmZ1bmN0aW9uIGdldFNwYW5LaW5kKHNwYW4pIHtcbiAgaWYgKHNwYW5IYXNLaW5kKHNwYW4pKSB7XG4gICAgcmV0dXJuIHNwYW4ua2luZDtcbiAgfVxuXG4gIHJldHVybiBhcGkuU3BhbktpbmQuSU5URVJOQUw7XG59XG5cbmNvbnN0IFNFTlRSWV9UUkFDRV9IRUFERVIgPSAnc2VudHJ5LXRyYWNlJztcbmNvbnN0IFNFTlRSWV9CQUdHQUdFX0hFQURFUiA9ICdiYWdnYWdlJztcblxuY29uc3QgU0VOVFJZX1RSQUNFX1NUQVRFX0RTQyA9ICdzZW50cnkuZHNjJztcbmNvbnN0IFNFTlRSWV9UUkFDRV9TVEFURV9TQU1QTEVEX05PVF9SRUNPUkRJTkcgPSAnc2VudHJ5LnNhbXBsZWRfbm90X3JlY29yZGluZyc7XG5jb25zdCBTRU5UUllfVFJBQ0VfU1RBVEVfVVJMID0gJ3NlbnRyeS51cmwnO1xuY29uc3QgU0VOVFJZX1RSQUNFX1NUQVRFX1NBTVBMRV9SQU5EID0gJ3NlbnRyeS5zYW1wbGVfcmFuZCc7XG5jb25zdCBTRU5UUllfVFJBQ0VfU1RBVEVfU0FNUExFX1JBVEUgPSAnc2VudHJ5LnNhbXBsZV9yYXRlJztcblxuY29uc3QgU0VOVFJZX1NDT1BFU19DT05URVhUX0tFWSA9IGFwaS5jcmVhdGVDb250ZXh0S2V5KCdzZW50cnlfc2NvcGVzJyk7XG5cbmNvbnN0IFNFTlRSWV9GT1JLX0lTT0xBVElPTl9TQ09QRV9DT05URVhUX0tFWSA9IGFwaS5jcmVhdGVDb250ZXh0S2V5KCdzZW50cnlfZm9ya19pc29sYXRpb25fc2NvcGUnKTtcblxuY29uc3QgU0VOVFJZX0ZPUktfU0VUX1NDT1BFX0NPTlRFWFRfS0VZID0gYXBpLmNyZWF0ZUNvbnRleHRLZXkoJ3NlbnRyeV9mb3JrX3NldF9zY29wZScpO1xuXG5jb25zdCBTRU5UUllfRk9SS19TRVRfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZID0gYXBpLmNyZWF0ZUNvbnRleHRLZXkoJ3NlbnRyeV9mb3JrX3NldF9pc29sYXRpb25fc2NvcGUnKTtcblxuY29uc3QgU0NPUEVfQ09OVEVYVF9GSUVMRCA9ICdfc2NvcGVDb250ZXh0JztcblxuLyoqXG4gKiBUcnkgdG8gZ2V0IHRoZSBjdXJyZW50IHNjb3BlcyBmcm9tIHRoZSBnaXZlbiBPVEVMIGNvbnRleHQuXG4gKiBUaGlzIHJlcXVpcmVzIGEgQ29udGV4dCBNYW5hZ2VyIHRoYXQgd2FzIHdyYXBwZWQgd2l0aCBnZXRXcmFwcGVkQ29udGV4dE1hbmFnZXIuXG4gKi9cbmZ1bmN0aW9uIGdldFNjb3Blc0Zyb21Db250ZXh0KGNvbnRleHQpIHtcbiAgcmV0dXJuIGNvbnRleHQuZ2V0VmFsdWUoU0VOVFJZX1NDT1BFU19DT05URVhUX0tFWSkgO1xufVxuXG4vKipcbiAqIFNldCB0aGUgY3VycmVudCBzY29wZXMgb24gYW4gT1RFTCBjb250ZXh0LlxuICogVGhpcyB3aWxsIHJldHVybiBhIGZvcmtlZCBjb250ZXh0IHdpdGggdGhlIFByb3BhZ2F0aW9uIENvbnRleHQgc2V0LlxuICovXG5mdW5jdGlvbiBzZXRTY29wZXNPbkNvbnRleHQoY29udGV4dCwgc2NvcGVzKSB7XG4gIHJldHVybiBjb250ZXh0LnNldFZhbHVlKFNFTlRSWV9TQ09QRVNfQ09OVEVYVF9LRVksIHNjb3Blcyk7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjb250ZXh0IG9uIHRoZSBzY29wZSBzbyB3ZSBjYW4gbGF0ZXIgbG9vayBpdCB1cC5cbiAqIFdlIG5lZWQgdGhpcyB0byBnZXQgdGhlIGNvbnRleHQgZnJvbSB0aGUgc2NvcGUgaW4gdGhlIGB0cmFjZWAgZnVuY3Rpb25zLlxuICovXG5mdW5jdGlvbiBzZXRDb250ZXh0T25TY29wZShzY29wZSwgY29udGV4dCkge1xuICBjb3JlLmFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eShzY29wZSwgU0NPUEVfQ09OVEVYVF9GSUVMRCwgY29udGV4dCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjb250ZXh0IHJlbGF0ZWQgdG8gYSBzY29wZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Q29udGV4dEZyb21TY29wZShzY29wZSkge1xuICByZXR1cm4gKHNjb3BlIClbU0NPUEVfQ09OVEVYVF9GSUVMRF07XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBvdGVsU3BhbiBDaGVja3Mgd2hldGhlciBhIGdpdmVuIE9URUwgU3BhbiBpcyBhbiBodHRwIHJlcXVlc3QgdG8gc2VudHJ5LlxuICogQHJldHVybnMgYm9vbGVhblxuICovXG5mdW5jdGlvbiBpc1NlbnRyeVJlcXVlc3RTcGFuKHNwYW4pIHtcbiAgaWYgKCFzcGFuSGFzQXR0cmlidXRlcyhzcGFuKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHsgYXR0cmlidXRlcyB9ID0gc3BhbjtcblxuICAvLyBgQVRUUl9VUkxfRlVMTGAgaXMgdGhlIG5ldyBhdHRyaWJ1dGUsIGJ1dCB3ZSBzdGlsbCBzdXBwb3J0IHRoZSBvbGQgb25lLCBgQVRUUl9IVFRQX1VSTGAsIGZvciBub3cuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBjb25zdCBodHRwVXJsID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfVVJMXSB8fCBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuQVRUUl9VUkxfRlVMTF07XG5cbiAgaWYgKCFodHRwVXJsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGNvcmUuaXNTZW50cnlSZXF1ZXN0VXJsKGh0dHBVcmwudG9TdHJpbmcoKSwgY29yZS5nZXRDbGllbnQoKSk7XG59XG5cbi8qKlxuICogT3BlblRlbGVtZXRyeSBvbmx5IGtub3dzIGFib3V0IFNBTVBMRUQgb3IgTk9ORSBkZWNpc2lvbixcbiAqIGJ1dCBmb3IgdXMgaXQgaXMgaW1wb3J0YW50IHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiB1bnNldCBhbmQgdW5zYW1wbGVkLlxuICpcbiAqIEJvdGggb2YgdGhlc2UgYXJlIGlkZW50aWZpZWQgYXMgYHRyYWNlRmxhZ3MgPT09IFRyYWNlZ0ZsYWdzLk5PTkVgLFxuICogYnV0IHdlIGFkZGl0aW9uYWxseSBsb29rIGF0IGEgc3BlY2lhbCB0cmFjZSBzdGF0ZSB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gdGhlbS5cbiAqL1xuZnVuY3Rpb24gZ2V0U2FtcGxpbmdEZWNpc2lvbihzcGFuQ29udGV4dCkge1xuICBjb25zdCB7IHRyYWNlRmxhZ3MsIHRyYWNlU3RhdGUgfSA9IHNwYW5Db250ZXh0O1xuXG4gIGNvbnN0IHNhbXBsZWROb3RSZWNvcmRpbmcgPSB0cmFjZVN0YXRlID8gdHJhY2VTdGF0ZS5nZXQoU0VOVFJZX1RSQUNFX1NUQVRFX1NBTVBMRURfTk9UX1JFQ09SRElORykgPT09ICcxJyA6IGZhbHNlO1xuXG4gIC8vIElmIHRyYWNlIGZsYWcgaXMgYFNBTVBMRURgLCB3ZSBpbnRlcnByZXQgdGhpcyBhcyBzYW1wbGVkXG4gIC8vIElmIGl0IGlzIGBOT05FYCwgaXQgY291bGQgbWVhbiBlaXRoZXIgaXQgd2FzIHNhbXBsZWQgdG8gYmUgbm90IHJlY29yZGVyLCBvciB0aGF0IGl0IHdhcyBub3Qgc2FtcGxlZCBhdCBhbGxcbiAgLy8gRm9yIHVzIHRoaXMgaXMgYW4gaW1wb3J0YW50IGRpZmZlcmVuY2UsIHNvdyBlIGxvb2sgYXQgdGhlIFNFTlRSWV9UUkFDRV9TVEFURV9TQU1QTEVEX05PVF9SRUNPUkRJTkdcbiAgLy8gdG8gaWRlbnRpZnkgd2hpY2ggaXQgaXNcbiAgaWYgKHRyYWNlRmxhZ3MgPT09IGFwaS5UcmFjZUZsYWdzLlNBTVBMRUQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChzYW1wbGVkTm90UmVjb3JkaW5nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRmFsbCBiYWNrIHRvIERTQyBhcyBhIGxhc3QgcmVzb3J0LCB0aGF0IG1heSBhbHNvIGNvbnRhaW4gYHNhbXBsZWRgLi4uXG4gIGNvbnN0IGRzY1N0cmluZyA9IHRyYWNlU3RhdGUgPyB0cmFjZVN0YXRlLmdldChTRU5UUllfVFJBQ0VfU1RBVEVfRFNDKSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgZHNjID0gZHNjU3RyaW5nID8gY29yZS5iYWdnYWdlSGVhZGVyVG9EeW5hbWljU2FtcGxpbmdDb250ZXh0KGRzY1N0cmluZykgOiB1bmRlZmluZWQ7XG5cbiAgaWYgKGRzYz8uc2FtcGxlZCA9PT0gJ3RydWUnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGRzYz8uc2FtcGxlZCA9PT0gJ2ZhbHNlJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogSW5mZXIgdGhlIG9wICYgZGVzY3JpcHRpb24gZm9yIGEgc2V0IG9mIG5hbWUsIGF0dHJpYnV0ZXMgYW5kIGtpbmQgb2YgYSBzcGFuLlxuICovXG5mdW5jdGlvbiBpbmZlclNwYW5EYXRhKHNwYW5OYW1lLCBhdHRyaWJ1dGVzLCBraW5kKSB7XG4gIC8vIGlmIGh0dHAubWV0aG9kIGV4aXN0cywgdGhpcyBpcyBhbiBodHRwIHJlcXVlc3Qgc3BhblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgY29uc3QgaHR0cE1ldGhvZCA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5BVFRSX0hUVFBfUkVRVUVTVF9NRVRIT0RdIHx8IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19IVFRQX01FVEhPRF07XG4gIGlmIChodHRwTWV0aG9kKSB7XG4gICAgcmV0dXJuIGRlc2NyaXB0aW9uRm9ySHR0cE1ldGhvZCh7IGF0dHJpYnV0ZXMsIG5hbWU6IHNwYW5OYW1lLCBraW5kIH0sIGh0dHBNZXRob2QpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIGNvbnN0IGRiU3lzdGVtID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0RCX1NZU1RFTV07XG4gIGNvbnN0IG9wSXNDYWNoZSA9XG4gICAgdHlwZW9mIGF0dHJpYnV0ZXNbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09QXSA9PT0gJ3N0cmluZycgJiZcbiAgICBhdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUF0uc3RhcnRzV2l0aCgnY2FjaGUuJyk7XG5cbiAgLy8gSWYgZGIudHlwZSBleGlzdHMgdGhlbiB0aGlzIGlzIGEgZGF0YWJhc2UgY2FsbCBzcGFuXG4gIC8vIElmIHRoZSBSZWRpcyBEQiBpcyB1c2VkIGFzIGEgY2FjaGUsIHRoZSBzcGFuIGRlc2NyaXB0aW9uIHNob3VsZCBub3QgYmUgY2hhbmdlZFxuICBpZiAoZGJTeXN0ZW0gJiYgIW9wSXNDYWNoZSkge1xuICAgIHJldHVybiBkZXNjcmlwdGlvbkZvckRiU3lzdGVtKHsgYXR0cmlidXRlcywgbmFtZTogc3Bhbk5hbWUgfSk7XG4gIH1cblxuICBjb25zdCBjdXN0b21Tb3VyY2VPclJvdXRlID0gYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFXSA9PT0gJ2N1c3RvbScgPyAnY3VzdG9tJyA6ICdyb3V0ZSc7XG5cbiAgLy8gSWYgcnBjLnNlcnZpY2UgZXhpc3RzIHRoZW4gdGhpcyBpcyBhIHJwYyBjYWxsIHNwYW4uXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBjb25zdCBycGNTZXJ2aWNlID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX1JQQ19TRVJWSUNFXTtcbiAgaWYgKHJwY1NlcnZpY2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZ2V0VXNlclVwZGF0ZWROYW1lQW5kU291cmNlKHNwYW5OYW1lLCBhdHRyaWJ1dGVzLCAncm91dGUnKSxcbiAgICAgIG9wOiAncnBjJyxcbiAgICB9O1xuICB9XG5cbiAgLy8gSWYgbWVzc2FnaW5nLnN5c3RlbSBleGlzdHMgdGhlbiB0aGlzIGlzIGEgbWVzc2FnaW5nIHN5c3RlbSBzcGFuLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgY29uc3QgbWVzc2FnaW5nU3lzdGVtID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX01FU1NBR0lOR19TWVNURU1dO1xuICBpZiAobWVzc2FnaW5nU3lzdGVtKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmdldFVzZXJVcGRhdGVkTmFtZUFuZFNvdXJjZShzcGFuTmFtZSwgYXR0cmlidXRlcywgY3VzdG9tU291cmNlT3JSb3V0ZSksXG4gICAgICBvcDogJ21lc3NhZ2UnLFxuICAgIH07XG4gIH1cblxuICAvLyBJZiBmYWFzLnRyaWdnZXIgZXhpc3RzIHRoZW4gdGhpcyBpcyBhIGZ1bmN0aW9uIGFzIGEgc2VydmljZSBzcGFuLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgY29uc3QgZmFhc1RyaWdnZXIgPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfRkFBU19UUklHR0VSXTtcbiAgaWYgKGZhYXNUcmlnZ2VyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmdldFVzZXJVcGRhdGVkTmFtZUFuZFNvdXJjZShzcGFuTmFtZSwgYXR0cmlidXRlcywgY3VzdG9tU291cmNlT3JSb3V0ZSksXG4gICAgICBvcDogZmFhc1RyaWdnZXIudG9TdHJpbmcoKSxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHsgb3A6IHVuZGVmaW5lZCwgZGVzY3JpcHRpb246IHNwYW5OYW1lLCBzb3VyY2U6ICdjdXN0b20nIH07XG59XG5cbi8qKlxuICogRXh0cmFjdCBiZXR0ZXIgb3AvZGVzY3JpcHRpb24gZnJvbSBhbiBvdGVsIHNwYW4uXG4gKlxuICogRG9lcyBub3Qgb3ZlcndyaXRlIHRoZSBzcGFuIG5hbWUgaWYgdGhlIHNvdXJjZSBpcyBhbHJlYWR5IHNldCB0byBjdXN0b20gdG8gZW5zdXJlXG4gKiB0aGF0IHVzZXItdXBkYXRlZCBzcGFuIG5hbWVzIGFyZSBwcmVzZXJ2ZWQuIEluIHRoaXMgY2FzZSwgd2Ugb25seSBhZGp1c3QgdGhlIG9wIGJ1dFxuICogbGVhdmUgc3BhbiBkZXNjcmlwdGlvbiBhbmQgc291cmNlIHVuY2hhbmdlZC5cbiAqXG4gKiBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vb3Blbi10ZWxlbWV0cnkvb3BlbnRlbGVtZXRyeS1jb2xsZWN0b3ItY29udHJpYi9ibG9iLzc0MjJjZTJhMDYzMzdmNjhhNTliNTUyYjhjNWEyYWMxMjVkNmJhZTUvZXhwb3J0ZXIvc2VudHJ5ZXhwb3J0ZXIvc2VudHJ5X2V4cG9ydGVyLmdvI0wzMDZcbiAqL1xuZnVuY3Rpb24gcGFyc2VTcGFuRGVzY3JpcHRpb24oc3Bhbikge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gc3Bhbkhhc0F0dHJpYnV0ZXMoc3BhbikgPyBzcGFuLmF0dHJpYnV0ZXMgOiB7fTtcbiAgY29uc3QgbmFtZSA9IHNwYW5IYXNOYW1lKHNwYW4pID8gc3Bhbi5uYW1lIDogJzx1bmtub3duPic7XG4gIGNvbnN0IGtpbmQgPSBnZXRTcGFuS2luZChzcGFuKTtcblxuICByZXR1cm4gaW5mZXJTcGFuRGF0YShuYW1lLCBhdHRyaWJ1dGVzLCBraW5kKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpcHRpb25Gb3JEYlN5c3RlbSh7IGF0dHJpYnV0ZXMsIG5hbWUgfSkge1xuICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBjdXN0b20gbmFtZSwgd2UgZG9uJ3Qgb3ZlcndyaXRlIGl0IGJ1dCBvbmx5IHNldCB0aGUgb3BcbiAgY29uc3QgdXNlckRlZmluZWROYW1lID0gYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfQ1VTVE9NX1NQQU5fTkFNRV07XG4gIGlmICh0eXBlb2YgdXNlckRlZmluZWROYW1lID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB7XG4gICAgICBvcDogJ2RiJyxcbiAgICAgIGRlc2NyaXB0aW9uOiB1c2VyRGVmaW5lZE5hbWUsXG4gICAgICBzb3VyY2U6IChhdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0VdICkgfHwgJ2N1c3RvbScsXG4gICAgfTtcbiAgfVxuXG4gIC8vIGlmIHdlIGFscmVhZHkgaGF2ZSB0aGUgc291cmNlIHNldCB0byBjdXN0b20sIHdlIGRvbid0IG92ZXJ3cml0ZSB0aGUgc3BhbiBkZXNjcmlwdGlvbiBidXQgb25seSBzZXQgdGhlIG9wXG4gIGlmIChhdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0VdID09PSAnY3VzdG9tJykge1xuICAgIHJldHVybiB7IG9wOiAnZGInLCBkZXNjcmlwdGlvbjogbmFtZSwgc291cmNlOiAnY3VzdG9tJyB9O1xuICB9XG5cbiAgLy8gVXNlIERCIHN0YXRlbWVudCAoRXggXCJTRUxFQ1QgKiBGUk9NIHRhYmxlXCIpIGlmIHBvc3NpYmxlIGFzIGRlc2NyaXB0aW9uLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgY29uc3Qgc3RhdGVtZW50ID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0RCX1NUQVRFTUVOVF07XG5cbiAgY29uc3QgZGVzY3JpcHRpb24gPSBzdGF0ZW1lbnQgPyBzdGF0ZW1lbnQudG9TdHJpbmcoKSA6IG5hbWU7XG5cbiAgcmV0dXJuIHsgb3A6ICdkYicsIGRlc2NyaXB0aW9uLCBzb3VyY2U6ICd0YXNrJyB9O1xufVxuXG4vKiogT25seSBleHBvcnRlZCBmb3IgdGVzdHMuICovXG5mdW5jdGlvbiBkZXNjcmlwdGlvbkZvckh0dHBNZXRob2QoXG4gIHsgbmFtZSwga2luZCwgYXR0cmlidXRlcyB9LFxuICBodHRwTWV0aG9kLFxuKSB7XG4gIGNvbnN0IG9wUGFydHMgPSBbJ2h0dHAnXTtcblxuICBzd2l0Y2ggKGtpbmQpIHtcbiAgICBjYXNlIGFwaS5TcGFuS2luZC5DTElFTlQ6XG4gICAgICBvcFBhcnRzLnB1c2goJ2NsaWVudCcpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhcGkuU3BhbktpbmQuU0VSVkVSOlxuICAgICAgb3BQYXJ0cy5wdXNoKCdzZXJ2ZXInKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gU3BhbnMgZm9yIEhUVFAgcmVxdWVzdHMgd2UgaGF2ZSBkZXRlcm1pbmVkIHRvIGJlIHByZWZldGNoIHJlcXVlc3RzIHdpbGwgaGF2ZSBhIGAucHJlZmV0Y2hgIHBvc3RmaXggaW4gdGhlIG9wXG4gIGlmIChhdHRyaWJ1dGVzWydzZW50cnkuaHR0cC5wcmVmZXRjaCddKSB7XG4gICAgb3BQYXJ0cy5wdXNoKCdwcmVmZXRjaCcpO1xuICB9XG5cbiAgY29uc3QgeyB1cmxQYXRoLCB1cmwsIHF1ZXJ5LCBmcmFnbWVudCwgaGFzUm91dGUgfSA9IGdldFNhbml0aXplZFVybChhdHRyaWJ1dGVzLCBraW5kKTtcblxuICBpZiAoIXVybFBhdGgpIHtcbiAgICByZXR1cm4geyAuLi5nZXRVc2VyVXBkYXRlZE5hbWVBbmRTb3VyY2UobmFtZSwgYXR0cmlidXRlcyksIG9wOiBvcFBhcnRzLmpvaW4oJy4nKSB9O1xuICB9XG5cbiAgY29uc3QgZ3JhcGhxbE9wZXJhdGlvbnNBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW1NFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfR1JBUEhRTF9PUEVSQVRJT05dO1xuXG4gIC8vIEV4LiBHRVQgL2FwaS91c2Vyc1xuICBjb25zdCBiYXNlRGVzY3JpcHRpb24gPSBgJHtodHRwTWV0aG9kfSAke3VybFBhdGh9YDtcblxuICAvLyBXaGVuIHRoZSBodHRwIHNwYW4gaGFzIGEgZ3JhcGhxbCBvcGVyYXRpb24sIGFwcGVuZCBpdCB0byB0aGUgZGVzY3JpcHRpb25cbiAgLy8gV2UgYWRkIHRoZXNlIGluIHRoZSBncmFwaHFsSW50ZWdyYXRpb25cbiAgY29uc3QgaW5mZXJyZWREZXNjcmlwdGlvbiA9IGdyYXBocWxPcGVyYXRpb25zQXR0cmlidXRlXG4gICAgPyBgJHtiYXNlRGVzY3JpcHRpb259ICgke2dldEdyYXBocWxPcGVyYXRpb25OYW1lc0Zyb21BdHRyaWJ1dGUoZ3JhcGhxbE9wZXJhdGlvbnNBdHRyaWJ1dGUpfSlgXG4gICAgOiBiYXNlRGVzY3JpcHRpb247XG5cbiAgLy8gSWYgYGh0dHBQYXRoYCBpcyBhIHJvb3QgcGF0aCwgdGhlbiB3ZSBjYW4gY2F0ZWdvcml6ZSB0aGUgdHJhbnNhY3Rpb24gc291cmNlIGFzIHJvdXRlLlxuICBjb25zdCBpbmZlcnJlZFNvdXJjZSA9IGhhc1JvdXRlIHx8IHVybFBhdGggPT09ICcvJyA/ICdyb3V0ZScgOiAndXJsJztcblxuICBjb25zdCBkYXRhID0ge307XG5cbiAgaWYgKHVybCkge1xuICAgIGRhdGEudXJsID0gdXJsO1xuICB9XG4gIGlmIChxdWVyeSkge1xuICAgIGRhdGFbJ2h0dHAucXVlcnknXSA9IHF1ZXJ5O1xuICB9XG4gIGlmIChmcmFnbWVudCkge1xuICAgIGRhdGFbJ2h0dHAuZnJhZ21lbnQnXSA9IGZyYWdtZW50O1xuICB9XG5cbiAgLy8gSWYgdGhlIHNwYW4ga2luZCBpcyBuZWl0aGVyIGNsaWVudCBub3Igc2VydmVyLCB3ZSB1c2UgdGhlIG9yaWdpbmFsIG5hbWVcbiAgLy8gdGhpcyBpbmZlcnMgdGhhdCBzb21lYm9keSBtYW51YWxseSBzdGFydGVkIHRoaXMgc3BhbiwgaW4gd2hpY2ggY2FzZSB3ZSBkb24ndCB3YW50IHRvIG92ZXJ3cml0ZSB0aGUgbmFtZVxuICBjb25zdCBpc0NsaWVudE9yU2VydmVyS2luZCA9IGtpbmQgPT09IGFwaS5TcGFuS2luZC5DTElFTlQgfHwga2luZCA9PT0gYXBpLlNwYW5LaW5kLlNFUlZFUjtcblxuICAvLyBJZiB0aGUgc3BhbiBpcyBhbiBhdXRvLXNwYW4gKD1pdCBjb21lcyBmcm9tIG9uZSBvZiBvdXIgaW5zdHJ1bWVudGF0aW9ucyksXG4gIC8vIHdlIGFsd2F5cyB3YW50IHRvIGluZmVyIHRoZSBuYW1lXG4gIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc29tZSBvZiB0aGUgYXV0by1pbnN0cnVtZW50YXRpb24gd2UgdXNlIHVzZXMga2luZD1JTlRFUk5BTFxuICBjb25zdCBvcmlnaW4gPSBhdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU5dIHx8ICdtYW51YWwnO1xuICBjb25zdCBpc01hbnVhbFNwYW4gPSAhYCR7b3JpZ2lufWAuc3RhcnRzV2l0aCgnYXV0bycpO1xuXG4gIC8vIElmIHVzZXJzIChvciBpbiB2ZXJ5IHJhcmUgb2NjYXNpb25zIHdlKSBzZXQgdGhlIHNvdXJjZSB0byBjdXN0b20sIHdlIGRvbid0IG92ZXJ3cml0ZSB0aGUgbmFtZVxuICBjb25zdCBhbHJlYWR5SGFzQ3VzdG9tU291cmNlID0gYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFXSA9PT0gJ2N1c3RvbSc7XG4gIGNvbnN0IGN1c3RvbVNwYW5OYW1lID0gYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfQ1VTVE9NX1NQQU5fTkFNRV07XG5cbiAgY29uc3QgdXNlSW5mZXJyZWREZXNjcmlwdGlvbiA9XG4gICAgIWFscmVhZHlIYXNDdXN0b21Tb3VyY2UgJiYgY3VzdG9tU3Bhbk5hbWUgPT0gbnVsbCAmJiAoaXNDbGllbnRPclNlcnZlcktpbmQgfHwgIWlzTWFudWFsU3Bhbik7XG5cbiAgY29uc3QgeyBkZXNjcmlwdGlvbiwgc291cmNlIH0gPSB1c2VJbmZlcnJlZERlc2NyaXB0aW9uXG4gICAgPyB7IGRlc2NyaXB0aW9uOiBpbmZlcnJlZERlc2NyaXB0aW9uLCBzb3VyY2U6IGluZmVycmVkU291cmNlIH1cbiAgICA6IGdldFVzZXJVcGRhdGVkTmFtZUFuZFNvdXJjZShuYW1lLCBhdHRyaWJ1dGVzKTtcblxuICByZXR1cm4ge1xuICAgIG9wOiBvcFBhcnRzLmpvaW4oJy4nKSxcbiAgICBkZXNjcmlwdGlvbixcbiAgICBzb3VyY2UsXG4gICAgZGF0YSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0R3JhcGhxbE9wZXJhdGlvbk5hbWVzRnJvbUF0dHJpYnV0ZShhdHRyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGF0dHIpKSB7XG4gICAgY29uc3Qgc29ydGVkID0gYXR0ci5zbGljZSgpLnNvcnQoKTtcblxuICAgIC8vIFVwIHRvIDUgaXRlbXMsIHdlIGp1c3QgYWRkIGFsbCBvZiB0aGVtXG4gICAgaWYgKHNvcnRlZC5sZW5ndGggPD0gNSkge1xuICAgICAgcmV0dXJuIHNvcnRlZC5qb2luKCcsICcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFbHNlLCB3ZSBhZGQgdGhlIGZpcnN0IDUgYW5kIHRoZSBkaWZmIG9mIG90aGVyIG9wZXJhdGlvbnNcbiAgICAgIHJldHVybiBgJHtzb3J0ZWQuc2xpY2UoMCwgNSkuam9pbignLCAnKX0sICske3NvcnRlZC5sZW5ndGggLSA1fWA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGAke2F0dHJ9YDtcbn1cblxuLyoqIEV4cG9ydGVkIGZvciB0ZXN0cyBvbmx5ICovXG5mdW5jdGlvbiBnZXRTYW5pdGl6ZWRVcmwoXG4gIGF0dHJpYnV0ZXMsXG4gIGtpbmQsXG4pXG5cbiB7XG4gIC8vIFRoaXMgaXMgdGhlIHJlbGF0aXZlIHBhdGggb2YgdGhlIFVSTCwgZS5nLiAvc3ViXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBjb25zdCBodHRwVGFyZ2V0ID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfVEFSR0VUXTtcbiAgLy8gVGhpcyBpcyB0aGUgZnVsbCBVUkwsIGluY2x1ZGluZyBob3N0ICYgcXVlcnkgcGFyYW1zIGV0Yy4sIGUuZy4gaHR0cHM6Ly9leGFtcGxlLmNvbS9zdWI/Zm9vPWJhclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgY29uc3QgaHR0cFVybCA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19IVFRQX1VSTF0gfHwgYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLkFUVFJfVVJMX0ZVTExdO1xuICAvLyBUaGlzIGlzIHRoZSBub3JtYWxpemVkIHJvdXRlIG5hbWUgLSBtYXkgbm90IGFsd2F5cyBiZSBhdmFpbGFibGUhXG4gIGNvbnN0IGh0dHBSb3V0ZSA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5BVFRSX0hUVFBfUk9VVEVdO1xuXG4gIGNvbnN0IHBhcnNlZFVybCA9IHR5cGVvZiBodHRwVXJsID09PSAnc3RyaW5nJyA/IGNvcmUucGFyc2VVcmwoaHR0cFVybCkgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHVybCA9IHBhcnNlZFVybCA/IGNvcmUuZ2V0U2FuaXRpemVkVXJsU3RyaW5nKHBhcnNlZFVybCkgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHF1ZXJ5ID0gcGFyc2VkVXJsPy5zZWFyY2ggfHwgdW5kZWZpbmVkO1xuICBjb25zdCBmcmFnbWVudCA9IHBhcnNlZFVybD8uaGFzaCB8fCB1bmRlZmluZWQ7XG5cbiAgaWYgKHR5cGVvZiBodHRwUm91dGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHsgdXJsUGF0aDogaHR0cFJvdXRlLCB1cmwsIHF1ZXJ5LCBmcmFnbWVudCwgaGFzUm91dGU6IHRydWUgfTtcbiAgfVxuXG4gIGlmIChraW5kID09PSBhcGkuU3BhbktpbmQuU0VSVkVSICYmIHR5cGVvZiBodHRwVGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB7IHVybFBhdGg6IGNvcmUuc3RyaXBVcmxRdWVyeUFuZEZyYWdtZW50KGh0dHBUYXJnZXQpLCB1cmwsIHF1ZXJ5LCBmcmFnbWVudCwgaGFzUm91dGU6IGZhbHNlIH07XG4gIH1cblxuICBpZiAocGFyc2VkVXJsKSB7XG4gICAgcmV0dXJuIHsgdXJsUGF0aDogdXJsLCB1cmwsIHF1ZXJ5LCBmcmFnbWVudCwgaGFzUm91dGU6IGZhbHNlIH07XG4gIH1cblxuICAvLyBmYWxsIGJhY2sgdG8gdGFyZ2V0IGV2ZW4gZm9yIGNsaWVudCBzcGFucywgaWYgbm8gVVJMIGlzIHByZXNlbnRcbiAgaWYgKHR5cGVvZiBodHRwVGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB7IHVybFBhdGg6IGNvcmUuc3RyaXBVcmxRdWVyeUFuZEZyYWdtZW50KGh0dHBUYXJnZXQpLCB1cmwsIHF1ZXJ5LCBmcmFnbWVudCwgaGFzUm91dGU6IGZhbHNlIH07XG4gIH1cblxuICByZXR1cm4geyB1cmxQYXRoOiB1bmRlZmluZWQsIHVybCwgcXVlcnksIGZyYWdtZW50LCBoYXNSb3V0ZTogZmFsc2UgfTtcbn1cblxuLyoqXG4gKiBCZWNhdXNlIE90ZWwgaW5zdHJ1bWVudGF0aW9uIHNvbWV0aW1lcyBtdXRhdGVzIHNwYW4gbmFtZXMgdmlhIGBzcGFuLnVwZGF0ZU5hbWVgLCB0aGUgb25seSB3YXlcbiAqIHRvIGVuc3VyZSB0aGF0IGEgdXNlci1zZXQgc3BhbiBuYW1lIGlzIHByZXNlcnZlZCBpcyB0byBzdG9yZSBpdCBhcyBhIHRtcCBhdHRyaWJ1dGUgb24gdGhlIHNwYW4uXG4gKiBXZSBkZWxldGUgdGhpcyBhdHRyaWJ1dGUgb25jZSB3ZSdyZSBkb25lIHdpdGggaXQgd2hlbiBwcmVwYXJpbmcgdGhlIGV2ZW50IGVudmVsb3BlLlxuICpcbiAqIFRoaXMgdGVtcCBhdHRyaWJ1dGUgYWx3YXlzIHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0aGUgb3JpZ2luYWwgbmFtZS5cbiAqXG4gKiBXZSBhbHNvIG5lZWQgdG8gdGFrZSBjYXJlIG9mIHNldHRpbmcgdGhlIGNvcnJlY3Qgc291cmNlLiBVc2VycyBjYW4gYWx3YXlzIHVwZGF0ZSB0aGUgc291cmNlXG4gKiBhZnRlciB1cGRhdGluZyB0aGUgbmFtZSwgc28gd2UgbmVlZCB0byByZXNwZWN0IHRoYXQuXG4gKlxuICogQGludGVybmFsIGV4cG9ydGVkIG9ubHkgZm9yIHRlc3RpbmdcbiAqL1xuZnVuY3Rpb24gZ2V0VXNlclVwZGF0ZWROYW1lQW5kU291cmNlKFxuICBvcmlnaW5hbE5hbWUsXG4gIGF0dHJpYnV0ZXMsXG4gIGZhbGxiYWNrU291cmNlID0gJ2N1c3RvbScsXG4pXG5cbiB7XG4gIGNvbnN0IHNvdXJjZSA9IChhdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0VdICkgfHwgZmFsbGJhY2tTb3VyY2U7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfQ1VTVE9NX1NQQU5fTkFNRV07XG5cbiAgaWYgKGRlc2NyaXB0aW9uICYmIHR5cGVvZiBkZXNjcmlwdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGVzY3JpcHRpb24sXG4gICAgICBzb3VyY2UsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7IGRlc2NyaXB0aW9uOiBvcmlnaW5hbE5hbWUsIHNvdXJjZSB9O1xufVxuXG4vKipcbiAqIFNldHVwIGEgRFNDIGhhbmRsZXIgb24gdGhlIHBhc3NlZCBjbGllbnQsXG4gKiBlbnN1cmluZyB0aGF0IHRoZSB0cmFuc2FjdGlvbiBuYW1lIGlzIGluZmVycmVkIGZyb20gdGhlIHNwYW4gY29ycmVjdGx5LlxuICovXG5mdW5jdGlvbiBlbmhhbmNlRHNjV2l0aE9wZW5UZWxlbWV0cnlSb290U3Bhbk5hbWUoY2xpZW50KSB7XG4gIGNsaWVudC5vbignY3JlYXRlRHNjJywgKGRzYywgcm9vdFNwYW4pID0+IHtcbiAgICBpZiAoIXJvb3RTcGFuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gV2Ugd2FudCB0byBvdmVyd3JpdGUgdGhlIHRyYW5zYWN0aW9uIG9uIHRoZSBEU0MgdGhhdCBpcyBjcmVhdGVkIGJ5IGRlZmF1bHQgaW4gY29yZVxuICAgIC8vIFRoZSByZWFzb24gZm9yIHRoaXMgaXMgdGhhdCB3ZSB3YW50IHRvIGluZmVyIHRoZSBzcGFuIG5hbWUsIG5vdCB1c2UgdGhlIGluaXRpYWwgb25lXG4gICAgLy8gT3RoZXJ3aXNlLCB3ZSdsbCBnZXQgbmFtZXMgbGlrZSBcIkdFVFwiIGluc3RlYWQgb2YgZS5nLiBcIkdFVCAvZm9vXCJcbiAgICAvLyBgcGFyc2VTcGFuRGVzY3JpcHRpb25gIHRha2VzIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBzcGFuIGludG8gYWNjb3VudCBmb3IgdGhlIG5hbWVcbiAgICAvLyBUaGlzIG11dGF0ZXMgdGhlIHBhc3NlZC1pbiBEU0NcblxuICAgIGNvbnN0IGpzb25TcGFuID0gY29yZS5zcGFuVG9KU09OKHJvb3RTcGFuKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ganNvblNwYW4uZGF0YTtcbiAgICBjb25zdCBzb3VyY2UgPSBhdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0VdO1xuXG4gICAgY29uc3QgeyBkZXNjcmlwdGlvbiB9ID0gc3Bhbkhhc05hbWUocm9vdFNwYW4pID8gcGFyc2VTcGFuRGVzY3JpcHRpb24ocm9vdFNwYW4pIDogeyBkZXNjcmlwdGlvbjogdW5kZWZpbmVkIH07XG4gICAgaWYgKHNvdXJjZSAhPT0gJ3VybCcgJiYgZGVzY3JpcHRpb24pIHtcbiAgICAgIGRzYy50cmFuc2FjdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgIH1cblxuICAgIC8vIEFsc28gZW5zdXJlIHNhbXBsaW5nIGRlY2lzaW9uIGlzIGNvcnJlY3RseSBpbmZlcnJlZFxuICAgIC8vIEluIGNvcmUsIHdlIHVzZSBgc3BhbklzU2FtcGxlZGAsIHdoaWNoIGp1c3QgbG9va3MgYXQgdGhlIHRyYWNlIGZsYWdzXG4gICAgLy8gYnV0IGluIE9URUwsIHdlIHVzZSBhIHNsaWdodGx5IG1vcmUgY29tcGxleCBsb2dpYyB0byBiZSBhYmxlIHRvIGRpZmZlcm50aWF0ZSBiZXR3ZWVuIHVuc2FtcGxlZCBhbmQgZGVmZXJyZWQgc2FtcGxpbmdcbiAgICBpZiAoY29yZS5oYXNTcGFuc0VuYWJsZWQoKSkge1xuICAgICAgY29uc3Qgc2FtcGxlZCA9IGdldFNhbXBsaW5nRGVjaXNpb24ocm9vdFNwYW4uc3BhbkNvbnRleHQoKSk7XG4gICAgICBkc2Muc2FtcGxlZCA9IHNhbXBsZWQgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogU3RyaW5nKHNhbXBsZWQpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudGx5IGFjdGl2ZSBzcGFuLlxuICovXG5mdW5jdGlvbiBnZXRBY3RpdmVTcGFuKCkge1xuICByZXR1cm4gYXBpLnRyYWNlLmdldEFjdGl2ZVNwYW4oKTtcbn1cblxuLyoqXG4gKiBUaGlzIHNlcnZlcyBhcyBhIGJ1aWxkIHRpbWUgZmxhZyB0aGF0IHdpbGwgYmUgdHJ1ZSBieSBkZWZhdWx0LCBidXQgZmFsc2UgaW4gbm9uLWRlYnVnIGJ1aWxkcyBvciBpZiB1c2VycyByZXBsYWNlIGBfX1NFTlRSWV9ERUJVR19fYCBpbiB0aGVpciBnZW5lcmF0ZWQgY29kZS5cbiAqXG4gKiBBVFRFTlRJT046IFRoaXMgY29uc3RhbnQgbXVzdCBuZXZlciBjcm9zcyBwYWNrYWdlIGJvdW5kYXJpZXMgKGkuZS4gYmUgZXhwb3J0ZWQpIHRvIGd1YXJhbnRlZSB0aGF0IGl0IGNhbiBiZSB1c2VkIGZvciB0cmVlIHNoYWtpbmcuXG4gKi9cbmNvbnN0IERFQlVHX0JVSUxEID0gKHR5cGVvZiBfX1NFTlRSWV9ERUJVR19fID09PSAndW5kZWZpbmVkJyB8fCBfX1NFTlRSWV9ERUJVR19fKTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIFRyYWNlU3RhdGUgZm9yIHRoZSBnaXZlbiBkYXRhLlxuICovXG5mdW5jdGlvbiBtYWtlVHJhY2VTdGF0ZSh7XG4gIGRzYyxcbiAgc2FtcGxlZCxcbn1cblxuKSB7XG4gIC8vIFdlIHN0b3JlIHRoZSBEU0MgYXMgT1RFTCB0cmFjZSBzdGF0ZSBvbiB0aGUgc3BhbiBjb250ZXh0XG4gIGNvbnN0IGRzY1N0cmluZyA9IGRzYyA/IGNvcmUuZHluYW1pY1NhbXBsaW5nQ29udGV4dFRvU2VudHJ5QmFnZ2FnZUhlYWRlcihkc2MpIDogdW5kZWZpbmVkO1xuXG4gIGNvbnN0IHRyYWNlU3RhdGVCYXNlID0gbmV3IGNvcmUkMS5UcmFjZVN0YXRlKCk7XG5cbiAgY29uc3QgdHJhY2VTdGF0ZVdpdGhEc2MgPSBkc2NTdHJpbmcgPyB0cmFjZVN0YXRlQmFzZS5zZXQoU0VOVFJZX1RSQUNFX1NUQVRFX0RTQywgZHNjU3RyaW5nKSA6IHRyYWNlU3RhdGVCYXNlO1xuXG4gIC8vIFdlIGFsc28gc3BlY2lmaWNhbGx5IHdhbnQgdG8gc3RvcmUgaWYgdGhpcyBpcyBzYW1wbGVkIHRvIGJlIG5vdCByZWNvcmRpbmcsXG4gIC8vIG9yIHVuc2FtcGxlZCAoPWNvdWxkIGJlIGVpdGhlciBzYW1wbGVkIG9yIG5vdClcbiAgcmV0dXJuIHNhbXBsZWQgPT09IGZhbHNlID8gdHJhY2VTdGF0ZVdpdGhEc2Muc2V0KFNFTlRSWV9UUkFDRV9TVEFURV9TQU1QTEVEX05PVF9SRUNPUkRJTkcsICcxJykgOiB0cmFjZVN0YXRlV2l0aERzYztcbn1cblxuY29uc3Qgc2V0dXBFbGVtZW50cyA9IG5ldyBTZXQoKTtcblxuLyoqIEdldCBhbGwgdGhlIE9wZW5UZWxlbWV0cnkgZWxlbWVudHMgdGhhdCBoYXZlIGJlZW4gc2V0IHVwLiAqL1xuZnVuY3Rpb24gb3BlblRlbGVtZXRyeVNldHVwQ2hlY2soKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHNldHVwRWxlbWVudHMpO1xufVxuXG4vKiogTWFyayBhbiBPcGVuVGVsZW1ldHJ5IGVsZW1lbnQgYXMgc2V0dXAuICovXG5mdW5jdGlvbiBzZXRJc1NldHVwKGVsZW1lbnQpIHtcbiAgc2V0dXBFbGVtZW50cy5hZGQoZWxlbWVudCk7XG59XG5cbi8qKlxuICogSW5qZWN0cyBhbmQgZXh0cmFjdHMgYHNlbnRyeS10cmFjZWAgYW5kIGBiYWdnYWdlYCBoZWFkZXJzIGZyb20gY2FycmllcnMuXG4gKi9cbmNsYXNzIFNlbnRyeVByb3BhZ2F0b3IgZXh0ZW5kcyBjb3JlJDEuVzNDQmFnZ2FnZVByb3BhZ2F0b3Ige1xuICAvKiogQSBtYXAgb2YgVVJMcyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGNoZWNrZWQgZm9yIGlmIHRoZXkgbWF0Y2ggdHJhY2VQcm9wYWdhdGlvblRhcmdldHMuICovXG5cbiAgIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgc2V0SXNTZXR1cCgnU2VudHJ5UHJvcGFnYXRvcicpO1xuXG4gICAgLy8gV2UncmUgY2FjaGluZyByZXN1bHRzIHNvIHdlIGRvbid0IGhhdmUgdG8gcmVjb21wdXRlIHJlZ2V4cCBldmVyeSB0aW1lIHdlIGNyZWF0ZSBhIHJlcXVlc3QuXG4gICAgdGhpcy5fdXJsTWF0Y2hlc1RhcmdldHNNYXAgPSBuZXcgY29yZS5MUlVNYXAoMTAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIGluamVjdChjb250ZXh0LCBjYXJyaWVyLCBzZXR0ZXIpIHtcbiAgICBpZiAoY29yZSQxLmlzVHJhY2luZ1N1cHByZXNzZWQoY29udGV4dCkpIHtcbiAgICAgIERFQlVHX0JVSUxEICYmIGNvcmUuZGVidWcubG9nKCdbVHJhY2luZ10gTm90IGluamVjdGluZyB0cmFjZSBkYXRhIGZvciB1cmwgYmVjYXVzZSB0cmFjaW5nIGlzIHN1cHByZXNzZWQuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYWN0aXZlU3BhbiA9IGFwaS50cmFjZS5nZXRTcGFuKGNvbnRleHQpO1xuICAgIGNvbnN0IHVybCA9IGFjdGl2ZVNwYW4gJiYgZ2V0Q3VycmVudFVSTChhY3RpdmVTcGFuKTtcblxuICAgIGNvbnN0IHRyYWNlUHJvcGFnYXRpb25UYXJnZXRzID0gY29yZS5nZXRDbGllbnQoKT8uZ2V0T3B0aW9ucygpPy50cmFjZVByb3BhZ2F0aW9uVGFyZ2V0cztcbiAgICBpZiAoIXNob3VsZFByb3BhZ2F0ZVRyYWNlRm9yVXJsKHVybCwgdHJhY2VQcm9wYWdhdGlvblRhcmdldHMsIHRoaXMuX3VybE1hdGNoZXNUYXJnZXRzTWFwKSkge1xuICAgICAgREVCVUdfQlVJTEQgJiZcbiAgICAgICAgY29yZS5kZWJ1Zy5sb2coJ1tUcmFjaW5nXSBOb3QgaW5qZWN0aW5nIHRyYWNlIGRhdGEgZm9yIHVybCBiZWNhdXNlIGl0IGRvZXMgbm90IG1hdGNoIHRyYWNlUHJvcGFnYXRpb25UYXJnZXRzOicsIHVybCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZXhpc3RpbmdCYWdnYWdlSGVhZGVyID0gZ2V0RXhpc3RpbmdCYWdnYWdlKGNhcnJpZXIpO1xuICAgIGxldCBiYWdnYWdlID0gYXBpLnByb3BhZ2F0aW9uLmdldEJhZ2dhZ2UoY29udGV4dCkgfHwgYXBpLnByb3BhZ2F0aW9uLmNyZWF0ZUJhZ2dhZ2Uoe30pO1xuXG4gICAgY29uc3QgeyBkeW5hbWljU2FtcGxpbmdDb250ZXh0LCB0cmFjZUlkLCBzcGFuSWQsIHNhbXBsZWQgfSA9IGdldEluamVjdGlvbkRhdGEoY29udGV4dCk7XG5cbiAgICBpZiAoZXhpc3RpbmdCYWdnYWdlSGVhZGVyKSB7XG4gICAgICBjb25zdCBiYWdnYWdlRW50cmllcyA9IGNvcmUucGFyc2VCYWdnYWdlSGVhZGVyKGV4aXN0aW5nQmFnZ2FnZUhlYWRlcik7XG5cbiAgICAgIGlmIChiYWdnYWdlRW50cmllcykge1xuICAgICAgICBPYmplY3QuZW50cmllcyhiYWdnYWdlRW50cmllcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgYmFnZ2FnZSA9IGJhZ2dhZ2Uuc2V0RW50cnkoa2V5LCB7IHZhbHVlIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZHluYW1pY1NhbXBsaW5nQ29udGV4dCkge1xuICAgICAgYmFnZ2FnZSA9IE9iamVjdC5lbnRyaWVzKGR5bmFtaWNTYW1wbGluZ0NvbnRleHQpLnJlZHVjZSgoYiwgW2RzY0tleSwgZHNjVmFsdWVdKSA9PiB7XG4gICAgICAgIGlmIChkc2NWYWx1ZSkge1xuICAgICAgICAgIHJldHVybiBiLnNldEVudHJ5KGAke2NvcmUuU0VOVFJZX0JBR0dBR0VfS0VZX1BSRUZJWH0ke2RzY0tleX1gLCB7IHZhbHVlOiBkc2NWYWx1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH0sIGJhZ2dhZ2UpO1xuICAgIH1cblxuICAgIC8vIFdlIGFsc28gd2FudCB0byBhdm9pZCBzZXR0aW5nIHRoZSBkZWZhdWx0IE9URUwgdHJhY2UgSUQsIGlmIHdlIGdldCB0aGF0IGZvciB3aGF0ZXZlciByZWFzb25cbiAgICBpZiAodHJhY2VJZCAmJiB0cmFjZUlkICE9PSBhcGkuSU5WQUxJRF9UUkFDRUlEKSB7XG4gICAgICBzZXR0ZXIuc2V0KGNhcnJpZXIsIFNFTlRSWV9UUkFDRV9IRUFERVIsIGNvcmUuZ2VuZXJhdGVTZW50cnlUcmFjZUhlYWRlcih0cmFjZUlkLCBzcGFuSWQsIHNhbXBsZWQpKTtcbiAgICB9XG5cbiAgICBzdXBlci5pbmplY3QoYXBpLnByb3BhZ2F0aW9uLnNldEJhZ2dhZ2UoY29udGV4dCwgYmFnZ2FnZSksIGNhcnJpZXIsIHNldHRlcik7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBleHRyYWN0KGNvbnRleHQsIGNhcnJpZXIsIGdldHRlcikge1xuICAgIGNvbnN0IG1heWJlU2VudHJ5VHJhY2VIZWFkZXIgPSBnZXR0ZXIuZ2V0KGNhcnJpZXIsIFNFTlRSWV9UUkFDRV9IRUFERVIpO1xuICAgIGNvbnN0IGJhZ2dhZ2UgPSBnZXR0ZXIuZ2V0KGNhcnJpZXIsIFNFTlRSWV9CQUdHQUdFX0hFQURFUik7XG5cbiAgICBjb25zdCBzZW50cnlUcmFjZSA9IG1heWJlU2VudHJ5VHJhY2VIZWFkZXJcbiAgICAgID8gQXJyYXkuaXNBcnJheShtYXliZVNlbnRyeVRyYWNlSGVhZGVyKVxuICAgICAgICA/IG1heWJlU2VudHJ5VHJhY2VIZWFkZXJbMF1cbiAgICAgICAgOiBtYXliZVNlbnRyeVRyYWNlSGVhZGVyXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIC8vIEFkZCByZW1vdGUgcGFyZW50IHNwYW4gY29udGV4dFxuICAgIC8vIElmIHRoZXJlIGlzIG5vIGluY29taW5nIHRyYWNlLCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBjb250ZXh0IGFzLWlzXG4gICAgcmV0dXJuIGVuc3VyZVNjb3Blc09uQ29udGV4dChnZXRDb250ZXh0V2l0aFJlbW90ZUFjdGl2ZVNwYW4oY29udGV4dCwgeyBzZW50cnlUcmFjZSwgYmFnZ2FnZSB9KSk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBmaWVsZHMoKSB7XG4gICAgcmV0dXJuIFtTRU5UUllfVFJBQ0VfSEVBREVSLCBTRU5UUllfQkFHR0FHRV9IRUFERVJdO1xuICB9XG59XG5cbmNvbnN0IE5PVF9QUk9QQUdBVEVEX01FU1NBR0UgPVxuICAnW1RyYWNpbmddIE5vdCBpbmplY3RpbmcgdHJhY2UgZGF0YSBmb3IgdXJsIGJlY2F1c2UgaXQgZG9lcyBub3QgbWF0Y2ggdHJhY2VQcm9wYWdhdGlvblRhcmdldHM6JztcblxuLyoqXG4gKiBDaGVjayBpZiBhIGdpdmVuIFVSTCBzaG91bGQgYmUgcHJvcGFnYXRlZCB0byBvciBub3QuXG4gKiBJZiBubyB1cmwgaXMgZGVmaW5lZCwgb3Igbm8gdHJhY2UgcHJvcGFnYXRpb24gdGFyZ2V0cyBhcmUgZGVmaW5lZCwgdGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gYHRydWVgLlxuICogWW91IGNhbiBhbHNvIG9wdGlvbmFsbHkgcHJvdmlkZSBhIGRlY2lzaW9uIG1hcCwgdG8gY2FjaGUgZGVjaXNpb25zIGFuZCBhdm9pZCByZXBlYXRlZCByZWdleCBsb29rdXBzLlxuICovXG5mdW5jdGlvbiBzaG91bGRQcm9wYWdhdGVUcmFjZUZvclVybChcbiAgdXJsLFxuICB0cmFjZVByb3BhZ2F0aW9uVGFyZ2V0cyxcbiAgZGVjaXNpb25NYXAsXG4pIHtcbiAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnIHx8ICF0cmFjZVByb3BhZ2F0aW9uVGFyZ2V0cykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgY2FjaGVkRGVjaXNpb24gPSBkZWNpc2lvbk1hcD8uZ2V0KHVybCk7XG4gIGlmIChjYWNoZWREZWNpc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgREVCVUdfQlVJTEQgJiYgIWNhY2hlZERlY2lzaW9uICYmIGNvcmUuZGVidWcubG9nKE5PVF9QUk9QQUdBVEVEX01FU1NBR0UsIHVybCk7XG4gICAgcmV0dXJuIGNhY2hlZERlY2lzaW9uO1xuICB9XG5cbiAgY29uc3QgZGVjaXNpb24gPSBjb3JlLnN0cmluZ01hdGNoZXNTb21lUGF0dGVybih1cmwsIHRyYWNlUHJvcGFnYXRpb25UYXJnZXRzKTtcbiAgZGVjaXNpb25NYXA/LnNldCh1cmwsIGRlY2lzaW9uKTtcblxuICBERUJVR19CVUlMRCAmJiAhZGVjaXNpb24gJiYgY29yZS5kZWJ1Zy5sb2coTk9UX1BST1BBR0FURURfTUVTU0FHRSwgdXJsKTtcbiAgcmV0dXJuIGRlY2lzaW9uO1xufVxuXG4vKipcbiAqIEdldCBwcm9wYWdhdGlvbiBpbmplY3Rpb24gZGF0YSBmb3IgdGhlIGdpdmVuIGNvbnRleHQuXG4gKiBUaGUgYWRkaXRpb25hbCBvcHRpb25zIGNhbiBiZSBwYXNzZWQgdG8gb3ZlcnJpZGUgdGhlIHNjb3BlIGFuZCBjbGllbnQgdGhhdCBpcyBvdGhlcndpc2UgZGVyaXZlZCBmcm9tIHRoZSBjb250ZXh0LlxuICovXG5mdW5jdGlvbiBnZXRJbmplY3Rpb25EYXRhKFxuICBjb250ZXh0LFxuICBvcHRpb25zID0ge30sXG4pXG5cbiB7XG4gIGNvbnN0IHNwYW4gPSBhcGkudHJhY2UuZ2V0U3Bhbihjb250ZXh0KTtcblxuICAvLyBJZiB3ZSBoYXZlIGEgcmVtb3RlIHNwYW4sIHRoZSBzcGFuSWQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYXMgdGhlIHBhcmVudFNwYW5JZCwgbm90IHNwYW5JZCBpdHNlbGZcbiAgLy8gSW5zdGVhZCwgd2UgdXNlIGEgdmlydHVhbCAoZ2VuZXJhdGVkKSBzcGFuSWQgZm9yIHByb3BhZ2F0aW9uXG4gIGlmIChzcGFuPy5zcGFuQ29udGV4dCgpLmlzUmVtb3RlKSB7XG4gICAgY29uc3Qgc3BhbkNvbnRleHQgPSBzcGFuLnNwYW5Db250ZXh0KCk7XG4gICAgY29uc3QgZHluYW1pY1NhbXBsaW5nQ29udGV4dCA9IGNvcmUuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuKHNwYW4pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGR5bmFtaWNTYW1wbGluZ0NvbnRleHQsXG4gICAgICB0cmFjZUlkOiBzcGFuQ29udGV4dC50cmFjZUlkLFxuICAgICAgc3BhbklkOiB1bmRlZmluZWQsXG4gICAgICBzYW1wbGVkOiBnZXRTYW1wbGluZ0RlY2lzaW9uKHNwYW5Db250ZXh0KSwgLy8gVE9ETzogRG8gd2UgbmVlZCB0byBjaGFuZ2Ugc29tZXRoaW5nIGhlcmU/XG4gICAgfTtcbiAgfVxuXG4gIC8vIElmIHdlIGhhdmUgYSBsb2NhbCBzcGFuLCB3ZSBqdXN0IHVzZSB0aGlzXG4gIGlmIChzcGFuKSB7XG4gICAgY29uc3Qgc3BhbkNvbnRleHQgPSBzcGFuLnNwYW5Db250ZXh0KCk7XG4gICAgY29uc3QgZHluYW1pY1NhbXBsaW5nQ29udGV4dCA9IGNvcmUuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuKHNwYW4pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGR5bmFtaWNTYW1wbGluZ0NvbnRleHQsXG4gICAgICB0cmFjZUlkOiBzcGFuQ29udGV4dC50cmFjZUlkLFxuICAgICAgc3BhbklkOiBzcGFuQ29udGV4dC5zcGFuSWQsXG4gICAgICBzYW1wbGVkOiBnZXRTYW1wbGluZ0RlY2lzaW9uKHNwYW5Db250ZXh0KSwgLy8gVE9ETzogRG8gd2UgbmVlZCB0byBjaGFuZ2Ugc29tZXRoaW5nIGhlcmU/XG4gICAgfTtcbiAgfVxuXG4gIC8vIEVsc2Ugd2UgdHJ5IHRvIHVzZSB0aGUgcHJvcGFnYXRpb24gY29udGV4dCBmcm9tIHRoZSBzY29wZVxuICAvLyBUaGUgb25seSBzY2VuYXJpbyB3aGVyZSB0aGlzIHNob3VsZCBoYXBwZW4gaXMgd2hlbiB3ZSBuZWl0aGVyIGhhdmUgYSBzcGFuLCBub3IgYW4gaW5jb21pbmcgdHJhY2VcbiAgY29uc3Qgc2NvcGUgPSBvcHRpb25zLnNjb3BlIHx8IGdldFNjb3Blc0Zyb21Db250ZXh0KGNvbnRleHQpPy5zY29wZSB8fCBjb3JlLmdldEN1cnJlbnRTY29wZSgpO1xuICBjb25zdCBjbGllbnQgPSBvcHRpb25zLmNsaWVudCB8fCBjb3JlLmdldENsaWVudCgpO1xuXG4gIGNvbnN0IHByb3BhZ2F0aW9uQ29udGV4dCA9IHNjb3BlLmdldFByb3BhZ2F0aW9uQ29udGV4dCgpO1xuICBjb25zdCBkeW5hbWljU2FtcGxpbmdDb250ZXh0ID0gY2xpZW50ID8gY29yZS5nZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNjb3BlKGNsaWVudCwgc2NvcGUpIDogdW5kZWZpbmVkO1xuICByZXR1cm4ge1xuICAgIGR5bmFtaWNTYW1wbGluZ0NvbnRleHQsXG4gICAgdHJhY2VJZDogcHJvcGFnYXRpb25Db250ZXh0LnRyYWNlSWQsXG4gICAgc3BhbklkOiBwcm9wYWdhdGlvbkNvbnRleHQucHJvcGFnYXRpb25TcGFuSWQsXG4gICAgc2FtcGxlZDogcHJvcGFnYXRpb25Db250ZXh0LnNhbXBsZWQsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHRXaXRoUmVtb3RlQWN0aXZlU3BhbihcbiAgY3R4LFxuICB7IHNlbnRyeVRyYWNlLCBiYWdnYWdlIH0sXG4pIHtcbiAgY29uc3QgcHJvcGFnYXRpb25Db250ZXh0ID0gY29yZS5wcm9wYWdhdGlvbkNvbnRleHRGcm9tSGVhZGVycyhzZW50cnlUcmFjZSwgYmFnZ2FnZSk7XG5cbiAgY29uc3QgeyB0cmFjZUlkLCBwYXJlbnRTcGFuSWQsIHNhbXBsZWQsIGRzYyB9ID0gcHJvcGFnYXRpb25Db250ZXh0O1xuXG4gIGNvbnN0IGNsaWVudCA9IGNvcmUuZ2V0Q2xpZW50KCk7XG4gIGNvbnN0IGluY29taW5nRHNjID0gY29yZS5iYWdnYWdlSGVhZGVyVG9EeW5hbWljU2FtcGxpbmdDb250ZXh0KGJhZ2dhZ2UpO1xuXG4gIC8vIFdlIG9ubHkgd2FudCB0byBzZXQgdGhlIHZpcnR1YWwgc3BhbiBpZiB3ZSBhcmUgY29udGludWluZyBhIGNvbmNyZXRlIHRyYWNlXG4gIC8vIE90aGVyd2lzZSwgd2UgaWdub3JlIHRoZSBpbmNvbWluZyB0cmFjZSBoZXJlLCBlLmcuIGlmIHdlIGhhdmUgbm8gdHJhY2UgaGVhZGVyc1xuICBpZiAoIXBhcmVudFNwYW5JZCB8fCAoY2xpZW50ICYmICFjb3JlLnNob3VsZENvbnRpbnVlVHJhY2UoY2xpZW50LCBpbmNvbWluZ0RzYz8ub3JnX2lkKSkpIHtcbiAgICByZXR1cm4gY3R4O1xuICB9XG5cbiAgY29uc3Qgc3BhbkNvbnRleHQgPSBnZW5lcmF0ZVJlbW90ZVNwYW5Db250ZXh0KHtcbiAgICB0cmFjZUlkLFxuICAgIHNwYW5JZDogcGFyZW50U3BhbklkLFxuICAgIHNhbXBsZWQsXG4gICAgZHNjLFxuICB9KTtcblxuICByZXR1cm4gYXBpLnRyYWNlLnNldFNwYW5Db250ZXh0KGN0eCwgc3BhbkNvbnRleHQpO1xufVxuXG4vKipcbiAqIFRha2VzIHRyYWNlIHN0cmluZ3MgYW5kIHByb3BhZ2F0ZXMgdGhlbSBhcyBhIHJlbW90ZSBhY3RpdmUgc3Bhbi5cbiAqIFRoaXMgc2hvdWxkIGJlIHVzZWQgaW4gYWRkaXRpb24gdG8gYGNvbnRpbnVlVHJhY2VgIGluIE9URUwtcG93ZXJlZCBlbnZpcm9ubWVudHMuXG4gKi9cbmZ1bmN0aW9uIGNvbnRpbnVlVHJhY2VBc1JlbW90ZVNwYW4oXG4gIGN0eCxcbiAgb3B0aW9ucyxcbiAgY2FsbGJhY2ssXG4pIHtcbiAgY29uc3QgY3R4V2l0aFNwYW5Db250ZXh0ID0gZW5zdXJlU2NvcGVzT25Db250ZXh0KGdldENvbnRleHRXaXRoUmVtb3RlQWN0aXZlU3BhbihjdHgsIG9wdGlvbnMpKTtcblxuICByZXR1cm4gYXBpLmNvbnRleHQud2l0aChjdHhXaXRoU3BhbkNvbnRleHQsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlU2NvcGVzT25Db250ZXh0KGN0eCkge1xuICAvLyBJZiB0aGVyZSBhcmUgbm8gc2NvcGVzIHlldCBvbiB0aGUgY29udGV4dCwgZW5zdXJlIHdlIGhhdmUgdGhlbVxuICBjb25zdCBzY29wZXMgPSBnZXRTY29wZXNGcm9tQ29udGV4dChjdHgpO1xuICBjb25zdCBuZXdTY29wZXMgPSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBubyBzY29wZSBoZXJlLCB0aGlzIGlzIG1vc3QgbGlrZWx5IGVpdGhlciB0aGUgcm9vdCBjb250ZXh0IG9yIGEgY29udGV4dCBtYW51YWxseSBkZXJpdmVkIGZyb20gaXRcbiAgICAvLyBJbiB0aGlzIGNhc2UsIHdlIHdhbnQgdG8gZm9yayB0aGUgY3VycmVudCBzY29wZSwgdG8gZW5zdXJlIHdlIGRvIG5vdCBwb2xsdXRlIHRoZSByb290IHNjb3BlXG4gICAgc2NvcGU6IHNjb3BlcyA/IHNjb3Blcy5zY29wZSA6IGNvcmUuZ2V0Q3VycmVudFNjb3BlKCkuY2xvbmUoKSxcbiAgICBpc29sYXRpb25TY29wZTogc2NvcGVzID8gc2NvcGVzLmlzb2xhdGlvblNjb3BlIDogY29yZS5nZXRJc29sYXRpb25TY29wZSgpLFxuICB9O1xuXG4gIHJldHVybiBzZXRTY29wZXNPbkNvbnRleHQoY3R4LCBuZXdTY29wZXMpO1xufVxuXG4vKiogVHJ5IHRvIGdldCB0aGUgZXhpc3RpbmcgYmFnZ2FnZSBoZWFkZXIgc28gd2UgY2FuIG1lcmdlIHRoaXMgaW4uICovXG5mdW5jdGlvbiBnZXRFeGlzdGluZ0JhZ2dhZ2UoY2Fycmllcikge1xuICB0cnkge1xuICAgIGNvbnN0IGJhZ2dhZ2UgPSAoY2FycmllciApW1NFTlRSWV9CQUdHQUdFX0hFQURFUl07XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYmFnZ2FnZSkgPyBiYWdnYWdlLmpvaW4oJywnKSA6IGJhZ2dhZ2U7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBJdCBpcyBwcmV0dHkgdHJpY2t5IHRvIGdldCBhY2Nlc3MgdG8gdGhlIG91dGdvaW5nIHJlcXVlc3QgVVJMIG9mIGEgcmVxdWVzdCBpbiB0aGUgcHJvcGFnYXRvci5cbiAqIEFzIHdlIG9ubHkgaGF2ZSBhY2Nlc3MgdG8gdGhlIGNvbnRleHQgb2YgdGhlIHNwYW4gdG8gYmUgc2VudCBhbmQgdGhlIGNhcnJpZXIgKD1oZWFkZXJzKSxcbiAqIGJ1dCB0aGUgc3BhbiBtYXkgYmUgdW5zYW1wbGVkIGFuZCB0aHVzIGhhdmUgbm8gYXR0cmlidXRlcy5cbiAqXG4gKiBTbyB3ZSB1c2UgdGhlIGZvbGxvd2luZyBsb2dpYzpcbiAqIDEuIElmIHdlIGhhdmUgYW4gYWN0aXZlIHNwYW4sIHdlIGNoZWNrIGlmIGl0IGhhcyBhIFVSTCBhdHRyaWJ1dGUuXG4gKiAyLiBFbHNlLCBpZiB0aGUgYWN0aXZlIHNwYW4gaGFzIG5vIFVSTCBhdHRyaWJ1dGUgKGUuZy4gaXQgaXMgdW5zYW1wbGVkKSwgd2UgY2hlY2sgYSBzcGVjaWFsIHRyYWNlIHN0YXRlICh3aGljaCB3ZSBzZXQgaW4gb3VyIHNhbXBsZXIpLlxuICovXG5mdW5jdGlvbiBnZXRDdXJyZW50VVJMKHNwYW4pIHtcbiAgY29uc3Qgc3BhbkRhdGEgPSBjb3JlLnNwYW5Ub0pTT04oc3BhbikuZGF0YTtcbiAgLy8gYEFUVFJfVVJMX0ZVTExgIGlzIHRoZSBuZXcgYXR0cmlidXRlLCBidXQgd2Ugc3RpbGwgc3VwcG9ydCB0aGUgb2xkIG9uZSwgYFNFTUFUVFJTX0hUVFBfVVJMYCwgZm9yIG5vdy5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIGNvbnN0IHVybEF0dHJpYnV0ZSA9IHNwYW5EYXRhW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9VUkxdIHx8IHNwYW5EYXRhW3NlbWFudGljQ29udmVudGlvbnMuQVRUUl9VUkxfRlVMTF07XG4gIGlmICh0eXBlb2YgdXJsQXR0cmlidXRlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB1cmxBdHRyaWJ1dGU7XG4gIH1cblxuICAvLyBBbHNvIGxvb2sgYXQgdGhlIHRyYWNlU3RhdGUsIHdoaWNoIHdlIG1heSBzZXQgaW4gdGhlIHNhbXBsZXIgZXZlbiBmb3IgdW5zYW1wbGVkIHNwYW5zXG4gIGNvbnN0IHVybFRyYWNlU3RhdGUgPSBzcGFuLnNwYW5Db250ZXh0KCkudHJhY2VTdGF0ZT8uZ2V0KFNFTlRSWV9UUkFDRV9TVEFURV9VUkwpO1xuICBpZiAodXJsVHJhY2VTdGF0ZSkge1xuICAgIHJldHVybiB1cmxUcmFjZVN0YXRlO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVSZW1vdGVTcGFuQ29udGV4dCh7XG4gIHNwYW5JZCxcbiAgdHJhY2VJZCxcbiAgc2FtcGxlZCxcbiAgZHNjLFxufVxuXG4pIHtcbiAgLy8gV2Ugc3RvcmUgdGhlIERTQyBhcyBPVEVMIHRyYWNlIHN0YXRlIG9uIHRoZSBzcGFuIGNvbnRleHRcbiAgY29uc3QgdHJhY2VTdGF0ZSA9IG1ha2VUcmFjZVN0YXRlKHtcbiAgICBkc2MsXG4gICAgc2FtcGxlZCxcbiAgfSk7XG5cbiAgY29uc3Qgc3BhbkNvbnRleHQgPSB7XG4gICAgdHJhY2VJZCxcbiAgICBzcGFuSWQsXG4gICAgaXNSZW1vdGU6IHRydWUsXG4gICAgdHJhY2VGbGFnczogc2FtcGxlZCA/IGFwaS5UcmFjZUZsYWdzLlNBTVBMRUQgOiBhcGkuVHJhY2VGbGFncy5OT05FLFxuICAgIHRyYWNlU3RhdGUsXG4gIH07XG5cbiAgcmV0dXJuIHNwYW5Db250ZXh0O1xufVxuXG4vKipcbiAqIFdyYXBzIGEgZnVuY3Rpb24gd2l0aCBhIHRyYW5zYWN0aW9uL3NwYW4gYW5kIGZpbmlzaGVzIHRoZSBzcGFuIGFmdGVyIHRoZSBmdW5jdGlvbiBpcyBkb25lLlxuICogVGhlIGNyZWF0ZWQgc3BhbiBpcyB0aGUgYWN0aXZlIHNwYW4gYW5kIHdpbGwgYmUgdXNlZCBhcyBwYXJlbnQgYnkgb3RoZXIgc3BhbnMgY3JlYXRlZCBpbnNpZGUgdGhlIGZ1bmN0aW9uXG4gKiBhbmQgY2FuIGJlIGFjY2Vzc2VkIHZpYSBgU2VudHJ5LmdldEFjdGl2ZVNwYW4oKWAsIGFzIGxvbmcgYXMgdGhlIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIHdoaWxlIHRoZSBzY29wZSBpcyBhY3RpdmUuXG4gKlxuICogSWYgeW91IHdhbnQgdG8gY3JlYXRlIGEgc3BhbiB0aGF0IGlzIG5vdCBzZXQgYXMgYWN0aXZlLCB1c2Uge0BsaW5rIHN0YXJ0SW5hY3RpdmVTcGFufS5cbiAqXG4gKiBZb3UnbGwgYWx3YXlzIGdldCBhIHNwYW4gcGFzc2VkIHRvIHRoZSBjYWxsYmFjayxcbiAqIGl0IG1heSBqdXN0IGJlIGEgbm9uLXJlY29yZGluZyBzcGFuIGlmIHRoZSBzcGFuIGlzIG5vdCBzYW1wbGVkIG9yIGlmIHRyYWNpbmcgaXMgZGlzYWJsZWQuXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0U3BhbihvcHRpb25zLCBjYWxsYmFjaykge1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIoKTtcblxuICBjb25zdCB7IG5hbWUsIHBhcmVudFNwYW46IGN1c3RvbVBhcmVudFNwYW4gfSA9IG9wdGlvbnM7XG5cbiAgLy8gSWYgYG9wdGlvbnMucGFyZW50U3BhbmAgaXMgZGVmaW5lZCwgd2Ugd2FudCB0byB3cmFwIHRoZSBjYWxsYmFjayBpbiBgd2l0aEFjdGl2ZVNwYW5gXG4gIGNvbnN0IHdyYXBwZXIgPSBnZXRBY3RpdmVTcGFuV3JhcHBlcihjdXN0b21QYXJlbnRTcGFuKTtcblxuICByZXR1cm4gd3JhcHBlcigoKSA9PiB7XG4gICAgY29uc3QgYWN0aXZlQ3R4ID0gZ2V0Q29udGV4dChvcHRpb25zLnNjb3BlLCBvcHRpb25zLmZvcmNlVHJhbnNhY3Rpb24pO1xuICAgIGNvbnN0IHNob3VsZFNraXBTcGFuID0gb3B0aW9ucy5vbmx5SWZQYXJlbnQgJiYgIWFwaS50cmFjZS5nZXRTcGFuKGFjdGl2ZUN0eCk7XG4gICAgY29uc3QgY3R4ID0gc2hvdWxkU2tpcFNwYW4gPyBjb3JlJDEuc3VwcHJlc3NUcmFjaW5nKGFjdGl2ZUN0eCkgOiBhY3RpdmVDdHg7XG5cbiAgICBjb25zdCBzcGFuT3B0aW9ucyA9IGdldFNwYW5PcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHRyYWNlci5zdGFydEFjdGl2ZVNwYW4obmFtZSwgc3Bhbk9wdGlvbnMsIGN0eCwgc3BhbiA9PiB7XG4gICAgICByZXR1cm4gY29yZS5oYW5kbGVDYWxsYmFja0Vycm9ycyhcbiAgICAgICAgKCkgPT4gY2FsbGJhY2soc3BhbiksXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICAvLyBPbmx5IHNldCB0aGUgc3BhbiBzdGF0dXMgdG8gRVJST1Igd2hlbiB0aGVyZSB3YXNuJ3QgYW55IHN0YXR1cyBzZXQgYmVmb3JlLCBpbiBvcmRlciB0byBhdm9pZCBzdG9tcGluZyB1c2VmdWwgc3BhbiBzdGF0dXNlc1xuICAgICAgICAgIGlmIChjb3JlLnNwYW5Ub0pTT04oc3Bhbikuc3RhdHVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHsgY29kZTogYXBpLlNwYW5TdGF0dXNDb2RlLkVSUk9SIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgKCkgPT4gc3Bhbi5lbmQoKSxcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNpbWlsYXIgdG8gYFNlbnRyeS5zdGFydFNwYW5gLiBXcmFwcyBhIGZ1bmN0aW9uIHdpdGggYSBzcGFuLCBidXQgZG9lcyBub3QgZmluaXNoIHRoZSBzcGFuXG4gKiBhZnRlciB0aGUgZnVuY3Rpb24gaXMgZG9uZSBhdXRvbWF0aWNhbGx5LiBZb3UnbGwgaGF2ZSB0byBjYWxsIGBzcGFuLmVuZCgpYCBtYW51YWxseS5cbiAqXG4gKiBUaGUgY3JlYXRlZCBzcGFuIGlzIHRoZSBhY3RpdmUgc3BhbiBhbmQgd2lsbCBiZSB1c2VkIGFzIHBhcmVudCBieSBvdGhlciBzcGFucyBjcmVhdGVkIGluc2lkZSB0aGUgZnVuY3Rpb25cbiAqIGFuZCBjYW4gYmUgYWNjZXNzZWQgdmlhIGBTZW50cnkuZ2V0QWN0aXZlU3BhbigpYCwgYXMgbG9uZyBhcyB0aGUgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgd2hpbGUgdGhlIHNjb3BlIGlzIGFjdGl2ZS5cbiAqXG4gKiBZb3UnbGwgYWx3YXlzIGdldCBhIHNwYW4gcGFzc2VkIHRvIHRoZSBjYWxsYmFjayxcbiAqIGl0IG1heSBqdXN0IGJlIGEgbm9uLXJlY29yZGluZyBzcGFuIGlmIHRoZSBzcGFuIGlzIG5vdCBzYW1wbGVkIG9yIGlmIHRyYWNpbmcgaXMgZGlzYWJsZWQuXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0U3Bhbk1hbnVhbChcbiAgb3B0aW9ucyxcbiAgY2FsbGJhY2ssXG4pIHtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKCk7XG5cbiAgY29uc3QgeyBuYW1lLCBwYXJlbnRTcGFuOiBjdXN0b21QYXJlbnRTcGFuIH0gPSBvcHRpb25zO1xuXG4gIC8vIElmIGBvcHRpb25zLnBhcmVudFNwYW5gIGlzIGRlZmluZWQsIHdlIHdhbnQgdG8gd3JhcCB0aGUgY2FsbGJhY2sgaW4gYHdpdGhBY3RpdmVTcGFuYFxuICBjb25zdCB3cmFwcGVyID0gZ2V0QWN0aXZlU3BhbldyYXBwZXIoY3VzdG9tUGFyZW50U3Bhbik7XG5cbiAgcmV0dXJuIHdyYXBwZXIoKCkgPT4ge1xuICAgIGNvbnN0IGFjdGl2ZUN0eCA9IGdldENvbnRleHQob3B0aW9ucy5zY29wZSwgb3B0aW9ucy5mb3JjZVRyYW5zYWN0aW9uKTtcbiAgICBjb25zdCBzaG91bGRTa2lwU3BhbiA9IG9wdGlvbnMub25seUlmUGFyZW50ICYmICFhcGkudHJhY2UuZ2V0U3BhbihhY3RpdmVDdHgpO1xuICAgIGNvbnN0IGN0eCA9IHNob3VsZFNraXBTcGFuID8gY29yZSQxLnN1cHByZXNzVHJhY2luZyhhY3RpdmVDdHgpIDogYWN0aXZlQ3R4O1xuXG4gICAgY29uc3Qgc3Bhbk9wdGlvbnMgPSBnZXRTcGFuT3B0aW9ucyhvcHRpb25zKTtcblxuICAgIHJldHVybiB0cmFjZXIuc3RhcnRBY3RpdmVTcGFuKG5hbWUsIHNwYW5PcHRpb25zLCBjdHgsIHNwYW4gPT4ge1xuICAgICAgcmV0dXJuIGNvcmUuaGFuZGxlQ2FsbGJhY2tFcnJvcnMoXG4gICAgICAgICgpID0+IGNhbGxiYWNrKHNwYW4sICgpID0+IHNwYW4uZW5kKCkpLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgLy8gT25seSBzZXQgdGhlIHNwYW4gc3RhdHVzIHRvIEVSUk9SIHdoZW4gdGhlcmUgd2Fzbid0IGFueSBzdGF0dXMgc2V0IGJlZm9yZSwgaW4gb3JkZXIgdG8gYXZvaWQgc3RvbXBpbmcgdXNlZnVsIHNwYW4gc3RhdHVzZXNcbiAgICAgICAgICBpZiAoY29yZS5zcGFuVG9KU09OKHNwYW4pLnN0YXR1cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzcGFuLnNldFN0YXR1cyh7IGNvZGU6IGFwaS5TcGFuU3RhdHVzQ29kZS5FUlJPUiB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3Bhbi4gVGhpcyBzcGFuIGlzIG5vdCBzZXQgYXMgYWN0aXZlLCBzbyB3aWxsIG5vdCBnZXQgYXV0b21hdGljIGluc3RydW1lbnRhdGlvbiBzcGFuc1xuICogYXMgY2hpbGRyZW4gb3IgYmUgYWJsZSB0byBiZSBhY2Nlc3NlZCB2aWEgYFNlbnRyeS5nZXRBY3RpdmVTcGFuKClgLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIGNyZWF0ZSBhIHNwYW4gdGhhdCBpcyBzZXQgYXMgYWN0aXZlLCB1c2Uge0BsaW5rIHN0YXJ0U3Bhbn0uXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGFsd2F5cyByZXR1cm4gYSBzcGFuLFxuICogaXQgbWF5IGp1c3QgYmUgYSBub24tcmVjb3JkaW5nIHNwYW4gaWYgdGhlIHNwYW4gaXMgbm90IHNhbXBsZWQgb3IgaWYgdHJhY2luZyBpcyBkaXNhYmxlZC5cbiAqL1xuZnVuY3Rpb24gc3RhcnRJbmFjdGl2ZVNwYW4ob3B0aW9ucykge1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIoKTtcblxuICBjb25zdCB7IG5hbWUsIHBhcmVudFNwYW46IGN1c3RvbVBhcmVudFNwYW4gfSA9IG9wdGlvbnM7XG5cbiAgLy8gSWYgYG9wdGlvbnMucGFyZW50U3BhbmAgaXMgZGVmaW5lZCwgd2Ugd2FudCB0byB3cmFwIHRoZSBjYWxsYmFjayBpbiBgd2l0aEFjdGl2ZVNwYW5gXG4gIGNvbnN0IHdyYXBwZXIgPSBnZXRBY3RpdmVTcGFuV3JhcHBlcihjdXN0b21QYXJlbnRTcGFuKTtcblxuICByZXR1cm4gd3JhcHBlcigoKSA9PiB7XG4gICAgY29uc3QgYWN0aXZlQ3R4ID0gZ2V0Q29udGV4dChvcHRpb25zLnNjb3BlLCBvcHRpb25zLmZvcmNlVHJhbnNhY3Rpb24pO1xuICAgIGNvbnN0IHNob3VsZFNraXBTcGFuID0gb3B0aW9ucy5vbmx5SWZQYXJlbnQgJiYgIWFwaS50cmFjZS5nZXRTcGFuKGFjdGl2ZUN0eCk7XG4gICAgY29uc3QgY3R4ID0gc2hvdWxkU2tpcFNwYW4gPyBjb3JlJDEuc3VwcHJlc3NUcmFjaW5nKGFjdGl2ZUN0eCkgOiBhY3RpdmVDdHg7XG5cbiAgICBjb25zdCBzcGFuT3B0aW9ucyA9IGdldFNwYW5PcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgY29uc3Qgc3BhbiA9IHRyYWNlci5zdGFydFNwYW4obmFtZSwgc3Bhbk9wdGlvbnMsIGN0eCk7XG5cbiAgICByZXR1cm4gc3BhbjtcbiAgfSk7XG59XG5cbi8qKlxuICogRm9ya3MgdGhlIGN1cnJlbnQgc2NvcGUgYW5kIHNldHMgdGhlIHByb3ZpZGVkIHNwYW4gYXMgYWN0aXZlIHNwYW4gaW4gdGhlIGNvbnRleHQgb2YgdGhlIHByb3ZpZGVkIGNhbGxiYWNrLiBDYW4gYmVcbiAqIHBhc3NlZCBgbnVsbGAgdG8gc3RhcnQgYW4gZW50aXJlbHkgbmV3IHNwYW4gdHJlZS5cbiAqXG4gKiBAcGFyYW0gc3BhbiBTcGFucyBzdGFydGVkIGluIHRoZSBjb250ZXh0IG9mIHRoZSBwcm92aWRlZCBjYWxsYmFjayB3aWxsIGJlIGNoaWxkcmVuIG9mIHRoaXMgc3Bhbi4gSWYgYG51bGxgIGlzIHBhc3NlZCxcbiAqIHNwYW5zIHN0YXJ0ZWQgd2l0aGluIHRoZSBjYWxsYmFjayB3aWxsIGJlIHJvb3Qgc3BhbnMuXG4gKiBAcGFyYW0gY2FsbGJhY2sgRXhlY3V0aW9uIGNvbnRleHQgaW4gd2hpY2ggdGhlIHByb3ZpZGVkIHNwYW4gd2lsbCBiZSBhY3RpdmUuIElzIHBhc3NlZCB0aGUgbmV3bHkgZm9ya2VkIHNjb3BlLlxuICogQHJldHVybnMgdGhlIHZhbHVlIHJldHVybmVkIGZyb20gdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB3aXRoQWN0aXZlU3BhbihzcGFuLCBjYWxsYmFjaykge1xuICBjb25zdCBuZXdDb250ZXh0V2l0aEFjdGl2ZVNwYW4gPSBzcGFuID8gYXBpLnRyYWNlLnNldFNwYW4oYXBpLmNvbnRleHQuYWN0aXZlKCksIHNwYW4pIDogYXBpLnRyYWNlLmRlbGV0ZVNwYW4oYXBpLmNvbnRleHQuYWN0aXZlKCkpO1xuICByZXR1cm4gYXBpLmNvbnRleHQud2l0aChuZXdDb250ZXh0V2l0aEFjdGl2ZVNwYW4sICgpID0+IGNhbGxiYWNrKGNvcmUuZ2V0Q3VycmVudFNjb3BlKCkpKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJhY2VyKCkge1xuICBjb25zdCBjbGllbnQgPSBjb3JlLmdldENsaWVudCgpO1xuICByZXR1cm4gY2xpZW50Py50cmFjZXIgfHwgYXBpLnRyYWNlLmdldFRyYWNlcignQHNlbnRyeS9vcGVudGVsZW1ldHJ5JywgY29yZS5TREtfVkVSU0lPTik7XG59XG5cbmZ1bmN0aW9uIGdldFNwYW5PcHRpb25zKG9wdGlvbnMpIHtcbiAgY29uc3QgeyBzdGFydFRpbWUsIGF0dHJpYnV0ZXMsIGtpbmQsIG9wLCBsaW5rcyB9ID0gb3B0aW9ucztcblxuICAvLyBPVEVMIGV4cGVjdHMgdGltZXN0YW1wcyBpbiBtcywgbm90IHNlY29uZHNcbiAgY29uc3QgZml4ZWRTdGFydFRpbWUgPSB0eXBlb2Ygc3RhcnRUaW1lID09PSAnbnVtYmVyJyA/IGVuc3VyZVRpbWVzdGFtcEluTWlsbGlzZWNvbmRzKHN0YXJ0VGltZSkgOiBzdGFydFRpbWU7XG5cbiAgcmV0dXJuIHtcbiAgICBhdHRyaWJ1dGVzOiBvcFxuICAgICAgPyB7XG4gICAgICAgICAgW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUF06IG9wLFxuICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgIH1cbiAgICAgIDogYXR0cmlidXRlcyxcbiAgICBraW5kLFxuICAgIGxpbmtzLFxuICAgIHN0YXJ0VGltZTogZml4ZWRTdGFydFRpbWUsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGVuc3VyZVRpbWVzdGFtcEluTWlsbGlzZWNvbmRzKHRpbWVzdGFtcCkge1xuICBjb25zdCBpc01zID0gdGltZXN0YW1wIDwgOTk5OTk5OTk5OTtcbiAgcmV0dXJuIGlzTXMgPyB0aW1lc3RhbXAgKiAxMDAwIDogdGltZXN0YW1wO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0KHNjb3BlLCBmb3JjZVRyYW5zYWN0aW9uKSB7XG4gIGNvbnN0IGN0eCA9IGdldENvbnRleHRGb3JTY29wZShzY29wZSk7XG4gIGNvbnN0IHBhcmVudFNwYW4gPSBhcGkudHJhY2UuZ2V0U3BhbihjdHgpO1xuXG4gIC8vIEluIHRoZSBjYXNlIHRoYXQgd2UgaGF2ZSBubyBwYXJlbnQgc3Bhbiwgd2Ugc3RhcnQgYSBuZXcgdHJhY2VcbiAgLy8gTm90ZSB0aGF0IGlmIHdlIGNvbnRpbnVlIGEgdHJhY2UsIHdlJ2xsIGFsd2F5cyBoYXZlIGEgcmVtb3RlIHBhcmVudCBzcGFuIGhlcmUgYW55aG93XG4gIGlmICghcGFyZW50U3Bhbikge1xuICAgIHJldHVybiBjdHg7XG4gIH1cblxuICAvLyBJZiB3ZSBkb24ndCB3YW50IHRvIGZvcmNlIGEgdHJhbnNhY3Rpb24sIGFuZCB3ZSBoYXZlIGEgcGFyZW50IHNwYW4sIGFsbCBnb29kLCB3ZSBqdXN0IHJldHVybiBhcy1pcyFcbiAgaWYgKCFmb3JjZVRyYW5zYWN0aW9uKSB7XG4gICAgcmV0dXJuIGN0eDtcbiAgfVxuXG4gIC8vIEVsc2UsIGlmIHdlIGRvIGhhdmUgYSBwYXJlbnQgc3BhbiBidXQgd2FudCB0byBmb3JjZSBhIHRyYW5zYWN0aW9uLCB3ZSBoYXZlIHRvIHNpbXVsYXRlIGEgXCJyb290XCIgY29udGV4dFxuXG4gIC8vIEVsc2UsIHdlIG5lZWQgdG8gZG8gdHdvIHRoaW5nczpcbiAgLy8gMS4gVW5zZXQgdGhlIHBhcmVudCBzcGFuIGZyb20gdGhlIGNvbnRleHQsIHNvIHdlJ2xsIGNyZWF0ZSBhIG5ldyByb290IHNwYW5cbiAgLy8gMi4gRW5zdXJlIHRoZSBwcm9wYWdhdGlvbiBjb250ZXh0IGlzIGNvcnJlY3QsIHNvIHdlJ2xsIGNvbnRpbnVlIGZyb20gdGhlIHBhcmVudCBzcGFuXG4gIGNvbnN0IGN0eFdpdGhvdXRTcGFuID0gYXBpLnRyYWNlLmRlbGV0ZVNwYW4oY3R4KTtcblxuICBjb25zdCB7IHNwYW5JZCwgdHJhY2VJZCB9ID0gcGFyZW50U3Bhbi5zcGFuQ29udGV4dCgpO1xuICBjb25zdCBzYW1wbGVkID0gZ2V0U2FtcGxpbmdEZWNpc2lvbihwYXJlbnRTcGFuLnNwYW5Db250ZXh0KCkpO1xuXG4gIC8vIEluIHRoaXMgY2FzZSwgd2hlbiB3ZSBhcmUgZm9yY2luZyBhIHRyYW5zYWN0aW9uLCB3ZSB3YW50IHRvIHRyZWF0IHRoaXMgbGlrZSBjb250aW51aW5nIGFuIGluY29taW5nIHRyYWNlXG4gIC8vIHNvIHdlIHNldCB0aGUgdHJhY2VTdGF0ZSBhY2NvcmRpbmcgdG8gdGhlIHJvb3Qgc3BhblxuICBjb25zdCByb290U3BhbiA9IGNvcmUuZ2V0Um9vdFNwYW4ocGFyZW50U3Bhbik7XG4gIGNvbnN0IGRzYyA9IGNvcmUuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuKHJvb3RTcGFuKTtcblxuICBjb25zdCB0cmFjZVN0YXRlID0gbWFrZVRyYWNlU3RhdGUoe1xuICAgIGRzYyxcbiAgICBzYW1wbGVkLFxuICB9KTtcblxuICBjb25zdCBzcGFuT3B0aW9ucyA9IHtcbiAgICB0cmFjZUlkLFxuICAgIHNwYW5JZCxcbiAgICBpc1JlbW90ZTogdHJ1ZSxcbiAgICB0cmFjZUZsYWdzOiBzYW1wbGVkID8gYXBpLlRyYWNlRmxhZ3MuU0FNUExFRCA6IGFwaS5UcmFjZUZsYWdzLk5PTkUsXG4gICAgdHJhY2VTdGF0ZSxcbiAgfTtcblxuICBjb25zdCBjdHhXaXRoU3BhbkNvbnRleHQgPSBhcGkudHJhY2Uuc2V0U3BhbkNvbnRleHQoY3R4V2l0aG91dFNwYW4sIHNwYW5PcHRpb25zKTtcblxuICByZXR1cm4gY3R4V2l0aFNwYW5Db250ZXh0O1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0Rm9yU2NvcGUoc2NvcGUpIHtcbiAgaWYgKHNjb3BlKSB7XG4gICAgY29uc3QgY3R4ID0gZ2V0Q29udGV4dEZyb21TY29wZShzY29wZSk7XG4gICAgaWYgKGN0eCkge1xuICAgICAgcmV0dXJuIGN0eDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXBpLmNvbnRleHQuYWN0aXZlKCk7XG59XG5cbi8qKlxuICogQ29udGludWUgYSB0cmFjZSBmcm9tIGBzZW50cnktdHJhY2VgIGFuZCBgYmFnZ2FnZWAgdmFsdWVzLlxuICogVGhlc2UgdmFsdWVzIGNhbiBiZSBvYnRhaW5lZCBmcm9tIGluY29taW5nIHJlcXVlc3QgaGVhZGVycywgb3IgaW4gdGhlIGJyb3dzZXIgZnJvbSBgPG1ldGEgbmFtZT1cInNlbnRyeS10cmFjZVwiPmBcbiAqIGFuZCBgPG1ldGEgbmFtZT1cImJhZ2dhZ2VcIj5gIEhUTUwgdGFncy5cbiAqXG4gKiBTcGFucyBzdGFydGVkIHdpdGggYHN0YXJ0U3BhbmAsIGBzdGFydFNwYW5NYW51YWxgIGFuZCBgc3RhcnRJbmFjdGl2ZVNwYW5gLCB3aXRoaW4gdGhlIGNhbGxiYWNrIHdpbGwgYXV0b21hdGljYWxseVxuICogYmUgYXR0YWNoZWQgdG8gdGhlIGluY29taW5nIHRyYWNlLlxuICpcbiAqIFRoaXMgaXMgYSBjdXN0b20gdmVyc2lvbiBvZiBgY29udGludWVUcmFjZWAgdGhhdCBpcyB1c2VkIGluIE9URUwtcG93ZXJlZCBlbnZpcm9ubWVudHMuXG4gKiBJdCBwcm9wYWdhdGVzIHRoZSB0cmFjZSBhcyBhIHJlbW90ZSBzcGFuLCBpbiBhZGRpdGlvbiB0byBzZXR0aW5nIGl0IG9uIHRoZSBwcm9wYWdhdGlvbiBjb250ZXh0LlxuICovXG5mdW5jdGlvbiBjb250aW51ZVRyYWNlKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBjb250aW51ZVRyYWNlQXNSZW1vdGVTcGFuKGFwaS5jb250ZXh0LmFjdGl2ZSgpLCBvcHRpb25zLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogR2V0IHRoZSB0cmFjZSBjb250ZXh0IGZvciBhIGdpdmVuIHNjb3BlLlxuICogV2UgaGF2ZSBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiBoZXJlIGJlY2F1c2Ugd2UgbmVlZCBhbiBPVEVMLXNwZWNpZmljIHdheSB0byBnZXQgdGhlIHNwYW4gZnJvbSBhIHNjb3BlLlxuICovXG5mdW5jdGlvbiBnZXRUcmFjZUNvbnRleHRGb3JTY29wZShcbiAgY2xpZW50LFxuICBzY29wZSxcbikge1xuICBjb25zdCBjdHggPSBnZXRDb250ZXh0RnJvbVNjb3BlKHNjb3BlKTtcbiAgY29uc3Qgc3BhbiA9IGN0eCAmJiBhcGkudHJhY2UuZ2V0U3BhbihjdHgpO1xuXG4gIGNvbnN0IHRyYWNlQ29udGV4dCA9IHNwYW4gPyBjb3JlLnNwYW5Ub1RyYWNlQ29udGV4dChzcGFuKSA6IGNvcmUuZ2V0VHJhY2VDb250ZXh0RnJvbVNjb3BlKHNjb3BlKTtcblxuICBjb25zdCBkeW5hbWljU2FtcGxpbmdDb250ZXh0ID0gc3BhblxuICAgID8gY29yZS5nZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW4oc3BhbilcbiAgICA6IGNvcmUuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TY29wZShjbGllbnQsIHNjb3BlKTtcbiAgcmV0dXJuIFtkeW5hbWljU2FtcGxpbmdDb250ZXh0LCB0cmFjZUNvbnRleHRdO1xufVxuXG5mdW5jdGlvbiBnZXRBY3RpdmVTcGFuV3JhcHBlcihwYXJlbnRTcGFuKSB7XG4gIHJldHVybiBwYXJlbnRTcGFuICE9PSB1bmRlZmluZWRcbiAgICA/IChjYWxsYmFjaykgPT4ge1xuICAgICAgICByZXR1cm4gd2l0aEFjdGl2ZVNwYW4ocGFyZW50U3BhbiwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIDogKGNhbGxiYWNrKSA9PiBjYWxsYmFjaygpO1xufVxuXG4vKiogU3VwcHJlc3MgdHJhY2luZyBpbiB0aGUgZ2l2ZW4gY2FsbGJhY2ssIGVuc3VyaW5nIG5vIHNwYW5zIGFyZSBnZW5lcmF0ZWQgaW5zaWRlIG9mIGl0LiAqL1xuZnVuY3Rpb24gc3VwcHJlc3NUcmFjaW5nKGNhbGxiYWNrKSB7XG4gIGNvbnN0IGN0eCA9IGNvcmUkMS5zdXBwcmVzc1RyYWNpbmcoYXBpLmNvbnRleHQuYWN0aXZlKCkpO1xuICByZXR1cm4gYXBpLmNvbnRleHQud2l0aChjdHgsIGNhbGxiYWNrKTtcbn1cblxuLyoqIEVuc3VyZSB0aGUgYHRyYWNlYCBjb250ZXh0IGlzIHNldCBvbiBhbGwgZXZlbnRzLiAqL1xuZnVuY3Rpb24gc2V0dXBFdmVudENvbnRleHRUcmFjZShjbGllbnQpIHtcbiAgY2xpZW50Lm9uKCdwcmVwcm9jZXNzRXZlbnQnLCBldmVudCA9PiB7XG4gICAgY29uc3Qgc3BhbiA9IGdldEFjdGl2ZVNwYW4oKTtcbiAgICAvLyBGb3IgdHJhbnNhY3Rpb24gZXZlbnRzLCB0aGlzIGlzIGhhbmRsZWQgc2VwYXJhdGVseVxuICAgIC8vIEJlY2F1c2UgdGhlIGFjdGl2ZSBzcGFuIG1heSBub3QgYmUgdGhlIHNwYW4gdGhhdCBpcyBhY3R1YWxseSB0aGUgdHJhbnNhY3Rpb24gZXZlbnRcbiAgICBpZiAoIXNwYW4gfHwgZXZlbnQudHlwZSA9PT0gJ3RyYW5zYWN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIGV2ZW50IGhhcyBhbHJlYWR5IHNldCBgdHJhY2VgIGNvbnRleHQsIHVzZSB0aGF0IG9uZS5cbiAgICBldmVudC5jb250ZXh0cyA9IHtcbiAgICAgIHRyYWNlOiBjb3JlLnNwYW5Ub1RyYWNlQ29udGV4dChzcGFuKSxcbiAgICAgIC4uLmV2ZW50LmNvbnRleHRzLFxuICAgIH07XG5cbiAgICBjb25zdCByb290U3BhbiA9IGNvcmUuZ2V0Um9vdFNwYW4oc3Bhbik7XG5cbiAgICBldmVudC5zZGtQcm9jZXNzaW5nTWV0YWRhdGEgPSB7XG4gICAgICBkeW5hbWljU2FtcGxpbmdDb250ZXh0OiBjb3JlLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3Bhbihyb290U3BhbiksXG4gICAgICAuLi5ldmVudC5zZGtQcm9jZXNzaW5nTWV0YWRhdGEsXG4gICAgfTtcblxuICAgIHJldHVybiBldmVudDtcbiAgfSk7XG59XG5cbi8qKlxuICogT3RlbC1zcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VHJhY2VEYXRhYC5cbiAqIEBzZWUgYEBzZW50cnkvY29yZWAgdmVyc2lvbiBvZiBgZ2V0VHJhY2VEYXRhYCBmb3IgbW9yZSBpbmZvcm1hdGlvblxuICovXG5mdW5jdGlvbiBnZXRUcmFjZURhdGEoe1xuICBzcGFuLFxuICBzY29wZSxcbiAgY2xpZW50LFxufSA9IHt9KSB7XG4gIGxldCBjdHggPSAoc2NvcGUgJiYgZ2V0Q29udGV4dEZyb21TY29wZShzY29wZSkpID8/IGFwaS5jb250ZXh0LmFjdGl2ZSgpO1xuXG4gIGlmIChzcGFuKSB7XG4gICAgY29uc3QgeyBzY29wZSB9ID0gY29yZS5nZXRDYXB0dXJlZFNjb3Blc09uU3BhbihzcGFuKTtcbiAgICAvLyBmYWxsIGJhY2sgdG8gY3VycmVudCBjb250ZXh0IGlmIGZvciB3aGF0ZXZlciByZWFzb24gd2UgY2FuJ3QgZmluZCB0aGUgb25lIG9mIHRoZSBzcGFuXG4gICAgY3R4ID0gKHNjb3BlICYmIGdldENvbnRleHRGcm9tU2NvcGUoc2NvcGUpKSB8fCBhcGkudHJhY2Uuc2V0U3BhbihhcGkuY29udGV4dC5hY3RpdmUoKSwgc3Bhbik7XG4gIH1cblxuICBjb25zdCB7IHRyYWNlSWQsIHNwYW5JZCwgc2FtcGxlZCwgZHluYW1pY1NhbXBsaW5nQ29udGV4dCB9ID0gZ2V0SW5qZWN0aW9uRGF0YShjdHgsIHsgc2NvcGUsIGNsaWVudCB9KTtcblxuICByZXR1cm4ge1xuICAgICdzZW50cnktdHJhY2UnOiBjb3JlLmdlbmVyYXRlU2VudHJ5VHJhY2VIZWFkZXIodHJhY2VJZCwgc3BhbklkLCBzYW1wbGVkKSxcbiAgICBiYWdnYWdlOiBjb3JlLmR5bmFtaWNTYW1wbGluZ0NvbnRleHRUb1NlbnRyeUJhZ2dhZ2VIZWFkZXIoZHluYW1pY1NhbXBsaW5nQ29udGV4dCksXG4gIH07XG59XG5cbi8qKlxuICogU2V0cyB0aGUgYXN5bmMgY29udGV4dCBzdHJhdGVneSB0byB1c2UgZm9sbG93IHRoZSBPVEVMIGNvbnRleHQgdW5kZXIgdGhlIGhvb2QuXG4gKiBXZSBoYW5kbGUgZm9ya2luZyBhIGh1YiBpbnNpZGUgb2Ygb3VyIGN1c3RvbSBPVEVMIENvbnRleHQgTWFuYWdlciAoLi9vdGVsQ29udGV4dE1hbmFnZXIudHMpXG4gKi9cbmZ1bmN0aW9uIHNldE9wZW5UZWxlbWV0cnlDb250ZXh0QXN5bmNDb250ZXh0U3RyYXRlZ3koKSB7XG4gIGZ1bmN0aW9uIGdldFNjb3BlcygpIHtcbiAgICBjb25zdCBjdHggPSBhcGkuY29udGV4dC5hY3RpdmUoKTtcbiAgICBjb25zdCBzY29wZXMgPSBnZXRTY29wZXNGcm9tQ29udGV4dChjdHgpO1xuXG4gICAgaWYgKHNjb3Blcykge1xuICAgICAgcmV0dXJuIHNjb3BlcztcbiAgICB9XG5cbiAgICAvLyBmYWxsYmFjayBiZWhhdmlvcjpcbiAgICAvLyBpZiwgZm9yIHdoYXRldmVyIHJlYXNvbiwgd2UgY2FuJ3QgZmluZCBzY29wZXMgb24gdGhlIGNvbnRleHQgaGVyZSwgd2UgaGF2ZSB0byBmaXggdGhpcyBzb21laG93XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjb3BlOiBjb3JlLmdldERlZmF1bHRDdXJyZW50U2NvcGUoKSxcbiAgICAgIGlzb2xhdGlvblNjb3BlOiBjb3JlLmdldERlZmF1bHRJc29sYXRpb25TY29wZSgpLFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3aXRoU2NvcGUoY2FsbGJhY2spIHtcbiAgICBjb25zdCBjdHggPSBhcGkuY29udGV4dC5hY3RpdmUoKTtcblxuICAgIC8vIFdlIGRlcGVuZCBvbiB0aGUgb3RlbENvbnRleHRNYW5hZ2VyIHRvIGhhbmRsZSB0aGUgY29udGV4dC9odWJcbiAgICAvLyBXZSBzZXQgdGhlIGBTRU5UUllfRk9SS19JU09MQVRJT05fU0NPUEVfQ09OVEVYVF9LRVlgIGNvbnRleHQgdmFsdWUsIHdoaWNoIGlzIHBpY2tlZCB1cCBieVxuICAgIC8vIHRoZSBPVEVMIGNvbnRleHQgbWFuYWdlciwgd2hpY2ggdXNlcyB0aGUgcHJlc2VuY2Ugb2YgdGhpcyBrZXkgdG8gZGV0ZXJtaW5lIGlmIGl0IHNob3VsZFxuICAgIC8vIGZvcmsgdGhlIGlzb2xhdGlvbiBzY29wZSwgb3Igbm90XG4gICAgLy8gYXMgYnkgZGVmYXVsdCwgd2UgZG9uJ3Qgd2FudCB0byBmb3JrIHRoaXMsIHVubGVzcyB0cmlnZ2VyZWQgZXhwbGljaXRseSBieSBgd2l0aFNjb3BlYFxuICAgIHJldHVybiBhcGkuY29udGV4dC53aXRoKGN0eCwgKCkgPT4ge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGdldEN1cnJlbnRTY29wZSgpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpdGhTZXRTY29wZShzY29wZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBjdHggPSBnZXRDb250ZXh0RnJvbVNjb3BlKHNjb3BlKSB8fCBhcGkuY29udGV4dC5hY3RpdmUoKTtcblxuICAgIC8vIFdlIGRlcGVuZCBvbiB0aGUgb3RlbENvbnRleHRNYW5hZ2VyIHRvIGhhbmRsZSB0aGUgY29udGV4dC9odWJcbiAgICAvLyBXZSBzZXQgdGhlIGBTRU5UUllfRk9SS19TRVRfU0NPUEVfQ09OVEVYVF9LRVlgIGNvbnRleHQgdmFsdWUsIHdoaWNoIGlzIHBpY2tlZCB1cCBieVxuICAgIC8vIHRoZSBPVEVMIGNvbnRleHQgbWFuYWdlciwgd2hpY2ggcGlja3MgdXAgdGhpcyBzY29wZSBhcyB0aGUgY3VycmVudCBzY29wZVxuICAgIHJldHVybiBhcGkuY29udGV4dC53aXRoKGN0eC5zZXRWYWx1ZShTRU5UUllfRk9SS19TRVRfU0NPUEVfQ09OVEVYVF9LRVksIHNjb3BlKSwgKCkgPT4ge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHNjb3BlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpdGhJc29sYXRpb25TY29wZShjYWxsYmFjaykge1xuICAgIGNvbnN0IGN0eCA9IGFwaS5jb250ZXh0LmFjdGl2ZSgpO1xuXG4gICAgLy8gV2UgZGVwZW5kIG9uIHRoZSBvdGVsQ29udGV4dE1hbmFnZXIgdG8gaGFuZGxlIHRoZSBjb250ZXh0L2h1YlxuICAgIC8vIFdlIHNldCB0aGUgYFNFTlRSWV9GT1JLX0lTT0xBVElPTl9TQ09QRV9DT05URVhUX0tFWWAgY29udGV4dCB2YWx1ZSwgd2hpY2ggaXMgcGlja2VkIHVwIGJ5XG4gICAgLy8gdGhlIE9URUwgY29udGV4dCBtYW5hZ2VyLCB3aGljaCB1c2VzIHRoZSBwcmVzZW5jZSBvZiB0aGlzIGtleSB0byBkZXRlcm1pbmUgaWYgaXQgc2hvdWxkXG4gICAgLy8gZm9yayB0aGUgaXNvbGF0aW9uIHNjb3BlLCBvciBub3RcbiAgICByZXR1cm4gYXBpLmNvbnRleHQud2l0aChjdHguc2V0VmFsdWUoU0VOVFJZX0ZPUktfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZLCB0cnVlKSwgKCkgPT4ge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGdldElzb2xhdGlvblNjb3BlKCkpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gd2l0aFNldElzb2xhdGlvblNjb3BlKGlzb2xhdGlvblNjb3BlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGN0eCA9IGFwaS5jb250ZXh0LmFjdGl2ZSgpO1xuXG4gICAgLy8gV2UgZGVwZW5kIG9uIHRoZSBvdGVsQ29udGV4dE1hbmFnZXIgdG8gaGFuZGxlIHRoZSBjb250ZXh0L2h1YlxuICAgIC8vIFdlIHNldCB0aGUgYFNFTlRSWV9GT1JLX0lTT0xBVElPTl9TQ09QRV9DT05URVhUX0tFWWAgY29udGV4dCB2YWx1ZSwgd2hpY2ggaXMgcGlja2VkIHVwIGJ5XG4gICAgLy8gdGhlIE9URUwgY29udGV4dCBtYW5hZ2VyLCB3aGljaCB1c2VzIHRoZSBwcmVzZW5jZSBvZiB0aGlzIGtleSB0byBkZXRlcm1pbmUgaWYgaXQgc2hvdWxkXG4gICAgLy8gZm9yayB0aGUgaXNvbGF0aW9uIHNjb3BlLCBvciBub3RcbiAgICByZXR1cm4gYXBpLmNvbnRleHQud2l0aChjdHguc2V0VmFsdWUoU0VOVFJZX0ZPUktfU0VUX0lTT0xBVElPTl9TQ09QRV9DT05URVhUX0tFWSwgaXNvbGF0aW9uU2NvcGUpLCAoKSA9PiB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZ2V0SXNvbGF0aW9uU2NvcGUoKSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDdXJyZW50U2NvcGUoKSB7XG4gICAgcmV0dXJuIGdldFNjb3BlcygpLnNjb3BlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SXNvbGF0aW9uU2NvcGUoKSB7XG4gICAgcmV0dXJuIGdldFNjb3BlcygpLmlzb2xhdGlvblNjb3BlO1xuICB9XG5cbiAgY29yZS5zZXRBc3luY0NvbnRleHRTdHJhdGVneSh7XG4gICAgd2l0aFNjb3BlLFxuICAgIHdpdGhTZXRTY29wZSxcbiAgICB3aXRoU2V0SXNvbGF0aW9uU2NvcGUsXG4gICAgd2l0aElzb2xhdGlvblNjb3BlLFxuICAgIGdldEN1cnJlbnRTY29wZSxcbiAgICBnZXRJc29sYXRpb25TY29wZSxcbiAgICBzdGFydFNwYW4sXG4gICAgc3RhcnRTcGFuTWFudWFsLFxuICAgIHN0YXJ0SW5hY3RpdmVTcGFuLFxuICAgIGdldEFjdGl2ZVNwYW4sXG4gICAgc3VwcHJlc3NUcmFjaW5nLFxuICAgIGdldFRyYWNlRGF0YSxcbiAgICBjb250aW51ZVRyYWNlLFxuICAgIC8vIFRoZSB0eXBlcyBoZXJlIGRvbid0IGZ1bGx5IGFsaWduLCBiZWNhdXNlIG91ciBvd24gYFNwYW5gIHR5cGUgaXMgbmFycm93ZXJcbiAgICAvLyB0aGFuIHRoZSBPVEVMIG9uZSAtIGJ1dCB0aGlzIGlzIE9LIGZvciBoZXJlLCBhcyB3ZSBub3cgd2UnbGwgb25seSBoYXZlIE9URUwgc3BhbnMgcGFzc2VkIGFyb3VuZFxuICAgIHdpdGhBY3RpdmVTcGFuOiB3aXRoQWN0aXZlU3BhbiAsXG4gIH0pO1xufVxuXG4vKipcbiAqIFdyYXAgYW4gT3BlblRlbGVtZXRyeSBDb250ZXh0TWFuYWdlciBpbiBhIHdheSB0aGF0IGVuc3VyZXMgdGhlIGNvbnRleHQgaXMga2VwdCBpbiBzeW5jIHdpdGggdGhlIFNlbnRyeSBTY29wZS5cbiAqXG4gKiBVc2FnZTpcbiAqIGltcG9ydCB7IEFzeW5jTG9jYWxTdG9yYWdlQ29udGV4dE1hbmFnZXIgfSBmcm9tICdAb3BlbnRlbGVtZXRyeS9jb250ZXh0LWFzeW5jLWhvb2tzJztcbiAqIGNvbnN0IFNlbnRyeUNvbnRleHRNYW5hZ2VyID0gd3JhcENvbnRleHRNYW5hZ2VyQ2xhc3MoQXN5bmNMb2NhbFN0b3JhZ2VDb250ZXh0TWFuYWdlcik7XG4gKiBjb25zdCBjb250ZXh0TWFuYWdlciA9IG5ldyBTZW50cnlDb250ZXh0TWFuYWdlcigpO1xuICovXG5mdW5jdGlvbiB3cmFwQ29udGV4dE1hbmFnZXJDbGFzcyhcbiAgQ29udGV4dE1hbmFnZXJDbGFzcyxcbikge1xuICAvKipcbiAgICogVGhpcyBpcyBhIGN1c3RvbSBDb250ZXh0TWFuYWdlciBmb3IgT3BlblRlbGVtZXRyeSwgd2hpY2ggZXh0ZW5kcyB0aGUgZGVmYXVsdCBBc3luY0xvY2FsU3RvcmFnZUNvbnRleHRNYW5hZ2VyLlxuICAgKiBJdCBlbnN1cmVzIHRoYXQgd2UgY3JlYXRlIG5ldyBzY29wZXMgcGVyIGNvbnRleHQsIHNvIHRoYXQgdGhlIE9URUwgQ29udGV4dCAmIHRoZSBTZW50cnkgU2NvcGUgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgd2UgY3VycmVudGx5IG9ubHkgc3VwcG9ydCBBc3luY0hvb2tzIHdpdGggdGhpcyxcbiAgICogYnV0IHNpbmNlIHRoaXMgc2hvdWxkIHdvcmsgZm9yIE5vZGUgMTQrIGFueWhvdyB0aGF0IHNob3VsZCBiZSBnb29kIGVub3VnaC5cbiAgICovXG5cbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBUUyBkb2VzIG5vdCBsaWtlIHRoaXMsIGJ1dCB3ZSBrbm93IHRoaXMgaXMgZmluZVxuICBjbGFzcyBTZW50cnlDb250ZXh0TWFuYWdlciBleHRlbmRzIENvbnRleHRNYW5hZ2VyQ2xhc3Mge1xuICAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgIHNldElzU2V0dXAoJ1NlbnRyeUNvbnRleHRNYW5hZ2VyJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJ3cml0ZSB3aXRoKCkgb2YgdGhlIG9yaWdpbmFsIEFzeW5jTG9jYWxTdG9yYWdlQ29udGV4dE1hbmFnZXJcbiAgICAgKiB0byBlbnN1cmUgd2UgYWxzbyBjcmVhdGUgbmV3IHNjb3BlcyBwZXIgY29udGV4dC5cbiAgICAgKi9cbiAgICAgd2l0aChcbiAgICAgIGNvbnRleHQsXG4gICAgICBmbixcbiAgICAgIHRoaXNBcmcsXG4gICAgICAuLi5hcmdzXG4gICAgKSB7XG4gICAgICBjb25zdCBjdXJyZW50U2NvcGVzID0gZ2V0U2NvcGVzRnJvbUNvbnRleHQoY29udGV4dCk7XG4gICAgICBjb25zdCBjdXJyZW50U2NvcGUgPSBjdXJyZW50U2NvcGVzPy5zY29wZSB8fCBjb3JlLmdldEN1cnJlbnRTY29wZSgpO1xuICAgICAgY29uc3QgY3VycmVudElzb2xhdGlvblNjb3BlID0gY3VycmVudFNjb3Blcz8uaXNvbGF0aW9uU2NvcGUgfHwgY29yZS5nZXRJc29sYXRpb25TY29wZSgpO1xuXG4gICAgICBjb25zdCBzaG91bGRGb3JrSXNvbGF0aW9uU2NvcGUgPSBjb250ZXh0LmdldFZhbHVlKFNFTlRSWV9GT1JLX0lTT0xBVElPTl9TQ09QRV9DT05URVhUX0tFWSkgPT09IHRydWU7XG4gICAgICBjb25zdCBzY29wZSA9IGNvbnRleHQuZ2V0VmFsdWUoU0VOVFJZX0ZPUktfU0VUX1NDT1BFX0NPTlRFWFRfS0VZKSA7XG4gICAgICBjb25zdCBpc29sYXRpb25TY29wZSA9IGNvbnRleHQuZ2V0VmFsdWUoU0VOVFJZX0ZPUktfU0VUX0lTT0xBVElPTl9TQ09QRV9DT05URVhUX0tFWSkgO1xuXG4gICAgICBjb25zdCBuZXdDdXJyZW50U2NvcGUgPSBzY29wZSB8fCBjdXJyZW50U2NvcGUuY2xvbmUoKTtcbiAgICAgIGNvbnN0IG5ld0lzb2xhdGlvblNjb3BlID1cbiAgICAgICAgaXNvbGF0aW9uU2NvcGUgfHwgKHNob3VsZEZvcmtJc29sYXRpb25TY29wZSA/IGN1cnJlbnRJc29sYXRpb25TY29wZS5jbG9uZSgpIDogY3VycmVudElzb2xhdGlvblNjb3BlKTtcbiAgICAgIGNvbnN0IHNjb3BlcyA9IHsgc2NvcGU6IG5ld0N1cnJlbnRTY29wZSwgaXNvbGF0aW9uU2NvcGU6IG5ld0lzb2xhdGlvblNjb3BlIH07XG5cbiAgICAgIGNvbnN0IGN0eDEgPSBzZXRTY29wZXNPbkNvbnRleHQoY29udGV4dCwgc2NvcGVzKTtcblxuICAgICAgLy8gUmVtb3ZlIHRoZSB1bm5lZWRlZCB2YWx1ZXMgYWdhaW5cbiAgICAgIGNvbnN0IGN0eDIgPSBjdHgxXG4gICAgICAgIC5kZWxldGVWYWx1ZShTRU5UUllfRk9SS19JU09MQVRJT05fU0NPUEVfQ09OVEVYVF9LRVkpXG4gICAgICAgIC5kZWxldGVWYWx1ZShTRU5UUllfRk9SS19TRVRfU0NPUEVfQ09OVEVYVF9LRVkpXG4gICAgICAgIC5kZWxldGVWYWx1ZShTRU5UUllfRk9SS19TRVRfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZKTtcblxuICAgICAgc2V0Q29udGV4dE9uU2NvcGUobmV3Q3VycmVudFNjb3BlLCBjdHgyKTtcblxuICAgICAgcmV0dXJuIHN1cGVyLndpdGgoY3R4MiwgZm4sIHRoaXNBcmcsIC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBTZW50cnlDb250ZXh0TWFuYWdlciA7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBydW5zIHRocm91Z2ggYSBsaXN0IG9mIE9URUwgU3BhbnMsIGFuZCB3cmFwcyB0aGVtIGluIGFuIGBTcGFuTm9kZWBcbiAqIHdoZXJlIGVhY2ggbm9kZSBob2xkcyBhIHJlZmVyZW5jZSB0byB0aGVpciBwYXJlbnQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ3JvdXBTcGFuc1dpdGhQYXJlbnRzKHNwYW5zKSB7XG4gIGNvbnN0IG5vZGVNYXAgPSBuZXcgTWFwKCk7XG5cbiAgZm9yIChjb25zdCBzcGFuIG9mIHNwYW5zKSB7XG4gICAgY3JlYXRlT3JVcGRhdGVTcGFuTm9kZUFuZFJlZnMobm9kZU1hcCwgc3Bhbik7XG4gIH1cblxuICByZXR1cm4gQXJyYXkuZnJvbShub2RlTWFwLCBmdW5jdGlvbiAoW19pZCwgc3Bhbk5vZGVdKSB7XG4gICAgcmV0dXJuIHNwYW5Ob2RlO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaGlzIHJldHVybnMgdGhlIF9sb2NhbF8gcGFyZW50IElEIC0gYHBhcmVudElkYCBvbiB0aGUgc3BhbiBtYXkgcG9pbnQgdG8gYSByZW1vdGUgc3Bhbi5cbiAqL1xuZnVuY3Rpb24gZ2V0TG9jYWxQYXJlbnRJZChzcGFuKSB7XG4gIGNvbnN0IHBhcmVudElzUmVtb3RlID0gc3Bhbi5hdHRyaWJ1dGVzW1NFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfUEFSRU5UX0lTX1JFTU9URV0gPT09IHRydWU7XG4gIC8vIElmIHRoZSBwYXJlbnRJZCBpcyB0aGUgdHJhY2UgcGFyZW50IElELCB3ZSBwcmV0ZW5kIGl0J3MgdW5kZWZpbmVkXG4gIC8vIEFzIHRoaXMgbWVhbnMgdGhlIHBhcmVudCBleGlzdHMgc29tZXdoZXJlIGVsc2VcbiAgcmV0dXJuICFwYXJlbnRJc1JlbW90ZSA/IGdldFBhcmVudFNwYW5JZChzcGFuKSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVTcGFuTm9kZUFuZFJlZnMobm9kZU1hcCwgc3Bhbikge1xuICBjb25zdCBpZCA9IHNwYW4uc3BhbkNvbnRleHQoKS5zcGFuSWQ7XG4gIGNvbnN0IHBhcmVudElkID0gZ2V0TG9jYWxQYXJlbnRJZChzcGFuKTtcblxuICBpZiAoIXBhcmVudElkKSB7XG4gICAgY3JlYXRlT3JVcGRhdGVOb2RlKG5vZGVNYXAsIHsgaWQsIHNwYW4sIGNoaWxkcmVuOiBbXSB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBFbHNlIG1ha2Ugc3VyZSB0byBjcmVhdGUgcGFyZW50IG5vZGUgYXMgd2VsbFxuICAvLyBOb3RlIHRoYXQgdGhlIHBhcmVudCBtYXkgbm90IGtub3cgaXQncyBwYXJlbnQgX3lldF8sIHRoaXMgbWF5IGJlIHVwZGF0ZWQgaW4gYSBsYXRlciBwYXNzXG4gIGNvbnN0IHBhcmVudE5vZGUgPSBjcmVhdGVPckdldFBhcmVudE5vZGUobm9kZU1hcCwgcGFyZW50SWQpO1xuICBjb25zdCBub2RlID0gY3JlYXRlT3JVcGRhdGVOb2RlKG5vZGVNYXAsIHsgaWQsIHNwYW4sIHBhcmVudE5vZGUsIGNoaWxkcmVuOiBbXSB9KTtcbiAgcGFyZW50Tm9kZS5jaGlsZHJlbi5wdXNoKG5vZGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPckdldFBhcmVudE5vZGUobm9kZU1hcCwgaWQpIHtcbiAgY29uc3QgZXhpc3RpbmcgPSBub2RlTWFwLmdldChpZCk7XG5cbiAgaWYgKGV4aXN0aW5nKSB7XG4gICAgcmV0dXJuIGV4aXN0aW5nO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlTm9kZShub2RlTWFwLCB7IGlkLCBjaGlsZHJlbjogW10gfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlTm9kZShub2RlTWFwLCBzcGFuTm9kZSkge1xuICBjb25zdCBleGlzdGluZyA9IG5vZGVNYXAuZ2V0KHNwYW5Ob2RlLmlkKTtcblxuICAvLyBJZiBzcGFuIGlzIGFscmVhZHkgc2V0LCBub3RoaW5nIHRvIGRvIGhlcmVcbiAgaWYgKGV4aXN0aW5nPy5zcGFuKSB7XG4gICAgcmV0dXJuIGV4aXN0aW5nO1xuICB9XG5cbiAgLy8gSWYgaXQgZXhpc3RzIGJ1dCBzcGFuIGlzIG5vdCBzZXQgeWV0LCB3ZSB1cGRhdGUgaXRcbiAgaWYgKGV4aXN0aW5nICYmICFleGlzdGluZy5zcGFuKSB7XG4gICAgZXhpc3Rpbmcuc3BhbiA9IHNwYW5Ob2RlLnNwYW47XG4gICAgZXhpc3RpbmcucGFyZW50Tm9kZSA9IHNwYW5Ob2RlLnBhcmVudE5vZGU7XG4gICAgcmV0dXJuIGV4aXN0aW5nO1xuICB9XG5cbiAgLy8gRWxzZSwgd2UgY3JlYXRlIGEgbmV3IG9uZS4uLlxuICBub2RlTWFwLnNldChzcGFuTm9kZS5pZCwgc3Bhbk5vZGUpO1xuICByZXR1cm4gc3Bhbk5vZGU7XG59XG5cbi8vIGNhbm9uaWNhbENvZGVzR3JwY01hcCBtYXBzIHNvbWUgR1JQQyBjb2RlcyB0byBTZW50cnkncyBzcGFuIHN0YXR1c2VzLiBTZWUgZGVzY3JpcHRpb24gaW4gZ3JwYyBkb2N1bWVudGF0aW9uLlxuY29uc3QgY2Fub25pY2FsR3JwY0Vycm9yQ29kZXNNYXAgPSB7XG4gICcxJzogJ2NhbmNlbGxlZCcsXG4gICcyJzogJ3Vua25vd25fZXJyb3InLFxuICAnMyc6ICdpbnZhbGlkX2FyZ3VtZW50JyxcbiAgJzQnOiAnZGVhZGxpbmVfZXhjZWVkZWQnLFxuICAnNSc6ICdub3RfZm91bmQnLFxuICAnNic6ICdhbHJlYWR5X2V4aXN0cycsXG4gICc3JzogJ3Blcm1pc3Npb25fZGVuaWVkJyxcbiAgJzgnOiAncmVzb3VyY2VfZXhoYXVzdGVkJyxcbiAgJzknOiAnZmFpbGVkX3ByZWNvbmRpdGlvbicsXG4gICcxMCc6ICdhYm9ydGVkJyxcbiAgJzExJzogJ291dF9vZl9yYW5nZScsXG4gICcxMic6ICd1bmltcGxlbWVudGVkJyxcbiAgJzEzJzogJ2ludGVybmFsX2Vycm9yJyxcbiAgJzE0JzogJ3VuYXZhaWxhYmxlJyxcbiAgJzE1JzogJ2RhdGFfbG9zcycsXG4gICcxNic6ICd1bmF1dGhlbnRpY2F0ZWQnLFxufSA7XG5cbmNvbnN0IGlzU3RhdHVzRXJyb3JNZXNzYWdlVmFsaWQgPSAobWVzc2FnZSkgPT4ge1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhjYW5vbmljYWxHcnBjRXJyb3JDb2Rlc01hcCkuaW5jbHVkZXMobWVzc2FnZSApO1xufTtcblxuLyoqXG4gKiBHZXQgYSBTZW50cnkgc3BhbiBzdGF0dXMgZnJvbSBhbiBvdGVsIHNwYW4uXG4gKi9cbmZ1bmN0aW9uIG1hcFN0YXR1cyhzcGFuKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBzcGFuSGFzQXR0cmlidXRlcyhzcGFuKSA/IHNwYW4uYXR0cmlidXRlcyA6IHt9O1xuICBjb25zdCBzdGF0dXMgPSBzcGFuSGFzU3RhdHVzKHNwYW4pID8gc3Bhbi5zdGF0dXMgOiB1bmRlZmluZWQ7XG5cbiAgaWYgKHN0YXR1cykge1xuICAgIC8vIFNpbmNlIHNwYW4gc3RhdHVzIE9LIGlzIG5vdCBzZXQgYnkgZGVmYXVsdCwgd2UgZ2l2ZSBpdCBwcmlvcml0eTogaHR0cHM6Ly9vcGVudGVsZW1ldHJ5LmlvL2RvY3MvY29uY2VwdHMvc2lnbmFscy90cmFjZXMvI3NwYW4tc3RhdHVzXG4gICAgaWYgKHN0YXR1cy5jb2RlID09PSBhcGkuU3BhblN0YXR1c0NvZGUuT0spIHtcbiAgICAgIHJldHVybiB7IGNvZGU6IGNvcmUuU1BBTl9TVEFUVVNfT0sgfTtcbiAgICAgIC8vIElmIHRoZSBzcGFuIGlzIGFscmVhZHkgbWFya2VkIGFzIGVycm9uZW91cyB3ZSByZXR1cm4gdGhhdCBleGFjdCBzdGF0dXNcbiAgICB9IGVsc2UgaWYgKHN0YXR1cy5jb2RlID09PSBhcGkuU3BhblN0YXR1c0NvZGUuRVJST1IpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3RhdHVzLm1lc3NhZ2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IGluZmVycmVkU3RhdHVzID0gaW5mZXJTdGF0dXNGcm9tQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcbiAgICAgICAgaWYgKGluZmVycmVkU3RhdHVzKSB7XG4gICAgICAgICAgcmV0dXJuIGluZmVycmVkU3RhdHVzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0dXMubWVzc2FnZSAmJiBpc1N0YXR1c0Vycm9yTWVzc2FnZVZhbGlkKHN0YXR1cy5tZXNzYWdlKSkge1xuICAgICAgICByZXR1cm4geyBjb2RlOiBjb3JlLlNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiBzdGF0dXMubWVzc2FnZSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgY29kZTogY29yZS5TUEFOX1NUQVRVU19FUlJPUiwgbWVzc2FnZTogJ3Vua25vd25fZXJyb3InIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgdGhlIHNwYW4gc3RhdHVzIGlzIFVOU0VULCB3ZSB0cnkgdG8gaW5mZXIgaXQgZnJvbSBIVFRQIG9yIEdSUEMgc3RhdHVzIGNvZGVzLlxuICBjb25zdCBpbmZlcnJlZFN0YXR1cyA9IGluZmVyU3RhdHVzRnJvbUF0dHJpYnV0ZXMoYXR0cmlidXRlcyk7XG5cbiAgaWYgKGluZmVycmVkU3RhdHVzKSB7XG4gICAgcmV0dXJuIGluZmVycmVkU3RhdHVzO1xuICB9XG5cbiAgLy8gV2UgZGVmYXVsdCB0byBzZXR0aW5nIHRoZSBzcGFucyBzdGF0dXMgdG8gb2suXG4gIGlmIChzdGF0dXM/LmNvZGUgPT09IGFwaS5TcGFuU3RhdHVzQ29kZS5VTlNFVCkge1xuICAgIHJldHVybiB7IGNvZGU6IGNvcmUuU1BBTl9TVEFUVVNfT0sgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyBjb2RlOiBjb3JlLlNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAndW5rbm93bl9lcnJvcicgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmZlclN0YXR1c0Zyb21BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpIHtcbiAgLy8gSWYgdGhlIHNwYW4gc3RhdHVzIGlzIFVOU0VULCB3ZSB0cnkgdG8gaW5mZXIgaXQgZnJvbSBIVFRQIG9yIEdSUEMgc3RhdHVzIGNvZGVzLlxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBjb25zdCBodHRwQ29kZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5BVFRSX0hUVFBfUkVTUE9OU0VfU1RBVFVTX0NPREVdIHx8IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19IVFRQX1NUQVRVU19DT0RFXTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIGNvbnN0IGdycGNDb2RlQXR0cmlidXRlID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX1JQQ19HUlBDX1NUQVRVU19DT0RFXTtcblxuICBjb25zdCBudW1iZXJIdHRwQ29kZSA9XG4gICAgdHlwZW9mIGh0dHBDb2RlQXR0cmlidXRlID09PSAnbnVtYmVyJ1xuICAgICAgPyBodHRwQ29kZUF0dHJpYnV0ZVxuICAgICAgOiB0eXBlb2YgaHR0cENvZGVBdHRyaWJ1dGUgPT09ICdzdHJpbmcnXG4gICAgICAgID8gcGFyc2VJbnQoaHR0cENvZGVBdHRyaWJ1dGUpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gIGlmICh0eXBlb2YgbnVtYmVySHR0cENvZGUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGNvcmUuZ2V0U3BhblN0YXR1c0Zyb21IdHRwQ29kZShudW1iZXJIdHRwQ29kZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIGdycGNDb2RlQXR0cmlidXRlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB7IGNvZGU6IGNvcmUuU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6IGNhbm9uaWNhbEdycGNFcnJvckNvZGVzTWFwW2dycGNDb2RlQXR0cmlidXRlXSB8fCAndW5rbm93bl9lcnJvcicgfTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmNvbnN0IE1BWF9TUEFOX0NPVU5UID0gMTAwMDtcbmNvbnN0IERFRkFVTFRfVElNRU9VVCA9IDMwMDsgLy8gNSBtaW5cblxuLyoqXG4gKiBBIFNlbnRyeS1zcGVjaWZpYyBleHBvcnRlciB0aGF0IGNvbnZlcnRzIE9wZW5UZWxlbWV0cnkgU3BhbnMgdG8gU2VudHJ5IFNwYW5zICYgVHJhbnNhY3Rpb25zLlxuICovXG5jbGFzcyBTZW50cnlTcGFuRXhwb3J0ZXIge1xuICAvKlxuICAgKiBBIHF1aWNrIGV4cGxhbmF0aW9uIG9uIHRoZSBidWNrZXRzOiBXZSBkbyBidWNrZXRpbmcgb2YgZmluaXNoZWQgc3BhbnMgZm9yIGVmZmljaWVuY3kuIFRoaXMgc3BhbiBleHBvcnRlciBpc1xuICAgKiBhY2N1bXVsYXRpbmcgc3BhbnMgdW50aWwgYSByb290IHNwYW4gaXMgZW5jb3VudGVyZWQgYW5kIHRoZW4gaXQgZmx1c2hlcyBhbGwgdGhlIHNwYW5zIHRoYXQgYXJlIGRlc2NlbmRhbnRzIG9mIHRoYXRcbiAgICogcm9vdCBzcGFuLiBCZWNhdXNlIGl0IGlzIHRvdGFsbHkgaW4gdGhlIHJlYWxtIG9mIHBvc3NpYmlsaXRpZXMgdGhhdCByb290IHNwYW5zIGFyZSBuZXZlciBmaW5pc2hlZCwgYW5kIHdlIGRvbid0XG4gICAqIHdhbnQgdG8gYWNjdW11bGF0ZSBzcGFucyBpbmRlZmluaXRlbHkgaW4gbWVtb3J5LCB3ZSBuZWVkIHRvIHBlcmlvZGljYWxseSBldmFjdWF0ZSBzcGFucy4gTmFpdmVseSB3ZSBjb3VsZCBzaW1wbHlcbiAgICogc3RvcmUgdGhlIHNwYW5zIGluIGFuIGFycmF5IGFuZCBlYWNoIHRpbWUgYSBuZXcgc3BhbiBjb21lcyBpbiB3ZSBjb3VsZCBpdGVyYXRlIHRocm91Z2ggdGhlIGVudGlyZSBhcnJheSBhbmRcbiAgICogZXZhY3VhdGUgYWxsIHNwYW5zIHRoYXQgaGF2ZSBhbiBlbmQtdGltZXN0YW1wIHRoYXQgaXMgb2xkZXIgdGhhbiBvdXIgbGltaXQuIFRoaXMgY291bGQgZ2V0IHF1aXRlIGV4cGVuc2l2ZSBiZWNhdXNlXG4gICAqIHdlIHdvdWxkIGhhdmUgdG8gaXRlcmF0ZSBhIHBvdGVudGlhbGx5IGxhcmdlIG51bWJlciBvZiBzcGFucyBldmVyeSB0aW1lIHdlIGV2YWN1YXRlLiBXZSB3YW50IHRvIGF2b2lkIHRoZXNlIGxhcmdlXG4gICAqIGJ1cnN0cyBvZiBjb21wdXRhdGlvbi5cbiAgICpcbiAgICogSW5zdGVhZCB3ZSBnbyBmb3IgYSBidWNrZXRpbmcgYXBwcm9hY2ggYW5kIHB1dCBzcGFucyBpbnRvIGJ1Y2tldHMsIGJhc2VkIG9uIHdoYXQgc2Vjb25kXG4gICAqIChtb2R1bG8gdGhlIHRpbWUgbGltaXQpIHRoZSBzcGFuIHdhcyBwdXQgaW50byB0aGUgZXhwb3J0ZXIuIFdpdGggYnVja2V0cywgd2hlbiB3ZSBkZWNpZGUgdG8gZXZhY3VhdGUsIHdlIGNhblxuICAgKiBpdGVyYXRlIHRocm91Z2ggdGhlIGJ1Y2tldCBlbnRyaWVzIGluc3RlYWQsIHdoaWNoIGhhdmUgYW4gdXBwZXIgYm91bmQgb2YgaXRlbXMsIG1ha2luZyB0aGUgZXZhY3VhdGlvbiBtdWNoIG1vcmVcbiAgICogZWZmaWNpZW50LiBDbGVhbmluZyB1cCBhbHNvIGJlY29tZXMgbXVjaCBtb3JlIGVmZmljaWVudCBzaW5jZSBpdCBzaW1wbHkgaW52b2x2ZXMgZGUtcmVmZXJlbmNpbmcgYSBidWNrZXQgd2l0aGluIHRoZVxuICAgKiBidWNrZXQgYXJyYXksIGFuZCBsZXR0aW5nIGdhcmJhZ2UgY29sbGVjdGlvbiB0YWtlIGNhcmUgb2YgdGhlIHJlc3QuXG4gICAqL1xuXG4gIC8vIEVzc2VudGlhbGx5IGEgYSBzZXQgb2Ygc3BhbiBpZHMgdGhhdCBhcmUgYWxyZWFkeSBzZW50LiBUaGUgdmFsdWVzIGFyZSBleHBpcmF0aW9uXG4gIC8vIHRpbWVzIGluIHRoaXMgY2FjaGUgc28gd2UgZG9uJ3QgaG9sZCBvbnRvIHRoZW0gaW5kZWZpbml0ZWx5LlxuXG4gIC8qIEludGVybmFsbHksIHdlIHVzZSBhIGRlYm91bmNlZCBmbHVzaCB0byBnaXZlIHNvbWUgd2lnZ2xlIHJvb20gdG8gdGhlIHNwYW4gcHJvY2Vzc29yIHRvIGFjY3VtdWxhdGUgbW9yZSBzcGFucy4gKi9cblxuICAgY29uc3RydWN0b3Iob3B0aW9uc1xuXG4pIHtcbiAgICB0aGlzLl9maW5pc2hlZFNwYW5CdWNrZXRTaXplID0gb3B0aW9ucz8udGltZW91dCB8fCBERUZBVUxUX1RJTUVPVVQ7XG4gICAgdGhpcy5fZmluaXNoZWRTcGFuQnVja2V0cyA9IG5ldyBBcnJheSh0aGlzLl9maW5pc2hlZFNwYW5CdWNrZXRTaXplKS5maWxsKHVuZGVmaW5lZCk7XG4gICAgdGhpcy5fbGFzdENsZWFudXBUaW1lc3RhbXBJblMgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICB0aGlzLl9zcGFuc1RvQnVja2V0RW50cnkgPSBuZXcgV2Vha01hcCgpO1xuICAgIHRoaXMuX3NlbnRTcGFucyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9kZWJvdW5jZWRGbHVzaCA9IGNvcmUuZGVib3VuY2UodGhpcy5mbHVzaC5iaW5kKHRoaXMpLCAxLCB7IG1heFdhaXQ6IDEwMCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvcnQgYSBzaW5nbGUgc3Bhbi5cbiAgICogVGhpcyBpcyBjYWxsZWQgYnkgdGhlIHNwYW4gcHJvY2Vzc29yIHdoZW5ldmVyIGEgc3BhbiBpcyBlbmRlZC5cbiAgICovXG4gICBleHBvcnQoc3Bhbikge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lc3RhbXBJblMgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcblxuICAgIGlmICh0aGlzLl9sYXN0Q2xlYW51cFRpbWVzdGFtcEluUyAhPT0gY3VycmVudFRpbWVzdGFtcEluUykge1xuICAgICAgbGV0IGRyb3BwZWRTcGFuQ291bnQgPSAwO1xuICAgICAgdGhpcy5fZmluaXNoZWRTcGFuQnVja2V0cy5mb3JFYWNoKChidWNrZXQsIGkpID0+IHtcbiAgICAgICAgaWYgKGJ1Y2tldCAmJiBidWNrZXQudGltZXN0YW1wSW5TIDw9IGN1cnJlbnRUaW1lc3RhbXBJblMgLSB0aGlzLl9maW5pc2hlZFNwYW5CdWNrZXRTaXplKSB7XG4gICAgICAgICAgZHJvcHBlZFNwYW5Db3VudCArPSBidWNrZXQuc3BhbnMuc2l6ZTtcbiAgICAgICAgICB0aGlzLl9maW5pc2hlZFNwYW5CdWNrZXRzW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChkcm9wcGVkU3BhbkNvdW50ID4gMCkge1xuICAgICAgICBERUJVR19CVUlMRCAmJlxuICAgICAgICAgIGNvcmUuZGVidWcubG9nKFxuICAgICAgICAgICAgYFNwYW5FeHBvcnRlciBkcm9wcGVkICR7ZHJvcHBlZFNwYW5Db3VudH0gc3BhbnMgYmVjYXVzZSB0aGV5IHdlcmUgcGVuZGluZyBmb3IgbW9yZSB0aGFuICR7dGhpcy5fZmluaXNoZWRTcGFuQnVja2V0U2l6ZX0gc2Vjb25kcy5gLFxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLl9sYXN0Q2xlYW51cFRpbWVzdGFtcEluUyA9IGN1cnJlbnRUaW1lc3RhbXBJblM7XG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudEJ1Y2tldEluZGV4ID0gY3VycmVudFRpbWVzdGFtcEluUyAlIHRoaXMuX2ZpbmlzaGVkU3BhbkJ1Y2tldFNpemU7XG4gICAgY29uc3QgY3VycmVudEJ1Y2tldCA9IHRoaXMuX2ZpbmlzaGVkU3BhbkJ1Y2tldHNbY3VycmVudEJ1Y2tldEluZGV4XSB8fCB7XG4gICAgICB0aW1lc3RhbXBJblM6IGN1cnJlbnRUaW1lc3RhbXBJblMsXG4gICAgICBzcGFuczogbmV3IFNldCgpLFxuICAgIH07XG4gICAgdGhpcy5fZmluaXNoZWRTcGFuQnVja2V0c1tjdXJyZW50QnVja2V0SW5kZXhdID0gY3VycmVudEJ1Y2tldDtcbiAgICBjdXJyZW50QnVja2V0LnNwYW5zLmFkZChzcGFuKTtcbiAgICB0aGlzLl9zcGFuc1RvQnVja2V0RW50cnkuc2V0KHNwYW4sIGN1cnJlbnRCdWNrZXQpO1xuXG4gICAgLy8gSWYgdGhlIHNwYW4gZG9lc24ndCBoYXZlIGEgbG9jYWwgcGFyZW50IElEIChpdCdzIGEgcm9vdCBzcGFuKSwgd2UncmUgZ29ubmEgZmx1c2ggYWxsIHRoZSBlbmRlZCBzcGFuc1xuICAgIGNvbnN0IGxvY2FsUGFyZW50SWQgPSBnZXRMb2NhbFBhcmVudElkKHNwYW4pO1xuICAgIGlmICghbG9jYWxQYXJlbnRJZCB8fCB0aGlzLl9zZW50U3BhbnMuaGFzKGxvY2FsUGFyZW50SWQpKSB7XG4gICAgICB0aGlzLl9kZWJvdW5jZWRGbHVzaCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcnkgdG8gZmx1c2ggYW55IHBlbmRpbmcgc3BhbnMgaW1tZWRpYXRlbHkuXG4gICAqIFRoaXMgaXMgY2FsbGVkIGludGVybmFsbHkgYnkgdGhlIGV4cG9ydGVyICh2aWEgX2RlYm91bmNlZEZsdXNoKSxcbiAgICogYnV0IGNhbiBhbHNvIGJlIHRyaWdnZXJlZCBleHRlcm5hbGx5IGlmIHdlIGZvcmNlLWZsdXNoLlxuICAgKi9cbiAgIGZsdXNoKCkge1xuICAgIGNvbnN0IGZpbmlzaGVkU3BhbnMgPSB0aGlzLl9maW5pc2hlZFNwYW5CdWNrZXRzLmZsYXRNYXAoYnVja2V0ID0+IChidWNrZXQgPyBBcnJheS5mcm9tKGJ1Y2tldC5zcGFucykgOiBbXSkpO1xuXG4gICAgdGhpcy5fZmx1c2hTZW50U3BhbkNhY2hlKCk7XG4gICAgY29uc3Qgc2VudFNwYW5zID0gdGhpcy5fbWF5YmVTZW5kKGZpbmlzaGVkU3BhbnMpO1xuXG4gICAgY29uc3Qgc2VudFNwYW5Db3VudCA9IHNlbnRTcGFucy5zaXplO1xuICAgIGNvbnN0IHJlbWFpbmluZ09wZW5TcGFuQ291bnQgPSBmaW5pc2hlZFNwYW5zLmxlbmd0aCAtIHNlbnRTcGFuQ291bnQ7XG4gICAgREVCVUdfQlVJTEQgJiZcbiAgICAgIGNvcmUuZGVidWcubG9nKFxuICAgICAgICBgU3BhbkV4cG9ydGVyIGV4cG9ydGVkICR7c2VudFNwYW5Db3VudH0gc3BhbnMsICR7cmVtYWluaW5nT3BlblNwYW5Db3VudH0gc3BhbnMgYXJlIHdhaXRpbmcgZm9yIHRoZWlyIHBhcmVudCBzcGFucyB0byBmaW5pc2hgLFxuICAgICAgKTtcblxuICAgIGNvbnN0IGV4cGlyYXRpb25EYXRlID0gRGF0ZS5ub3coKSArIERFRkFVTFRfVElNRU9VVCAqIDEwMDA7XG5cbiAgICBmb3IgKGNvbnN0IHNwYW4gb2Ygc2VudFNwYW5zKSB7XG4gICAgICB0aGlzLl9zZW50U3BhbnMuc2V0KHNwYW4uc3BhbkNvbnRleHQoKS5zcGFuSWQsIGV4cGlyYXRpb25EYXRlKTtcbiAgICAgIGNvbnN0IGJ1Y2tldEVudHJ5ID0gdGhpcy5fc3BhbnNUb0J1Y2tldEVudHJ5LmdldChzcGFuKTtcbiAgICAgIGlmIChidWNrZXRFbnRyeSkge1xuICAgICAgICBidWNrZXRFbnRyeS5zcGFucy5kZWxldGUoc3Bhbik7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIENhbmNlbCBhIHBlbmRpbmcgZGVib3VuY2VkIGZsdXNoLCBpZiB0aGVyZSBpcyBvbmVcbiAgICAvLyBUaGlzIGNhbiBiZSByZWxldmFudCBpZiB3ZSBkaXJlY3RseSBmbHVzaCwgY2lyY3VtdmVudGluZyB0aGUgZGVib3VuY2VcbiAgICAvLyBpbiB0aGF0IGNhc2UsIHdlIHdhbnQgdG8gY2FuY2VsIGFueSBwZW5kaW5nIGRlYm91bmNlZCBmbHVzaFxuICAgIHRoaXMuX2RlYm91bmNlZEZsdXNoLmNhbmNlbCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIHRoZSBleHBvcnRlci5cbiAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgc3BhbiBwcm9jZXNzb3IgaXMgc2h1dCBkb3duLlxuICAgKi9cbiAgIGNsZWFyKCkge1xuICAgIHRoaXMuX2ZpbmlzaGVkU3BhbkJ1Y2tldHMgPSB0aGlzLl9maW5pc2hlZFNwYW5CdWNrZXRzLmZpbGwodW5kZWZpbmVkKTtcbiAgICB0aGlzLl9zZW50U3BhbnMuY2xlYXIoKTtcbiAgICB0aGlzLl9kZWJvdW5jZWRGbHVzaC5jYW5jZWwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIHRoZSBnaXZlbiBzcGFucywgYnV0IG9ubHkgaWYgdGhleSBhcmUgcGFydCBvZiBhIGZpbmlzaGVkIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBSZXR1cm5zIHRoZSBzZW50IHNwYW5zLlxuICAgKiBTcGFucyByZW1haW4gdW5zZW50IHdoZW4gdGhlaXIgcGFyZW50IHNwYW4gaXMgbm90IHlldCBmaW5pc2hlZC5cbiAgICogVGhpcyB3aWxsIGhhcHBlbiByZWd1bGFybHksIGFzIGNoaWxkIHNwYW5zIGFyZSBnZW5lcmFsbHkgZmluaXNoZWQgYmVmb3JlIHRoZWlyIHBhcmVudHMuXG4gICAqIEJ1dCBpdCBfY291bGRfIGFsc28gaGFwcGVuIGJlY2F1c2UsIGZvciB3aGF0ZXZlciByZWFzb24sIGEgcGFyZW50IHNwYW4gd2FzIGxvc3QuXG4gICAqIEluIHRoaXMgY2FzZSwgd2UnbGwgZXZlbnR1YWxseSBuZWVkIHRvIGNsZWFuIHRoaXMgdXAuXG4gICAqL1xuICAgX21heWJlU2VuZChzcGFucykge1xuICAgIGNvbnN0IGdyb3VwZWQgPSBncm91cFNwYW5zV2l0aFBhcmVudHMoc3BhbnMpO1xuICAgIGNvbnN0IHNlbnRTcGFucyA9IG5ldyBTZXQoKTtcblxuICAgIGNvbnN0IHJvb3ROb2RlcyA9IHRoaXMuX2dldENvbXBsZXRlZFJvb3ROb2Rlcyhncm91cGVkKTtcblxuICAgIGZvciAoY29uc3Qgcm9vdCBvZiByb290Tm9kZXMpIHtcbiAgICAgIGNvbnN0IHNwYW4gPSByb290LnNwYW47XG4gICAgICBzZW50U3BhbnMuYWRkKHNwYW4pO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb25FdmVudCA9IGNyZWF0ZVRyYW5zYWN0aW9uRm9yT3RlbFNwYW4oc3Bhbik7XG5cbiAgICAgIC8vIEFkZCBhbiBhdHRyaWJ1dGUgdG8gdGhlIHRyYW5zYWN0aW9uIGV2ZW50IHRvIGluZGljYXRlIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiBpcyBhbiBvcnBoYW5lZCB0cmFuc2FjdGlvblxuICAgICAgaWYgKHJvb3QucGFyZW50Tm9kZSAmJiB0aGlzLl9zZW50U3BhbnMuaGFzKHJvb3QucGFyZW50Tm9kZS5pZCkpIHtcbiAgICAgICAgY29uc3QgdHJhY2VEYXRhID0gdHJhbnNhY3Rpb25FdmVudC5jb250ZXh0cz8udHJhY2U/LmRhdGE7XG4gICAgICAgIGlmICh0cmFjZURhdGEpIHtcbiAgICAgICAgICB0cmFjZURhdGFbJ3NlbnRyeS5wYXJlbnRfc3Bhbl9hbHJlYWR5X3NlbnQnXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gV2UnbGwgcmVjdXJzaXZlbHkgYWRkIGFsbCB0aGUgY2hpbGQgc3BhbnMgdG8gdGhpcyBhcnJheVxuICAgICAgY29uc3Qgc3BhbnMgPSB0cmFuc2FjdGlvbkV2ZW50LnNwYW5zIHx8IFtdO1xuXG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHJvb3QuY2hpbGRyZW4pIHtcbiAgICAgICAgY3JlYXRlQW5kRmluaXNoU3BhbkZvck90ZWxTcGFuKGNoaWxkLCBzcGFucywgc2VudFNwYW5zKTtcbiAgICAgIH1cblxuICAgICAgLy8gc3BhbnMuc29ydCgpIG11dGF0ZXMgdGhlIGFycmF5LCBidXQgd2UgZG8gbm90IHVzZSB0aGlzIGFueW1vcmUgYWZ0ZXIgdGhpcyBwb2ludFxuICAgICAgLy8gc28gd2UgY2FuIHNhZmVseSBtdXRhdGUgaXQgaGVyZVxuICAgICAgdHJhbnNhY3Rpb25FdmVudC5zcGFucyA9XG4gICAgICAgIHNwYW5zLmxlbmd0aCA+IE1BWF9TUEFOX0NPVU5UXG4gICAgICAgICAgPyBzcGFucy5zb3J0KChhLCBiKSA9PiBhLnN0YXJ0X3RpbWVzdGFtcCAtIGIuc3RhcnRfdGltZXN0YW1wKS5zbGljZSgwLCBNQVhfU1BBTl9DT1VOVClcbiAgICAgICAgICA6IHNwYW5zO1xuXG4gICAgICBjb25zdCBtZWFzdXJlbWVudHMgPSBjb3JlLnRpbWVkRXZlbnRzVG9NZWFzdXJlbWVudHMoc3Bhbi5ldmVudHMpO1xuICAgICAgaWYgKG1lYXN1cmVtZW50cykge1xuICAgICAgICB0cmFuc2FjdGlvbkV2ZW50Lm1lYXN1cmVtZW50cyA9IG1lYXN1cmVtZW50cztcbiAgICAgIH1cblxuICAgICAgY29yZS5jYXB0dXJlRXZlbnQodHJhbnNhY3Rpb25FdmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbnRTcGFucztcbiAgfVxuXG4gIC8qKiBSZW1vdmUgXCJleHBpcmVkXCIgc3BhbiBpZCBlbnRyaWVzIGZyb20gdGhlIF9zZW50U3BhbnMgY2FjaGUuICovXG4gICBfZmx1c2hTZW50U3BhbkNhY2hlKCkge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIC8vIE5vdGUsIGl0IGlzIHNhZmUgdG8gZGVsZXRlIGl0ZW1zIGZyb20gdGhlIG1hcCBhcyB3ZSBnbzogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM1OTQzOTk1LzkwMjk3XG4gICAgZm9yIChjb25zdCBbc3BhbklkLCBleHBpcmF0aW9uVGltZV0gb2YgdGhpcy5fc2VudFNwYW5zLmVudHJpZXMoKSkge1xuICAgICAgaWYgKGV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lc3RhbXApIHtcbiAgICAgICAgdGhpcy5fc2VudFNwYW5zLmRlbGV0ZShzcGFuSWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBDaGVjayBpZiBhIG5vZGUgaXMgYSBjb21wbGV0ZWQgcm9vdCBub2RlIG9yIGEgbm9kZSB3aG9zZSBwYXJlbnQgaGFzIGFscmVhZHkgYmVlbiBzZW50ICovXG4gICBfbm9kZUlzQ29tcGxldGVkUm9vdE5vZGVPckhhc1NlbnRQYXJlbnQobm9kZSkge1xuICAgIHJldHVybiAhIW5vZGUuc3BhbiAmJiAoIW5vZGUucGFyZW50Tm9kZSB8fCB0aGlzLl9zZW50U3BhbnMuaGFzKG5vZGUucGFyZW50Tm9kZS5pZCkpO1xuICB9XG5cbiAgLyoqIEdldCBhbGwgY29tcGxldGVkIHJvb3Qgbm9kZXMgZnJvbSBhIGxpc3Qgb2Ygbm9kZXMgKi9cbiAgIF9nZXRDb21wbGV0ZWRSb290Tm9kZXMobm9kZXMpIHtcbiAgICAvLyBUT0RPOiBXZSBzaG91bGQgYmUgYWJsZSB0byByZW1vdmUgdGhlIGV4cGxpY2l0IGBub2RlIGlzIFNwYW5Ob2RlQ29tcGxldGVkYCB0eXBlIGd1YXJkXG4gICAgLy8gICAgICAgb25jZSB3ZSBzdG9wIHN1cHBvcnRpbmcgVFMgPCA1LjVcbiAgICByZXR1cm4gbm9kZXMuZmlsdGVyKChub2RlKSA9PiB0aGlzLl9ub2RlSXNDb21wbGV0ZWRSb290Tm9kZU9ySGFzU2VudFBhcmVudChub2RlKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VTcGFuKHNwYW4pIHtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHNwYW4uYXR0cmlidXRlcztcblxuICBjb25zdCBvcmlnaW4gPSBhdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU5dIDtcbiAgY29uc3Qgb3AgPSBhdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUF0gO1xuICBjb25zdCBzb3VyY2UgPSBhdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0VdIDtcblxuICByZXR1cm4geyBvcmlnaW4sIG9wLCBzb3VyY2UgfTtcbn1cblxuLyoqIEV4cG9ydGVkIG9ubHkgZm9yIHRlc3RzLiAqL1xuZnVuY3Rpb24gY3JlYXRlVHJhbnNhY3Rpb25Gb3JPdGVsU3BhbihzcGFuKSB7XG4gIGNvbnN0IHsgb3AsIGRlc2NyaXB0aW9uLCBkYXRhLCBvcmlnaW4gPSAnbWFudWFsJywgc291cmNlIH0gPSBnZXRTcGFuRGF0YShzcGFuKTtcbiAgY29uc3QgY2FwdHVyZWRTcGFuU2NvcGVzID0gY29yZS5nZXRDYXB0dXJlZFNjb3Blc09uU3BhbihzcGFuICk7XG5cbiAgY29uc3Qgc2FtcGxlUmF0ZSA9IHNwYW4uYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU0FNUExFX1JBVEVdIDtcblxuICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgIFtjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFXTogc291cmNlLFxuICAgIFtjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU0FNUExFX1JBVEVdOiBzYW1wbGVSYXRlLFxuICAgIFtjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1BdOiBvcCxcbiAgICBbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09SSUdJTl06IG9yaWdpbixcbiAgICAuLi5kYXRhLFxuICAgIC4uLnJlbW92ZVNlbnRyeUF0dHJpYnV0ZXMoc3Bhbi5hdHRyaWJ1dGVzKSxcbiAgfTtcblxuICBjb25zdCB7IGxpbmtzIH0gPSBzcGFuO1xuICBjb25zdCB7IHRyYWNlSWQ6IHRyYWNlX2lkLCBzcGFuSWQ6IHNwYW5faWQgfSA9IHNwYW4uc3BhbkNvbnRleHQoKTtcblxuICAvLyBJZiBwYXJlbnRTcGFuSWRGcm9tVHJhY2VTdGF0ZSBpcyBkZWZpbmVkIGF0IGFsbCwgd2Ugd2FudCBpdCB0byB0YWtlIHByZWNlZGVuY2VcbiAgLy8gSW4gdGhhdCBjYXNlLCBhbiBlbXB0eSBzdHJpbmcgc2hvdWxkIGJlIGludGVycHJldGVkIGFzIFwibm8gcGFyZW50IHNwYW4gaWRcIixcbiAgLy8gZXZlbiBpZiBgc3Bhbi5wYXJlbnRTcGFuSWRgIGlzIHNldFxuICAvLyB0aGlzIGlzIHRoZSBjYXNlIHdoZW4gd2UgYXJlIHN0YXJ0aW5nIGEgbmV3IHRyYWNlLCB3aGVyZSB3ZSBoYXZlIGEgdmlydHVhbCBzcGFuIGJhc2VkIG9uIHRoZSBwcm9wYWdhdGlvbkNvbnRleHRcbiAgLy8gV2Ugb25seSB3YW50IHRvIGNvbnRpbnVlIHRoZSB0cmFjZUlkIGluIHRoaXMgY2FzZSwgYnV0IGlnbm9yZSB0aGUgcGFyZW50IHNwYW5cbiAgY29uc3QgcGFyZW50X3NwYW5faWQgPSBnZXRQYXJlbnRTcGFuSWQoc3Bhbik7XG5cbiAgY29uc3Qgc3RhdHVzID0gbWFwU3RhdHVzKHNwYW4pO1xuXG4gIGNvbnN0IHRyYWNlQ29udGV4dCA9IHtcbiAgICBwYXJlbnRfc3Bhbl9pZCxcbiAgICBzcGFuX2lkLFxuICAgIHRyYWNlX2lkLFxuICAgIGRhdGE6IGF0dHJpYnV0ZXMsXG4gICAgb3JpZ2luLFxuICAgIG9wLFxuICAgIHN0YXR1czogY29yZS5nZXRTdGF0dXNNZXNzYWdlKHN0YXR1cyksIC8vIEFzIHBlciBwcm90b2NvbCwgc3BhbiBzdGF0dXMgaXMgYWxsb3dlZCB0byBiZSB1bmRlZmluZWRcbiAgICBsaW5rczogY29yZS5jb252ZXJ0U3BhbkxpbmtzRm9yRW52ZWxvcGUobGlua3MpLFxuICB9O1xuXG4gIGNvbnN0IHN0YXR1c0NvZGUgPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuQVRUUl9IVFRQX1JFU1BPTlNFX1NUQVRVU19DT0RFXTtcbiAgY29uc3QgcmVzcG9uc2VDb250ZXh0ID0gdHlwZW9mIHN0YXR1c0NvZGUgPT09ICdudW1iZXInID8geyByZXNwb25zZTogeyBzdGF0dXNfY29kZTogc3RhdHVzQ29kZSB9IH0gOiB1bmRlZmluZWQ7XG5cbiAgY29uc3QgdHJhbnNhY3Rpb25FdmVudCA9IHtcbiAgICBjb250ZXh0czoge1xuICAgICAgdHJhY2U6IHRyYWNlQ29udGV4dCxcbiAgICAgIG90ZWw6IHtcbiAgICAgICAgcmVzb3VyY2U6IHNwYW4ucmVzb3VyY2UuYXR0cmlidXRlcyxcbiAgICAgIH0sXG4gICAgICAuLi5yZXNwb25zZUNvbnRleHQsXG4gICAgfSxcbiAgICBzcGFuczogW10sXG4gICAgc3RhcnRfdGltZXN0YW1wOiBjb3JlLnNwYW5UaW1lSW5wdXRUb1NlY29uZHMoc3Bhbi5zdGFydFRpbWUpLFxuICAgIHRpbWVzdGFtcDogY29yZS5zcGFuVGltZUlucHV0VG9TZWNvbmRzKHNwYW4uZW5kVGltZSksXG4gICAgdHJhbnNhY3Rpb246IGRlc2NyaXB0aW9uLFxuICAgIHR5cGU6ICd0cmFuc2FjdGlvbicsXG4gICAgc2RrUHJvY2Vzc2luZ01ldGFkYXRhOiB7XG4gICAgICBjYXB0dXJlZFNwYW5TY29wZTogY2FwdHVyZWRTcGFuU2NvcGVzLnNjb3BlLFxuICAgICAgY2FwdHVyZWRTcGFuSXNvbGF0aW9uU2NvcGU6IGNhcHR1cmVkU3BhblNjb3Blcy5pc29sYXRpb25TY29wZSxcbiAgICAgIHNhbXBsZVJhdGUsXG4gICAgICBkeW5hbWljU2FtcGxpbmdDb250ZXh0OiBjb3JlLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbihzcGFuICksXG4gICAgfSxcbiAgICAuLi4oc291cmNlICYmIHtcbiAgICAgIHRyYW5zYWN0aW9uX2luZm86IHtcbiAgICAgICAgc291cmNlLFxuICAgICAgfSxcbiAgICB9KSxcbiAgfTtcblxuICByZXR1cm4gdHJhbnNhY3Rpb25FdmVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQW5kRmluaXNoU3BhbkZvck90ZWxTcGFuKG5vZGUsIHNwYW5zLCBzZW50U3BhbnMpIHtcbiAgY29uc3Qgc3BhbiA9IG5vZGUuc3BhbjtcblxuICBpZiAoc3Bhbikge1xuICAgIHNlbnRTcGFucy5hZGQoc3Bhbik7XG4gIH1cblxuICBjb25zdCBzaG91bGREcm9wID0gIXNwYW47XG5cbiAgLy8gSWYgdGhpcyBzcGFuIHNob3VsZCBiZSBkcm9wcGVkLCB3ZSBzdGlsbCB3YW50IHRvIGNyZWF0ZSBzcGFucyBmb3IgdGhlIGNoaWxkcmVuIG9mIHRoaXNcbiAgaWYgKHNob3VsZERyb3ApIHtcbiAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgY3JlYXRlQW5kRmluaXNoU3BhbkZvck90ZWxTcGFuKGNoaWxkLCBzcGFucywgc2VudFNwYW5zKTtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzcGFuX2lkID0gc3Bhbi5zcGFuQ29udGV4dCgpLnNwYW5JZDtcbiAgY29uc3QgdHJhY2VfaWQgPSBzcGFuLnNwYW5Db250ZXh0KCkudHJhY2VJZDtcbiAgY29uc3QgcGFyZW50U3BhbklkID0gZ2V0UGFyZW50U3BhbklkKHNwYW4pO1xuXG4gIGNvbnN0IHsgYXR0cmlidXRlcywgc3RhcnRUaW1lLCBlbmRUaW1lLCBsaW5rcyB9ID0gc3BhbjtcblxuICBjb25zdCB7IG9wLCBkZXNjcmlwdGlvbiwgZGF0YSwgb3JpZ2luID0gJ21hbnVhbCcgfSA9IGdldFNwYW5EYXRhKHNwYW4pO1xuICBjb25zdCBhbGxEYXRhID0ge1xuICAgIFtjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOXTogb3JpZ2luLFxuICAgIFtjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1BdOiBvcCxcbiAgICAuLi5yZW1vdmVTZW50cnlBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpLFxuICAgIC4uLmRhdGEsXG4gIH07XG5cbiAgY29uc3Qgc3RhdHVzID0gbWFwU3RhdHVzKHNwYW4pO1xuXG4gIGNvbnN0IHNwYW5KU09OID0ge1xuICAgIHNwYW5faWQsXG4gICAgdHJhY2VfaWQsXG4gICAgZGF0YTogYWxsRGF0YSxcbiAgICBkZXNjcmlwdGlvbixcbiAgICBwYXJlbnRfc3Bhbl9pZDogcGFyZW50U3BhbklkLFxuICAgIHN0YXJ0X3RpbWVzdGFtcDogY29yZS5zcGFuVGltZUlucHV0VG9TZWNvbmRzKHN0YXJ0VGltZSksXG4gICAgLy8gVGhpcyBpcyBbMCwwXSBieSBkZWZhdWx0IGluIE9URUwsIGluIHdoaWNoIGNhc2Ugd2Ugd2FudCB0byBpbnRlcnByZXQgdGhpcyBhcyBubyBlbmQgdGltZVxuICAgIHRpbWVzdGFtcDogY29yZS5zcGFuVGltZUlucHV0VG9TZWNvbmRzKGVuZFRpbWUpIHx8IHVuZGVmaW5lZCxcbiAgICBzdGF0dXM6IGNvcmUuZ2V0U3RhdHVzTWVzc2FnZShzdGF0dXMpLCAvLyBBcyBwZXIgcHJvdG9jb2wsIHNwYW4gc3RhdHVzIGlzIGFsbG93ZWQgdG8gYmUgdW5kZWZpbmVkXG4gICAgb3AsXG4gICAgb3JpZ2luLFxuICAgIG1lYXN1cmVtZW50czogY29yZS50aW1lZEV2ZW50c1RvTWVhc3VyZW1lbnRzKHNwYW4uZXZlbnRzKSxcbiAgICBsaW5rczogY29yZS5jb252ZXJ0U3BhbkxpbmtzRm9yRW52ZWxvcGUobGlua3MpLFxuICB9O1xuXG4gIHNwYW5zLnB1c2goc3BhbkpTT04pO1xuXG4gIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgY3JlYXRlQW5kRmluaXNoU3BhbkZvck90ZWxTcGFuKGNoaWxkLCBzcGFucywgc2VudFNwYW5zKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFNwYW5EYXRhKHNwYW4pXG5cbiB7XG4gIGNvbnN0IHsgb3A6IGRlZmluZWRPcCwgc291cmNlOiBkZWZpbmVkU291cmNlLCBvcmlnaW4gfSA9IHBhcnNlU3BhbihzcGFuKTtcbiAgY29uc3QgeyBvcDogaW5mZXJyZWRPcCwgZGVzY3JpcHRpb24sIHNvdXJjZTogaW5mZXJyZWRTb3VyY2UsIGRhdGE6IGluZmVycmVkRGF0YSB9ID0gcGFyc2VTcGFuRGVzY3JpcHRpb24oc3Bhbik7XG5cbiAgY29uc3Qgb3AgPSBkZWZpbmVkT3AgfHwgaW5mZXJyZWRPcDtcbiAgY29uc3Qgc291cmNlID0gZGVmaW5lZFNvdXJjZSB8fCBpbmZlcnJlZFNvdXJjZTtcblxuICBjb25zdCBkYXRhID0geyAuLi5pbmZlcnJlZERhdGEsIC4uLmdldERhdGEoc3BhbikgfTtcblxuICByZXR1cm4ge1xuICAgIG9wLFxuICAgIGRlc2NyaXB0aW9uLFxuICAgIHNvdXJjZSxcbiAgICBvcmlnaW4sXG4gICAgZGF0YSxcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgY3VzdG9tIGBzZW50cnkuYCBhdHRyaWJ1dGVzIHdlIGRvIG5vdCBuZWVkIHRvIHNlbmQuXG4gKiBUaGVzZSBhcmUgbW9yZSBjYXJyaWVyIGF0dHJpYnV0ZXMgd2UgdXNlIGluc2lkZSBvZiB0aGUgU0RLLCB3ZSBkbyBub3QgbmVlZCB0byBzZW5kIHRoZW0gdG8gdGhlIEFQSS5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlU2VudHJ5QXR0cmlidXRlcyhkYXRhKSB7XG4gIGNvbnN0IGNsZWFuZWREYXRhID0geyAuLi5kYXRhIH07XG5cbiAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWR5bmFtaWMtZGVsZXRlICovXG4gIGRlbGV0ZSBjbGVhbmVkRGF0YVtjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU0FNUExFX1JBVEVdO1xuICBkZWxldGUgY2xlYW5lZERhdGFbU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9QQVJFTlRfSVNfUkVNT1RFXTtcbiAgZGVsZXRlIGNsZWFuZWREYXRhW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9DVVNUT01fU1BBTl9OQU1FXTtcbiAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHluYW1pYy1kZWxldGUgKi9cblxuICByZXR1cm4gY2xlYW5lZERhdGE7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEoc3Bhbikge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gc3Bhbi5hdHRyaWJ1dGVzO1xuICBjb25zdCBkYXRhID0ge307XG5cbiAgaWYgKHNwYW4ua2luZCAhPT0gYXBpLlNwYW5LaW5kLklOVEVSTkFMKSB7XG4gICAgZGF0YVsnb3RlbC5raW5kJ10gPSBhcGkuU3BhbktpbmRbc3Bhbi5raW5kXTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBjb25zdCBtYXliZUh0dHBTdGF0dXNDb2RlQXR0cmlidXRlID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfU1RBVFVTX0NPREVdO1xuICBpZiAobWF5YmVIdHRwU3RhdHVzQ29kZUF0dHJpYnV0ZSkge1xuICAgIGRhdGFbc2VtYW50aWNDb252ZW50aW9ucy5BVFRSX0hUVFBfUkVTUE9OU0VfU1RBVFVTX0NPREVdID0gbWF5YmVIdHRwU3RhdHVzQ29kZUF0dHJpYnV0ZSA7XG4gIH1cblxuICBjb25zdCByZXF1ZXN0RGF0YSA9IGdldFJlcXVlc3RTcGFuRGF0YShzcGFuKTtcblxuICBpZiAocmVxdWVzdERhdGEudXJsKSB7XG4gICAgZGF0YS51cmwgPSByZXF1ZXN0RGF0YS51cmw7XG4gIH1cblxuICBpZiAocmVxdWVzdERhdGFbJ2h0dHAucXVlcnknXSkge1xuICAgIGRhdGFbJ2h0dHAucXVlcnknXSA9IHJlcXVlc3REYXRhWydodHRwLnF1ZXJ5J10uc2xpY2UoMSk7XG4gIH1cbiAgaWYgKHJlcXVlc3REYXRhWydodHRwLmZyYWdtZW50J10pIHtcbiAgICBkYXRhWydodHRwLmZyYWdtZW50J10gPSByZXF1ZXN0RGF0YVsnaHR0cC5mcmFnbWVudCddLnNsaWNlKDEpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIG9uU3BhblN0YXJ0KHNwYW4sIHBhcmVudENvbnRleHQpIHtcbiAgLy8gVGhpcyBpcyBhIHJlbGlhYmxlIHdheSB0byBnZXQgdGhlIHBhcmVudCBzcGFuIC0gYmVjYXVzZSB0aGlzIGlzIGV4YWN0bHkgaG93IHRoZSBwYXJlbnQgaXMgaWRlbnRpZmllZCBpbiB0aGUgT1RFTCBTREtcbiAgY29uc3QgcGFyZW50U3BhbiA9IGFwaS50cmFjZS5nZXRTcGFuKHBhcmVudENvbnRleHQpO1xuXG4gIGxldCBzY29wZXMgPSBnZXRTY29wZXNGcm9tQ29udGV4dChwYXJlbnRDb250ZXh0KTtcblxuICAvLyBXZSBuZWVkIGFjY2VzcyB0byB0aGUgcGFyZW50IHNwYW4gaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBtb3ZlIHVwIHRoZSBzcGFuIHRyZWUgZm9yIGJyZWFkY3J1bWJzXG4gIGlmIChwYXJlbnRTcGFuICYmICFwYXJlbnRTcGFuLnNwYW5Db250ZXh0KCkuaXNSZW1vdGUpIHtcbiAgICBjb3JlLmFkZENoaWxkU3BhblRvU3BhbihwYXJlbnRTcGFuLCBzcGFuKTtcbiAgfVxuXG4gIC8vIFdlIG5lZWQgdGhpcyBpbiB0aGUgc3BhbiBleHBvcnRlclxuICBpZiAocGFyZW50U3Bhbj8uc3BhbkNvbnRleHQoKS5pc1JlbW90ZSkge1xuICAgIHNwYW4uc2V0QXR0cmlidXRlKFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfUEFSRU5UX0lTX1JFTU9URSwgdHJ1ZSk7XG4gIH1cblxuICAvLyBUaGUgcm9vdCBjb250ZXh0IGRvZXMgbm90IGhhdmUgc2NvcGVzIHN0b3JlZCwgc28gd2UgY2hlY2sgZm9yIHRoaXMgc3BlY2lmaWNhbGx5XG4gIC8vIEFzIGZhbGxiYWNrIHdlIGF0dGFjaCB0aGUgZ2xvYmFsIHNjb3Blc1xuICBpZiAocGFyZW50Q29udGV4dCA9PT0gYXBpLlJPT1RfQ09OVEVYVCkge1xuICAgIHNjb3BlcyA9IHtcbiAgICAgIHNjb3BlOiBjb3JlLmdldERlZmF1bHRDdXJyZW50U2NvcGUoKSxcbiAgICAgIGlzb2xhdGlvblNjb3BlOiBjb3JlLmdldERlZmF1bHRJc29sYXRpb25TY29wZSgpLFxuICAgIH07XG4gIH1cblxuICAvLyBXZSBuZWVkIHRoZSBzY29wZSBhdCB0aW1lIG9mIHNwYW4gY3JlYXRpb24gaW4gb3JkZXIgdG8gYXBwbHkgaXQgdG8gdGhlIGV2ZW50IHdoZW4gdGhlIHNwYW4gaXMgZmluaXNoZWRcbiAgaWYgKHNjb3Blcykge1xuICAgIGNvcmUuc2V0Q2FwdHVyZWRTY29wZXNPblNwYW4oc3Bhbiwgc2NvcGVzLnNjb3BlLCBzY29wZXMuaXNvbGF0aW9uU2NvcGUpO1xuICB9XG5cbiAgY29yZS5sb2dTcGFuU3RhcnQoc3Bhbik7XG5cbiAgY29uc3QgY2xpZW50ID0gY29yZS5nZXRDbGllbnQoKTtcbiAgY2xpZW50Py5lbWl0KCdzcGFuU3RhcnQnLCBzcGFuKTtcbn1cblxuZnVuY3Rpb24gb25TcGFuRW5kKHNwYW4pIHtcbiAgY29yZS5sb2dTcGFuRW5kKHNwYW4pO1xuXG4gIGNvbnN0IGNsaWVudCA9IGNvcmUuZ2V0Q2xpZW50KCk7XG4gIGNsaWVudD8uZW1pdCgnc3BhbkVuZCcsIHNwYW4pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIE9wZW5UZWxlbWV0cnkgU3BhbnMgdG8gU2VudHJ5IFNwYW5zIGFuZCBzZW5kcyB0aGVtIHRvIFNlbnRyeSB2aWFcbiAqIHRoZSBTZW50cnkgU0RLLlxuICovXG5jbGFzcyBTZW50cnlTcGFuUHJvY2Vzc29yICB7XG5cbiAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzZXRJc1NldHVwKCdTZW50cnlTcGFuUHJvY2Vzc29yJyk7XG4gICAgdGhpcy5fZXhwb3J0ZXIgPSBuZXcgU2VudHJ5U3BhbkV4cG9ydGVyKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICAgYXN5bmMgZm9yY2VGbHVzaCgpIHtcbiAgICB0aGlzLl9leHBvcnRlci5mbHVzaCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICAgYXN5bmMgc2h1dGRvd24oKSB7XG4gICAgdGhpcy5fZXhwb3J0ZXIuY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIG9uU3RhcnQoc3BhbiwgcGFyZW50Q29udGV4dCkge1xuICAgIG9uU3BhblN0YXJ0KHNwYW4sIHBhcmVudENvbnRleHQpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gICBvbkVuZChzcGFuKSB7XG4gICAgb25TcGFuRW5kKHNwYW4pO1xuXG4gICAgdGhpcy5fZXhwb3J0ZXIuZXhwb3J0KHNwYW4pO1xuICB9XG59XG5cbi8qKlxuICogQSBjdXN0b20gT1RFTCBzYW1wbGVyIHRoYXQgdXNlcyBTZW50cnkgc2FtcGxpbmcgcmF0ZXMgdG8gbWFrZSBpdHMgZGVjaXNpb25cbiAqL1xuY2xhc3MgU2VudHJ5U2FtcGxlciAge1xuXG4gICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgc2V0SXNTZXR1cCgnU2VudHJ5U2FtcGxlcicpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gICBzaG91bGRTYW1wbGUoXG4gICAgY29udGV4dCxcbiAgICB0cmFjZUlkLFxuICAgIHNwYW5OYW1lLFxuICAgIHNwYW5LaW5kLFxuICAgIHNwYW5BdHRyaWJ1dGVzLFxuICAgIF9saW5rcyxcbiAgKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2NsaWVudC5nZXRPcHRpb25zKCk7XG5cbiAgICBjb25zdCBwYXJlbnRTcGFuID0gZ2V0VmFsaWRTcGFuKGNvbnRleHQpO1xuICAgIGNvbnN0IHBhcmVudENvbnRleHQgPSBwYXJlbnRTcGFuPy5zcGFuQ29udGV4dCgpO1xuXG4gICAgaWYgKCFjb3JlLmhhc1NwYW5zRW5hYmxlZChvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIHdyYXBTYW1wbGluZ0RlY2lzaW9uKHsgZGVjaXNpb246IHVuZGVmaW5lZCwgY29udGV4dCwgc3BhbkF0dHJpYnV0ZXMgfSk7XG4gICAgfVxuXG4gICAgLy8gYEFUVFJfSFRUUF9SRVFVRVNUX01FVEhPRGAgaXMgdGhlIG5ldyBhdHRyaWJ1dGUsIGJ1dCB3ZSBzdGlsbCBzdXBwb3J0IHRoZSBvbGQgb25lLCBgU0VNQVRUUlNfSFRUUF9NRVRIT0RgLCBmb3Igbm93LlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgIGNvbnN0IG1heWJlU3Bhbkh0dHBNZXRob2QgPSBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfTUVUSE9EXSB8fCBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLkFUVFJfSFRUUF9SRVFVRVNUX01FVEhPRF07XG5cbiAgICAvLyBJZiB3ZSBoYXZlIGEgaHR0cC5jbGllbnQgc3BhbiB0aGF0IGhhcyBubyBsb2NhbCBwYXJlbnQsIHdlIG5ldmVyIHdhbnQgdG8gc2FtcGxlIGl0XG4gICAgLy8gYnV0IHdlIHdhbnQgdG8gbGVhdmUgZG93bnN0cmVhbSBzYW1wbGluZyBkZWNpc2lvbnMgdXAgdG8gdGhlIHNlcnZlclxuICAgIGlmIChzcGFuS2luZCA9PT0gYXBpLlNwYW5LaW5kLkNMSUVOVCAmJiBtYXliZVNwYW5IdHRwTWV0aG9kICYmICghcGFyZW50U3BhbiB8fCBwYXJlbnRDb250ZXh0Py5pc1JlbW90ZSkpIHtcbiAgICAgIHJldHVybiB3cmFwU2FtcGxpbmdEZWNpc2lvbih7IGRlY2lzaW9uOiB1bmRlZmluZWQsIGNvbnRleHQsIHNwYW5BdHRyaWJ1dGVzIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudFNhbXBsZWQgPSBwYXJlbnRTcGFuID8gZ2V0UGFyZW50U2FtcGxlZChwYXJlbnRTcGFuLCB0cmFjZUlkLCBzcGFuTmFtZSkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgaXNSb290U3BhbiA9ICFwYXJlbnRTcGFuIHx8IHBhcmVudENvbnRleHQ/LmlzUmVtb3RlO1xuXG4gICAgLy8gV2Ugb25seSBzYW1wbGUgYmFzZWQgb24gcGFyYW1ldGVycyAobGlrZSB0cmFjZXNTYW1wbGVSYXRlIG9yIHRyYWNlc1NhbXBsZXIpIGZvciByb290IHNwYW5zICh3aGljaCBpcyBkb25lIGluIHNhbXBsZVNwYW4pLlxuICAgIC8vIE5vbi1yb290LXNwYW5zIHNpbXBseSBpbmhlcml0IHRoZSBzYW1wbGluZyBkZWNpc2lvbiBmcm9tIHRoZWlyIHBhcmVudC5cbiAgICBpZiAoIWlzUm9vdFNwYW4pIHtcbiAgICAgIHJldHVybiB3cmFwU2FtcGxpbmdEZWNpc2lvbih7XG4gICAgICAgIGRlY2lzaW9uOiBwYXJlbnRTYW1wbGVkID8gc2RrVHJhY2VCYXNlLlNhbXBsaW5nRGVjaXNpb24uUkVDT1JEX0FORF9TQU1QTEVEIDogc2RrVHJhY2VCYXNlLlNhbXBsaW5nRGVjaXNpb24uTk9UX1JFQ09SRCxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgc3BhbkF0dHJpYnV0ZXMsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBXZSB3YW50IHRvIHBhc3MgdGhlIGluZmVycmVkIG5hbWUgJiBhdHRyaWJ1dGVzIHRvIHRoZSBzYW1wbGVyIG1ldGhvZFxuICAgIGNvbnN0IHtcbiAgICAgIGRlc2NyaXB0aW9uOiBpbmZlcnJlZFNwYW5OYW1lLFxuICAgICAgZGF0YTogaW5mZXJyZWRBdHRyaWJ1dGVzLFxuICAgICAgb3AsXG4gICAgfSA9IGluZmVyU3BhbkRhdGEoc3Bhbk5hbWUsIHNwYW5BdHRyaWJ1dGVzLCBzcGFuS2luZCk7XG5cbiAgICBjb25zdCBtZXJnZWRBdHRyaWJ1dGVzID0ge1xuICAgICAgLi4uaW5mZXJyZWRBdHRyaWJ1dGVzLFxuICAgICAgLi4uc3BhbkF0dHJpYnV0ZXMsXG4gICAgfTtcblxuICAgIGlmIChvcCkge1xuICAgICAgbWVyZ2VkQXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1BdID0gb3A7XG4gICAgfVxuXG4gICAgY29uc3QgbXV0YWJsZVNhbXBsaW5nRGVjaXNpb24gPSB7IGRlY2lzaW9uOiB0cnVlIH07XG4gICAgdGhpcy5fY2xpZW50LmVtaXQoXG4gICAgICAnYmVmb3JlU2FtcGxpbmcnLFxuICAgICAge1xuICAgICAgICBzcGFuQXR0cmlidXRlczogbWVyZ2VkQXR0cmlidXRlcyxcbiAgICAgICAgc3Bhbk5hbWU6IGluZmVycmVkU3Bhbk5hbWUsXG4gICAgICAgIHBhcmVudFNhbXBsZWQ6IHBhcmVudFNhbXBsZWQsXG4gICAgICAgIHBhcmVudENvbnRleHQ6IHBhcmVudENvbnRleHQsXG4gICAgICB9LFxuICAgICAgbXV0YWJsZVNhbXBsaW5nRGVjaXNpb24sXG4gICAgKTtcbiAgICBpZiAoIW11dGFibGVTYW1wbGluZ0RlY2lzaW9uLmRlY2lzaW9uKSB7XG4gICAgICByZXR1cm4gd3JhcFNhbXBsaW5nRGVjaXNpb24oeyBkZWNpc2lvbjogdW5kZWZpbmVkLCBjb250ZXh0LCBzcGFuQXR0cmlidXRlcyB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB7IGlzb2xhdGlvblNjb3BlIH0gPSBnZXRTY29wZXNGcm9tQ29udGV4dChjb250ZXh0KSA/PyB7fTtcblxuICAgIGNvbnN0IGRzY1N0cmluZyA9IHBhcmVudENvbnRleHQ/LnRyYWNlU3RhdGUgPyBwYXJlbnRDb250ZXh0LnRyYWNlU3RhdGUuZ2V0KFNFTlRSWV9UUkFDRV9TVEFURV9EU0MpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGRzYyA9IGRzY1N0cmluZyA/IGNvcmUuYmFnZ2FnZUhlYWRlclRvRHluYW1pY1NhbXBsaW5nQ29udGV4dChkc2NTdHJpbmcpIDogdW5kZWZpbmVkO1xuXG4gICAgY29uc3Qgc2FtcGxlUmFuZCA9IGNvcmUucGFyc2VTYW1wbGVSYXRlKGRzYz8uc2FtcGxlX3JhbmQpID8/IE1hdGgucmFuZG9tKCk7XG5cbiAgICBjb25zdCBbc2FtcGxlZCwgc2FtcGxlUmF0ZSwgbG9jYWxTYW1wbGVSYXRlV2FzQXBwbGllZF0gPSBjb3JlLnNhbXBsZVNwYW4oXG4gICAgICBvcHRpb25zLFxuICAgICAge1xuICAgICAgICBuYW1lOiBpbmZlcnJlZFNwYW5OYW1lLFxuICAgICAgICBhdHRyaWJ1dGVzOiBtZXJnZWRBdHRyaWJ1dGVzLFxuICAgICAgICBub3JtYWxpemVkUmVxdWVzdDogaXNvbGF0aW9uU2NvcGU/LmdldFNjb3BlRGF0YSgpLnNka1Byb2Nlc3NpbmdNZXRhZGF0YS5ub3JtYWxpemVkUmVxdWVzdCxcbiAgICAgICAgcGFyZW50U2FtcGxlZCxcbiAgICAgICAgcGFyZW50U2FtcGxlUmF0ZTogY29yZS5wYXJzZVNhbXBsZVJhdGUoZHNjPy5zYW1wbGVfcmF0ZSksXG4gICAgICB9LFxuICAgICAgc2FtcGxlUmFuZCxcbiAgICApO1xuXG4gICAgY29uc3QgbWV0aG9kID0gYCR7bWF5YmVTcGFuSHR0cE1ldGhvZH1gLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKG1ldGhvZCA9PT0gJ09QVElPTlMnIHx8IG1ldGhvZCA9PT0gJ0hFQUQnKSB7XG4gICAgICBERUJVR19CVUlMRCAmJiBjb3JlLmRlYnVnLmxvZyhgW1RyYWNpbmddIE5vdCBzYW1wbGluZyBzcGFuIGJlY2F1c2UgSFRUUCBtZXRob2QgaXMgJyR7bWV0aG9kfScgZm9yICR7c3Bhbk5hbWV9YCk7XG5cbiAgICAgIHJldHVybiB3cmFwU2FtcGxpbmdEZWNpc2lvbih7XG4gICAgICAgIGRlY2lzaW9uOiBzZGtUcmFjZUJhc2UuU2FtcGxpbmdEZWNpc2lvbi5OT1RfUkVDT1JELFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBzcGFuQXR0cmlidXRlcyxcbiAgICAgICAgc2FtcGxlUmFuZCxcbiAgICAgICAgZG93bnN0cmVhbVRyYWNlU2FtcGxlUmF0ZTogMCwgLy8gd2UgZG9uJ3Qgd2FudCB0byBzYW1wbGUgYW55dGhpbmcgaW4gdGhlIGRvd25zdHJlYW0gdHJhY2UgZWl0aGVyXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAhc2FtcGxlZCAmJlxuICAgICAgLy8gV2UgY2hlY2sgZm9yIGBwYXJlbnRTYW1wbGVkID09PSB1bmRlZmluZWRgIGJlY2F1c2Ugd2Ugb25seSB3YW50IHRvIHJlY29yZCBjbGllbnQgcmVwb3J0cyBmb3Igc3BhbnMgdGhhdCBhcmUgdHJhY2Ugcm9vdHMgKGllLiB3aGVuIHRoZXJlIHdhcyBpbmNvbWluZyB0cmFjZSlcbiAgICAgIHBhcmVudFNhbXBsZWQgPT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgREVCVUdfQlVJTEQgJiYgY29yZS5kZWJ1Zy5sb2coJ1tUcmFjaW5nXSBEaXNjYXJkaW5nIHJvb3Qgc3BhbiBiZWNhdXNlIGl0cyB0cmFjZSB3YXMgbm90IGNob3NlbiB0byBiZSBzYW1wbGVkLicpO1xuICAgICAgdGhpcy5fY2xpZW50LnJlY29yZERyb3BwZWRFdmVudCgnc2FtcGxlX3JhdGUnLCAndHJhbnNhY3Rpb24nKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4ud3JhcFNhbXBsaW5nRGVjaXNpb24oe1xuICAgICAgICBkZWNpc2lvbjogc2FtcGxlZCA/IHNka1RyYWNlQmFzZS5TYW1wbGluZ0RlY2lzaW9uLlJFQ09SRF9BTkRfU0FNUExFRCA6IHNka1RyYWNlQmFzZS5TYW1wbGluZ0RlY2lzaW9uLk5PVF9SRUNPUkQsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHNwYW5BdHRyaWJ1dGVzLFxuICAgICAgICBzYW1wbGVSYW5kLFxuICAgICAgICBkb3duc3RyZWFtVHJhY2VTYW1wbGVSYXRlOiBsb2NhbFNhbXBsZVJhdGVXYXNBcHBsaWVkID8gc2FtcGxlUmF0ZSA6IHVuZGVmaW5lZCxcbiAgICAgIH0pLFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAvLyBXZSBzZXQgdGhlIHNhbXBsZSByYXRlIG9uIHRoZSBzcGFuIHdoZW4gYSBsb2NhbCBzYW1wbGUgcmF0ZSB3YXMgYXBwbGllZCB0byBiZXR0ZXIgdW5kZXJzdGFuZCBob3cgdHJhY2VzIHdlcmUgc2FtcGxlZCBpbiBTZW50cnlcbiAgICAgICAgW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TQU1QTEVfUkFURV06IGxvY2FsU2FtcGxlUmF0ZVdhc0FwcGxpZWQgPyBzYW1wbGVSYXRlIDogdW5kZWZpbmVkLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgLyoqIFJldHVybnMgdGhlIHNhbXBsZXIgbmFtZSBvciBzaG9ydCBkZXNjcmlwdGlvbiB3aXRoIHRoZSBjb25maWd1cmF0aW9uLiAqL1xuICAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdTZW50cnlTYW1wbGVyJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQYXJlbnRTYW1wbGVkKHBhcmVudFNwYW4sIHRyYWNlSWQsIHNwYW5OYW1lKSB7XG4gIGNvbnN0IHBhcmVudENvbnRleHQgPSBwYXJlbnRTcGFuLnNwYW5Db250ZXh0KCk7XG5cbiAgLy8gT25seSBpbmhlcml0IHNhbXBsZSByYXRlIGlmIGB0cmFjZUlkYCBpcyB0aGUgc2FtZVxuICAvLyBOb3RlIGZvciB0ZXN0aW5nOiBgaXNTcGFuQ29udGV4dFZhbGlkKClgIGNoZWNrcyB0aGUgZm9ybWF0IG9mIHRoZSB0cmFjZUlkL3NwYW5JZCwgc28gd2UgbmVlZCB0byBwYXNzIHZhbGlkIG9uZXNcbiAgaWYgKGFwaS5pc1NwYW5Db250ZXh0VmFsaWQocGFyZW50Q29udGV4dCkgJiYgcGFyZW50Q29udGV4dC50cmFjZUlkID09PSB0cmFjZUlkKSB7XG4gICAgaWYgKHBhcmVudENvbnRleHQuaXNSZW1vdGUpIHtcbiAgICAgIGNvbnN0IHBhcmVudFNhbXBsZWQgPSBnZXRTYW1wbGluZ0RlY2lzaW9uKHBhcmVudFNwYW4uc3BhbkNvbnRleHQoKSk7XG4gICAgICBERUJVR19CVUlMRCAmJlxuICAgICAgICBjb3JlLmRlYnVnLmxvZyhgW1RyYWNpbmddIEluaGVyaXRpbmcgcmVtb3RlIHBhcmVudCdzIHNhbXBsZWQgZGVjaXNpb24gZm9yICR7c3Bhbk5hbWV9OiAke3BhcmVudFNhbXBsZWR9YCk7XG4gICAgICByZXR1cm4gcGFyZW50U2FtcGxlZDtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJlbnRTYW1wbGVkID0gZ2V0U2FtcGxpbmdEZWNpc2lvbihwYXJlbnRDb250ZXh0KTtcbiAgICBERUJVR19CVUlMRCAmJiBjb3JlLmRlYnVnLmxvZyhgW1RyYWNpbmddIEluaGVyaXRpbmcgcGFyZW50J3Mgc2FtcGxlZCBkZWNpc2lvbiBmb3IgJHtzcGFuTmFtZX06ICR7cGFyZW50U2FtcGxlZH1gKTtcbiAgICByZXR1cm4gcGFyZW50U2FtcGxlZDtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogV3JhcCBhIHNhbXBsaW5nIGRlY2lzaW9uIHdpdGggZGF0YSB0aGF0IFNlbnRyeSBuZWVkcyB0byB3b3JrIHByb3Blcmx5IHdpdGggaXQuXG4gKiBJZiB5b3UgcGFzcyBgZGVjaXNpb246IHVuZGVmaW5lZGAsIGl0IHdpbGwgYmUgdHJlYXRlZCBhcyBgTk9UX1JFQ09SRElOR2AsIGJ1dCBpbiBjb250cmFzdCB0byBwYXNzaW5nIGBOT1RfUkVDT1JESU5HYFxuICogaXQgd2lsbCBub3QgcHJvcGFnYXRlIHRoaXMgZGVjaXNpb24gdG8gZG93bnN0cmVhbSBTZW50cnkgU0RLcy5cbiAqL1xuZnVuY3Rpb24gd3JhcFNhbXBsaW5nRGVjaXNpb24oe1xuICBkZWNpc2lvbixcbiAgY29udGV4dCxcbiAgc3BhbkF0dHJpYnV0ZXMsXG4gIHNhbXBsZVJhbmQsXG4gIGRvd25zdHJlYW1UcmFjZVNhbXBsZVJhdGUsXG59XG5cbikge1xuICBsZXQgdHJhY2VTdGF0ZSA9IGdldEJhc2VUcmFjZVN0YXRlKGNvbnRleHQsIHNwYW5BdHRyaWJ1dGVzKTtcblxuICAvLyBXZSB3aWxsIG92ZXJyaWRlIHRoZSBwcm9wYWdhdGVkIHNhbXBsZSByYXRlIGRvd25zdHJlYW0gd2hlblxuICAvLyAtIHRoZSB0cmFjZXNTYW1wbGVSYXRlIGlzIGFwcGxpZWRcbiAgLy8gLSB0aGUgdHJhY2VzU2FtcGxlciBpcyBpbnZva2VkXG4gIC8vIFNpbmNlIHVuc2FtcGxlZCBPVEVMIHNwYW5zIChOb25SZWNvcmRpbmdTcGFucykgY2Fubm90IGhvbGQgYXR0cmlidXRlcyB3ZSBuZWVkIHRvIHN0b3JlIHRoaXMgb24gdGhlICh0cmFjZSljb250ZXh0LlxuICBpZiAoZG93bnN0cmVhbVRyYWNlU2FtcGxlUmF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdHJhY2VTdGF0ZSA9IHRyYWNlU3RhdGUuc2V0KFNFTlRSWV9UUkFDRV9TVEFURV9TQU1QTEVfUkFURSwgYCR7ZG93bnN0cmVhbVRyYWNlU2FtcGxlUmF0ZX1gKTtcbiAgfVxuXG4gIGlmIChzYW1wbGVSYW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICB0cmFjZVN0YXRlID0gdHJhY2VTdGF0ZS5zZXQoU0VOVFJZX1RSQUNFX1NUQVRFX1NBTVBMRV9SQU5ELCBgJHtzYW1wbGVSYW5kfWApO1xuICB9XG5cbiAgLy8gSWYgdGhlIGRlY2lzaW9uIGlzIHVuZGVmaW5lZCwgd2UgdHJlYXQgaXQgYXMgTk9UX1JFQ09SRElORywgYnV0IHdlIGRvbid0IHByb3BhZ2F0ZSB0aGlzIGRlY2lzaW9uIHRvIGRvd25zdHJlYW0gU0RLc1xuICAvLyBXaGljaCBpcyBkb25lIGJ5IG5vdCBzZXR0aW5nIGBTRU5UUllfVFJBQ0VfU1RBVEVfU0FNUExFRF9OT1RfUkVDT1JESU5HYCB0cmFjZVN0YXRlXG4gIGlmIChkZWNpc2lvbiA9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4geyBkZWNpc2lvbjogc2RrVHJhY2VCYXNlLlNhbXBsaW5nRGVjaXNpb24uTk9UX1JFQ09SRCwgdHJhY2VTdGF0ZSB9O1xuICB9XG5cbiAgaWYgKGRlY2lzaW9uID09PSBzZGtUcmFjZUJhc2UuU2FtcGxpbmdEZWNpc2lvbi5OT1RfUkVDT1JEKSB7XG4gICAgcmV0dXJuIHsgZGVjaXNpb24sIHRyYWNlU3RhdGU6IHRyYWNlU3RhdGUuc2V0KFNFTlRSWV9UUkFDRV9TVEFURV9TQU1QTEVEX05PVF9SRUNPUkRJTkcsICcxJykgfTtcbiAgfVxuXG4gIHJldHVybiB7IGRlY2lzaW9uLCB0cmFjZVN0YXRlIH07XG59XG5cbmZ1bmN0aW9uIGdldEJhc2VUcmFjZVN0YXRlKGNvbnRleHQsIHNwYW5BdHRyaWJ1dGVzKSB7XG4gIGNvbnN0IHBhcmVudFNwYW4gPSBhcGkudHJhY2UuZ2V0U3Bhbihjb250ZXh0KTtcbiAgY29uc3QgcGFyZW50Q29udGV4dCA9IHBhcmVudFNwYW4/LnNwYW5Db250ZXh0KCk7XG5cbiAgbGV0IHRyYWNlU3RhdGUgPSBwYXJlbnRDb250ZXh0Py50cmFjZVN0YXRlIHx8IG5ldyBjb3JlJDEuVHJhY2VTdGF0ZSgpO1xuXG4gIC8vIFdlIGFsd2F5cyBrZWVwIHRoZSBVUkwgb24gdGhlIHRyYWNlIHN0YXRlLCBzbyB3ZSBjYW4gYWNjZXNzIGl0IGluIHRoZSBwcm9wYWdhdG9yXG4gIC8vIGBBVFRSX1VSTF9GVUxMYCBpcyB0aGUgbmV3IGF0dHJpYnV0ZSwgYnV0IHdlIHN0aWxsIHN1cHBvcnQgdGhlIG9sZCBvbmUsIGBBVFRSX0hUVFBfVVJMYCwgZm9yIG5vdy5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIGNvbnN0IHVybCA9IHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9VUkxdIHx8IHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuQVRUUl9VUkxfRlVMTF07XG4gIGlmICh1cmwgJiYgdHlwZW9mIHVybCA9PT0gJ3N0cmluZycpIHtcbiAgICB0cmFjZVN0YXRlID0gdHJhY2VTdGF0ZS5zZXQoU0VOVFJZX1RSQUNFX1NUQVRFX1VSTCwgdXJsKTtcbiAgfVxuXG4gIHJldHVybiB0cmFjZVN0YXRlO1xufVxuXG4vKipcbiAqIElmIHRoZSBhY3RpdmUgc3BhbiBpcyBpbnZhbGlkLCB3ZSB3YW50IHRvIGlnbm9yZSBpdCBhcyBwYXJlbnQuXG4gKiBUaGlzIGFsaWducyB3aXRoIGhvdyBvdGVsIHRyYWNlcnMgYW5kIGRlZmF1bHQgc2FtcGxlcnMgaGFuZGxlIHRoZXNlIGNhc2VzLlxuICovXG5mdW5jdGlvbiBnZXRWYWxpZFNwYW4oY29udGV4dCkge1xuICBjb25zdCBzcGFuID0gYXBpLnRyYWNlLmdldFNwYW4oY29udGV4dCk7XG4gIHJldHVybiBzcGFuICYmIGFwaS5pc1NwYW5Db250ZXh0VmFsaWQoc3Bhbi5zcGFuQ29udGV4dCgpKSA/IHNwYW4gOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydHMuZ2V0Q2xpZW50ID0gY29yZS5nZXRDbGllbnQ7XG5leHBvcnRzLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbiA9IGNvcmUuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuO1xuZXhwb3J0cy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX0dSQVBIUUxfT1BFUkFUSU9OID0gU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9HUkFQSFFMX09QRVJBVElPTjtcbmV4cG9ydHMuU2VudHJ5UHJvcGFnYXRvciA9IFNlbnRyeVByb3BhZ2F0b3I7XG5leHBvcnRzLlNlbnRyeVNhbXBsZXIgPSBTZW50cnlTYW1wbGVyO1xuZXhwb3J0cy5TZW50cnlTcGFuUHJvY2Vzc29yID0gU2VudHJ5U3BhblByb2Nlc3NvcjtcbmV4cG9ydHMuY29udGludWVUcmFjZSA9IGNvbnRpbnVlVHJhY2U7XG5leHBvcnRzLmVuaGFuY2VEc2NXaXRoT3BlblRlbGVtZXRyeVJvb3RTcGFuTmFtZSA9IGVuaGFuY2VEc2NXaXRoT3BlblRlbGVtZXRyeVJvb3RTcGFuTmFtZTtcbmV4cG9ydHMuZ2V0QWN0aXZlU3BhbiA9IGdldEFjdGl2ZVNwYW47XG5leHBvcnRzLmdldFJlcXVlc3RTcGFuRGF0YSA9IGdldFJlcXVlc3RTcGFuRGF0YTtcbmV4cG9ydHMuZ2V0U2NvcGVzRnJvbUNvbnRleHQgPSBnZXRTY29wZXNGcm9tQ29udGV4dDtcbmV4cG9ydHMuZ2V0U3BhbktpbmQgPSBnZXRTcGFuS2luZDtcbmV4cG9ydHMuZ2V0VHJhY2VDb250ZXh0Rm9yU2NvcGUgPSBnZXRUcmFjZUNvbnRleHRGb3JTY29wZTtcbmV4cG9ydHMuaXNTZW50cnlSZXF1ZXN0U3BhbiA9IGlzU2VudHJ5UmVxdWVzdFNwYW47XG5leHBvcnRzLm9wZW5UZWxlbWV0cnlTZXR1cENoZWNrID0gb3BlblRlbGVtZXRyeVNldHVwQ2hlY2s7XG5leHBvcnRzLnNldE9wZW5UZWxlbWV0cnlDb250ZXh0QXN5bmNDb250ZXh0U3RyYXRlZ3kgPSBzZXRPcGVuVGVsZW1ldHJ5Q29udGV4dEFzeW5jQ29udGV4dFN0cmF0ZWd5O1xuZXhwb3J0cy5zZXR1cEV2ZW50Q29udGV4dFRyYWNlID0gc2V0dXBFdmVudENvbnRleHRUcmFjZTtcbmV4cG9ydHMuc2hvdWxkUHJvcGFnYXRlVHJhY2VGb3JVcmwgPSBzaG91bGRQcm9wYWdhdGVUcmFjZUZvclVybDtcbmV4cG9ydHMuc3Bhbkhhc0F0dHJpYnV0ZXMgPSBzcGFuSGFzQXR0cmlidXRlcztcbmV4cG9ydHMuc3Bhbkhhc0V2ZW50cyA9IHNwYW5IYXNFdmVudHM7XG5leHBvcnRzLnNwYW5IYXNLaW5kID0gc3Bhbkhhc0tpbmQ7XG5leHBvcnRzLnNwYW5IYXNOYW1lID0gc3Bhbkhhc05hbWU7XG5leHBvcnRzLnNwYW5IYXNQYXJlbnRJZCA9IHNwYW5IYXNQYXJlbnRJZDtcbmV4cG9ydHMuc3Bhbkhhc1N0YXR1cyA9IHNwYW5IYXNTdGF0dXM7XG5leHBvcnRzLnN0YXJ0SW5hY3RpdmVTcGFuID0gc3RhcnRJbmFjdGl2ZVNwYW47XG5leHBvcnRzLnN0YXJ0U3BhbiA9IHN0YXJ0U3BhbjtcbmV4cG9ydHMuc3RhcnRTcGFuTWFudWFsID0gc3RhcnRTcGFuTWFudWFsO1xuZXhwb3J0cy5zdXBwcmVzc1RyYWNpbmcgPSBzdXBwcmVzc1RyYWNpbmc7XG5leHBvcnRzLndpdGhBY3RpdmVTcGFuID0gd2l0aEFjdGl2ZVNwYW47XG5leHBvcnRzLndyYXBDbGllbnRDbGFzcyA9IHdyYXBDbGllbnRDbGFzcztcbmV4cG9ydHMud3JhcENvbnRleHRNYW5hZ2VyQ2xhc3MgPSB3cmFwQ29udGV4dE1hbmFnZXJDbGFzcztcbmV4cG9ydHMud3JhcFNhbXBsaW5nRGVjaXNpb24gPSB3cmFwU2FtcGxpbmdEZWNpc2lvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@sentry+opentelemetry@10.17.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.1_lnanjtbeaorg7cpyd6d5aj7lji/node_modules/@sentry/opentelemetry/build/cjs/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@sentry+opentelemetry@10.17.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.1_lnanjtbeaorg7cpyd6d5aj7lji/node_modules/@sentry/opentelemetry/build/cjs/index.js":
/*!***************************************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@sentry+opentelemetry@10.17.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.1_lnanjtbeaorg7cpyd6d5aj7lji/node_modules/@sentry/opentelemetry/build/cjs/index.js ***!
  \***************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst semanticConventions = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.37.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nconst core = __webpack_require__(/*! @sentry/core */ \"(ssr)/../../node_modules/.pnpm/@sentry+core@10.17.0/node_modules/@sentry/core/build/cjs/index.js\");\nconst api = __webpack_require__(/*! @opentelemetry/api */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst core$1 = __webpack_require__(/*! @opentelemetry/core */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+core@2.1.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\nconst sdkTraceBase = __webpack_require__(/*! @opentelemetry/sdk-trace-base */ \"(ssr)/../../node_modules/.pnpm/@opentelemetry+sdk-trace-base@2.1.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/index.js\");\n\n/** If this attribute is true, it means that the parent is a remote span. */\nconst SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE = 'sentry.parentIsRemote';\n\n// These are not standardized yet, but used by the graphql instrumentation\nconst SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION = 'sentry.graphql.operation';\n\n/**\n * Get the parent span id from a span.\n * In OTel v1, the parent span id is accessed as `parentSpanId`\n * In OTel v2, the parent span id is accessed as `spanId` on the `parentSpanContext`\n */\nfunction getParentSpanId(span) {\n  if ('parentSpanId' in span) {\n    return span.parentSpanId ;\n  } else if ('parentSpanContext' in span) {\n    return (span.parentSpanContext )?.spanId;\n  }\n\n  return undefined;\n}\n\n/**\n * Check if a given span has attributes.\n * This is necessary because the base `Span` type does not have attributes,\n * so in places where we are passed a generic span, we need to check if we want to access them.\n */\nfunction spanHasAttributes(\n  span,\n) {\n  const castSpan = span ;\n  return !!castSpan.attributes && typeof castSpan.attributes === 'object';\n}\n\n/**\n * Check if a given span has a kind.\n * This is necessary because the base `Span` type does not have a kind,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasKind(span) {\n  const castSpan = span ;\n  return typeof castSpan.kind === 'number';\n}\n\n/**\n * Check if a given span has a status.\n * This is necessary because the base `Span` type does not have a status,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasStatus(\n  span,\n) {\n  const castSpan = span ;\n  return !!castSpan.status;\n}\n\n/**\n * Check if a given span has a name.\n * This is necessary because the base `Span` type does not have a name,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasName(span) {\n  const castSpan = span ;\n  return !!castSpan.name;\n}\n\n/**\n * Check if a given span has a kind.\n * This is necessary because the base `Span` type does not have a kind,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasParentId(\n  span,\n) {\n  const castSpan = span ;\n  return !!getParentSpanId(castSpan);\n}\n\n/**\n * Check if a given span has events.\n * This is necessary because the base `Span` type does not have events,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasEvents(\n  span,\n) {\n  const castSpan = span ;\n  return Array.isArray(castSpan.events);\n}\n\n/**\n * Get sanitizied request data from an OTEL span.\n */\nfunction getRequestSpanData(span) {\n  // The base `Span` type has no `attributes`, so we need to guard here against that\n  if (!spanHasAttributes(span)) {\n    return {};\n  }\n\n  // eslint-disable-next-line deprecation/deprecation\n  const maybeUrlAttribute = (span.attributes[semanticConventions.ATTR_URL_FULL] || span.attributes[semanticConventions.SEMATTRS_HTTP_URL])\n\n;\n\n  const data = {\n    url: maybeUrlAttribute,\n    // eslint-disable-next-line deprecation/deprecation\n    'http.method': (span.attributes[semanticConventions.ATTR_HTTP_REQUEST_METHOD] || span.attributes[semanticConventions.SEMATTRS_HTTP_METHOD])\n\n,\n  };\n\n  // Default to GET if URL is set but method is not\n  if (!data['http.method'] && data.url) {\n    data['http.method'] = 'GET';\n  }\n\n  try {\n    if (typeof maybeUrlAttribute === 'string') {\n      const url = core.parseUrl(maybeUrlAttribute);\n\n      data.url = core.getSanitizedUrlString(url);\n\n      if (url.search) {\n        data['http.query'] = url.search;\n      }\n      if (url.hash) {\n        data['http.fragment'] = url.hash;\n      }\n    }\n  } catch {\n    // ignore\n  }\n\n  return data;\n}\n\n// Typescript complains if we do not use `...args: any[]` for the mixin, with:\n// A mixin class must have a constructor with a single rest parameter of type 'any[]'.ts(2545)\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\n * Wrap an Client class with things we need for OpenTelemetry support.\n * Make sure that the Client class passed in is non-abstract!\n *\n * Usage:\n * const OpenTelemetryClient = getWrappedClientClass(NodeClient);\n * const client = new OpenTelemetryClient(options);\n */\nfunction wrapClientClass\n\n(ClientClass) {\n  // @ts-expect-error We just assume that this is non-abstract, if you pass in an abstract class this would make it non-abstract\n  class OpenTelemetryClient extends ClientClass  {\n\n     constructor(...args) {\n      super(...args);\n    }\n\n    /** Get the OTEL tracer. */\n     get tracer() {\n      if (this._tracer) {\n        return this._tracer;\n      }\n\n      const name = '@sentry/opentelemetry';\n      const version = core.SDK_VERSION;\n      const tracer = api.trace.getTracer(name, version);\n      this._tracer = tracer;\n\n      return tracer;\n    }\n\n    /**\n     * @inheritDoc\n     */\n     async flush(timeout) {\n      const provider = this.traceProvider;\n      await provider?.forceFlush();\n      return super.flush(timeout);\n    }\n  }\n\n  return OpenTelemetryClient ;\n}\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\n/**\n * Get the span kind from a span.\n * For whatever reason, this is not public API on the generic \"Span\" type,\n * so we need to check if we actually have a `SDKTraceBaseSpan` where we can fetch this from.\n * Otherwise, we fall back to `SpanKind.INTERNAL`.\n */\nfunction getSpanKind(span) {\n  if (spanHasKind(span)) {\n    return span.kind;\n  }\n\n  return api.SpanKind.INTERNAL;\n}\n\nconst SENTRY_TRACE_HEADER = 'sentry-trace';\nconst SENTRY_BAGGAGE_HEADER = 'baggage';\n\nconst SENTRY_TRACE_STATE_DSC = 'sentry.dsc';\nconst SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING = 'sentry.sampled_not_recording';\nconst SENTRY_TRACE_STATE_URL = 'sentry.url';\nconst SENTRY_TRACE_STATE_SAMPLE_RAND = 'sentry.sample_rand';\nconst SENTRY_TRACE_STATE_SAMPLE_RATE = 'sentry.sample_rate';\n\nconst SENTRY_SCOPES_CONTEXT_KEY = api.createContextKey('sentry_scopes');\n\nconst SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY = api.createContextKey('sentry_fork_isolation_scope');\n\nconst SENTRY_FORK_SET_SCOPE_CONTEXT_KEY = api.createContextKey('sentry_fork_set_scope');\n\nconst SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY = api.createContextKey('sentry_fork_set_isolation_scope');\n\nconst SCOPE_CONTEXT_FIELD = '_scopeContext';\n\n/**\n * Try to get the current scopes from the given OTEL context.\n * This requires a Context Manager that was wrapped with getWrappedContextManager.\n */\nfunction getScopesFromContext(context) {\n  return context.getValue(SENTRY_SCOPES_CONTEXT_KEY) ;\n}\n\n/**\n * Set the current scopes on an OTEL context.\n * This will return a forked context with the Propagation Context set.\n */\nfunction setScopesOnContext(context, scopes) {\n  return context.setValue(SENTRY_SCOPES_CONTEXT_KEY, scopes);\n}\n\n/**\n * Set the context on the scope so we can later look it up.\n * We need this to get the context from the scope in the `trace` functions.\n */\nfunction setContextOnScope(scope, context) {\n  core.addNonEnumerableProperty(scope, SCOPE_CONTEXT_FIELD, context);\n}\n\n/**\n * Get the context related to a scope.\n */\nfunction getContextFromScope(scope) {\n  return (scope )[SCOPE_CONTEXT_FIELD];\n}\n\n/**\n *\n * @param otelSpan Checks whether a given OTEL Span is an http request to sentry.\n * @returns boolean\n */\nfunction isSentryRequestSpan(span) {\n  if (!spanHasAttributes(span)) {\n    return false;\n  }\n\n  const { attributes } = span;\n\n  // `ATTR_URL_FULL` is the new attribute, but we still support the old one, `ATTR_HTTP_URL`, for now.\n  // eslint-disable-next-line deprecation/deprecation\n  const httpUrl = attributes[semanticConventions.SEMATTRS_HTTP_URL] || attributes[semanticConventions.ATTR_URL_FULL];\n\n  if (!httpUrl) {\n    return false;\n  }\n\n  return core.isSentryRequestUrl(httpUrl.toString(), core.getClient());\n}\n\n/**\n * OpenTelemetry only knows about SAMPLED or NONE decision,\n * but for us it is important to differentiate between unset and unsampled.\n *\n * Both of these are identified as `traceFlags === TracegFlags.NONE`,\n * but we additionally look at a special trace state to differentiate between them.\n */\nfunction getSamplingDecision(spanContext) {\n  const { traceFlags, traceState } = spanContext;\n\n  const sampledNotRecording = traceState ? traceState.get(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING) === '1' : false;\n\n  // If trace flag is `SAMPLED`, we interpret this as sampled\n  // If it is `NONE`, it could mean either it was sampled to be not recorder, or that it was not sampled at all\n  // For us this is an important difference, sow e look at the SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING\n  // to identify which it is\n  if (traceFlags === api.TraceFlags.SAMPLED) {\n    return true;\n  }\n\n  if (sampledNotRecording) {\n    return false;\n  }\n\n  // Fall back to DSC as a last resort, that may also contain `sampled`...\n  const dscString = traceState ? traceState.get(SENTRY_TRACE_STATE_DSC) : undefined;\n  const dsc = dscString ? core.baggageHeaderToDynamicSamplingContext(dscString) : undefined;\n\n  if (dsc?.sampled === 'true') {\n    return true;\n  }\n  if (dsc?.sampled === 'false') {\n    return false;\n  }\n\n  return undefined;\n}\n\n/**\n * Infer the op & description for a set of name, attributes and kind of a span.\n */\nfunction inferSpanData(spanName, attributes, kind) {\n  // if http.method exists, this is an http request span\n  // eslint-disable-next-line deprecation/deprecation\n  const httpMethod = attributes[semanticConventions.ATTR_HTTP_REQUEST_METHOD] || attributes[semanticConventions.SEMATTRS_HTTP_METHOD];\n  if (httpMethod) {\n    return descriptionForHttpMethod({ attributes, name: spanName, kind }, httpMethod);\n  }\n\n  // eslint-disable-next-line deprecation/deprecation\n  const dbSystem = attributes[semanticConventions.SEMATTRS_DB_SYSTEM];\n  const opIsCache =\n    typeof attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_OP] === 'string' &&\n    attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_OP].startsWith('cache.');\n\n  // If db.type exists then this is a database call span\n  // If the Redis DB is used as a cache, the span description should not be changed\n  if (dbSystem && !opIsCache) {\n    return descriptionForDbSystem({ attributes, name: spanName });\n  }\n\n  const customSourceOrRoute = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === 'custom' ? 'custom' : 'route';\n\n  // If rpc.service exists then this is a rpc call span.\n  // eslint-disable-next-line deprecation/deprecation\n  const rpcService = attributes[semanticConventions.SEMATTRS_RPC_SERVICE];\n  if (rpcService) {\n    return {\n      ...getUserUpdatedNameAndSource(spanName, attributes, 'route'),\n      op: 'rpc',\n    };\n  }\n\n  // If messaging.system exists then this is a messaging system span.\n  // eslint-disable-next-line deprecation/deprecation\n  const messagingSystem = attributes[semanticConventions.SEMATTRS_MESSAGING_SYSTEM];\n  if (messagingSystem) {\n    return {\n      ...getUserUpdatedNameAndSource(spanName, attributes, customSourceOrRoute),\n      op: 'message',\n    };\n  }\n\n  // If faas.trigger exists then this is a function as a service span.\n  // eslint-disable-next-line deprecation/deprecation\n  const faasTrigger = attributes[semanticConventions.SEMATTRS_FAAS_TRIGGER];\n  if (faasTrigger) {\n    return {\n      ...getUserUpdatedNameAndSource(spanName, attributes, customSourceOrRoute),\n      op: faasTrigger.toString(),\n    };\n  }\n\n  return { op: undefined, description: spanName, source: 'custom' };\n}\n\n/**\n * Extract better op/description from an otel span.\n *\n * Does not overwrite the span name if the source is already set to custom to ensure\n * that user-updated span names are preserved. In this case, we only adjust the op but\n * leave span description and source unchanged.\n *\n * Based on https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/7422ce2a06337f68a59b552b8c5a2ac125d6bae5/exporter/sentryexporter/sentry_exporter.go#L306\n */\nfunction parseSpanDescription(span) {\n  const attributes = spanHasAttributes(span) ? span.attributes : {};\n  const name = spanHasName(span) ? span.name : '<unknown>';\n  const kind = getSpanKind(span);\n\n  return inferSpanData(name, attributes, kind);\n}\n\nfunction descriptionForDbSystem({ attributes, name }) {\n  // if we already have a custom name, we don't overwrite it but only set the op\n  const userDefinedName = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n  if (typeof userDefinedName === 'string') {\n    return {\n      op: 'db',\n      description: userDefinedName,\n      source: (attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] ) || 'custom',\n    };\n  }\n\n  // if we already have the source set to custom, we don't overwrite the span description but only set the op\n  if (attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === 'custom') {\n    return { op: 'db', description: name, source: 'custom' };\n  }\n\n  // Use DB statement (Ex \"SELECT * FROM table\") if possible as description.\n  // eslint-disable-next-line deprecation/deprecation\n  const statement = attributes[semanticConventions.SEMATTRS_DB_STATEMENT];\n\n  const description = statement ? statement.toString() : name;\n\n  return { op: 'db', description, source: 'task' };\n}\n\n/** Only exported for tests. */\nfunction descriptionForHttpMethod(\n  { name, kind, attributes },\n  httpMethod,\n) {\n  const opParts = ['http'];\n\n  switch (kind) {\n    case api.SpanKind.CLIENT:\n      opParts.push('client');\n      break;\n    case api.SpanKind.SERVER:\n      opParts.push('server');\n      break;\n  }\n\n  // Spans for HTTP requests we have determined to be prefetch requests will have a `.prefetch` postfix in the op\n  if (attributes['sentry.http.prefetch']) {\n    opParts.push('prefetch');\n  }\n\n  const { urlPath, url, query, fragment, hasRoute } = getSanitizedUrl(attributes, kind);\n\n  if (!urlPath) {\n    return { ...getUserUpdatedNameAndSource(name, attributes), op: opParts.join('.') };\n  }\n\n  const graphqlOperationsAttribute = attributes[SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION];\n\n  // Ex. GET /api/users\n  const baseDescription = `${httpMethod} ${urlPath}`;\n\n  // When the http span has a graphql operation, append it to the description\n  // We add these in the graphqlIntegration\n  const inferredDescription = graphqlOperationsAttribute\n    ? `${baseDescription} (${getGraphqlOperationNamesFromAttribute(graphqlOperationsAttribute)})`\n    : baseDescription;\n\n  // If `httpPath` is a root path, then we can categorize the transaction source as route.\n  const inferredSource = hasRoute || urlPath === '/' ? 'route' : 'url';\n\n  const data = {};\n\n  if (url) {\n    data.url = url;\n  }\n  if (query) {\n    data['http.query'] = query;\n  }\n  if (fragment) {\n    data['http.fragment'] = fragment;\n  }\n\n  // If the span kind is neither client nor server, we use the original name\n  // this infers that somebody manually started this span, in which case we don't want to overwrite the name\n  const isClientOrServerKind = kind === api.SpanKind.CLIENT || kind === api.SpanKind.SERVER;\n\n  // If the span is an auto-span (=it comes from one of our instrumentations),\n  // we always want to infer the name\n  // this is necessary because some of the auto-instrumentation we use uses kind=INTERNAL\n  const origin = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] || 'manual';\n  const isManualSpan = !`${origin}`.startsWith('auto');\n\n  // If users (or in very rare occasions we) set the source to custom, we don't overwrite the name\n  const alreadyHasCustomSource = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === 'custom';\n  const customSpanName = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n\n  const useInferredDescription =\n    !alreadyHasCustomSource && customSpanName == null && (isClientOrServerKind || !isManualSpan);\n\n  const { description, source } = useInferredDescription\n    ? { description: inferredDescription, source: inferredSource }\n    : getUserUpdatedNameAndSource(name, attributes);\n\n  return {\n    op: opParts.join('.'),\n    description,\n    source,\n    data,\n  };\n}\n\nfunction getGraphqlOperationNamesFromAttribute(attr) {\n  if (Array.isArray(attr)) {\n    const sorted = attr.slice().sort();\n\n    // Up to 5 items, we just add all of them\n    if (sorted.length <= 5) {\n      return sorted.join(', ');\n    } else {\n      // Else, we add the first 5 and the diff of other operations\n      return `${sorted.slice(0, 5).join(', ')}, +${sorted.length - 5}`;\n    }\n  }\n\n  return `${attr}`;\n}\n\n/** Exported for tests only */\nfunction getSanitizedUrl(\n  attributes,\n  kind,\n)\n\n {\n  // This is the relative path of the URL, e.g. /sub\n  // eslint-disable-next-line deprecation/deprecation\n  const httpTarget = attributes[semanticConventions.SEMATTRS_HTTP_TARGET];\n  // This is the full URL, including host & query params etc., e.g. https://example.com/sub?foo=bar\n  // eslint-disable-next-line deprecation/deprecation\n  const httpUrl = attributes[semanticConventions.SEMATTRS_HTTP_URL] || attributes[semanticConventions.ATTR_URL_FULL];\n  // This is the normalized route name - may not always be available!\n  const httpRoute = attributes[semanticConventions.ATTR_HTTP_ROUTE];\n\n  const parsedUrl = typeof httpUrl === 'string' ? core.parseUrl(httpUrl) : undefined;\n  const url = parsedUrl ? core.getSanitizedUrlString(parsedUrl) : undefined;\n  const query = parsedUrl?.search || undefined;\n  const fragment = parsedUrl?.hash || undefined;\n\n  if (typeof httpRoute === 'string') {\n    return { urlPath: httpRoute, url, query, fragment, hasRoute: true };\n  }\n\n  if (kind === api.SpanKind.SERVER && typeof httpTarget === 'string') {\n    return { urlPath: core.stripUrlQueryAndFragment(httpTarget), url, query, fragment, hasRoute: false };\n  }\n\n  if (parsedUrl) {\n    return { urlPath: url, url, query, fragment, hasRoute: false };\n  }\n\n  // fall back to target even for client spans, if no URL is present\n  if (typeof httpTarget === 'string') {\n    return { urlPath: core.stripUrlQueryAndFragment(httpTarget), url, query, fragment, hasRoute: false };\n  }\n\n  return { urlPath: undefined, url, query, fragment, hasRoute: false };\n}\n\n/**\n * Because Otel instrumentation sometimes mutates span names via `span.updateName`, the only way\n * to ensure that a user-set span name is preserved is to store it as a tmp attribute on the span.\n * We delete this attribute once we're done with it when preparing the event envelope.\n *\n * This temp attribute always takes precedence over the original name.\n *\n * We also need to take care of setting the correct source. Users can always update the source\n * after updating the name, so we need to respect that.\n *\n * @internal exported only for testing\n */\nfunction getUserUpdatedNameAndSource(\n  originalName,\n  attributes,\n  fallbackSource = 'custom',\n)\n\n {\n  const source = (attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] ) || fallbackSource;\n  const description = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n\n  if (description && typeof description === 'string') {\n    return {\n      description,\n      source,\n    };\n  }\n\n  return { description: originalName, source };\n}\n\n/**\n * Setup a DSC handler on the passed client,\n * ensuring that the transaction name is inferred from the span correctly.\n */\nfunction enhanceDscWithOpenTelemetryRootSpanName(client) {\n  client.on('createDsc', (dsc, rootSpan) => {\n    if (!rootSpan) {\n      return;\n    }\n\n    // We want to overwrite the transaction on the DSC that is created by default in core\n    // The reason for this is that we want to infer the span name, not use the initial one\n    // Otherwise, we'll get names like \"GET\" instead of e.g. \"GET /foo\"\n    // `parseSpanDescription` takes the attributes of the span into account for the name\n    // This mutates the passed-in DSC\n\n    const jsonSpan = core.spanToJSON(rootSpan);\n    const attributes = jsonSpan.data;\n    const source = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n\n    const { description } = spanHasName(rootSpan) ? parseSpanDescription(rootSpan) : { description: undefined };\n    if (source !== 'url' && description) {\n      dsc.transaction = description;\n    }\n\n    // Also ensure sampling decision is correctly inferred\n    // In core, we use `spanIsSampled`, which just looks at the trace flags\n    // but in OTEL, we use a slightly more complex logic to be able to differntiate between unsampled and deferred sampling\n    if (core.hasSpansEnabled()) {\n      const sampled = getSamplingDecision(rootSpan.spanContext());\n      dsc.sampled = sampled == undefined ? undefined : String(sampled);\n    }\n  });\n}\n\n/**\n * Returns the currently active span.\n */\nfunction getActiveSpan() {\n  return api.trace.getActiveSpan();\n}\n\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nconst DEBUG_BUILD = (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__);\n\n/**\n * Generate a TraceState for the given data.\n */\nfunction makeTraceState({\n  dsc,\n  sampled,\n}\n\n) {\n  // We store the DSC as OTEL trace state on the span context\n  const dscString = dsc ? core.dynamicSamplingContextToSentryBaggageHeader(dsc) : undefined;\n\n  const traceStateBase = new core$1.TraceState();\n\n  const traceStateWithDsc = dscString ? traceStateBase.set(SENTRY_TRACE_STATE_DSC, dscString) : traceStateBase;\n\n  // We also specifically want to store if this is sampled to be not recording,\n  // or unsampled (=could be either sampled or not)\n  return sampled === false ? traceStateWithDsc.set(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING, '1') : traceStateWithDsc;\n}\n\nconst setupElements = new Set();\n\n/** Get all the OpenTelemetry elements that have been set up. */\nfunction openTelemetrySetupCheck() {\n  return Array.from(setupElements);\n}\n\n/** Mark an OpenTelemetry element as setup. */\nfunction setIsSetup(element) {\n  setupElements.add(element);\n}\n\n/**\n * Injects and extracts `sentry-trace` and `baggage` headers from carriers.\n */\nclass SentryPropagator extends core$1.W3CBaggagePropagator {\n  /** A map of URLs that have already been checked for if they match tracePropagationTargets. */\n\n   constructor() {\n    super();\n    setIsSetup('SentryPropagator');\n\n    // We're caching results so we don't have to recompute regexp every time we create a request.\n    this._urlMatchesTargetsMap = new core.LRUMap(100);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   inject(context, carrier, setter) {\n    if (core$1.isTracingSuppressed(context)) {\n      DEBUG_BUILD && core.debug.log('[Tracing] Not injecting trace data for url because tracing is suppressed.');\n      return;\n    }\n\n    const activeSpan = api.trace.getSpan(context);\n    const url = activeSpan && getCurrentURL(activeSpan);\n\n    const tracePropagationTargets = core.getClient()?.getOptions()?.tracePropagationTargets;\n    if (!shouldPropagateTraceForUrl(url, tracePropagationTargets, this._urlMatchesTargetsMap)) {\n      DEBUG_BUILD &&\n        core.debug.log('[Tracing] Not injecting trace data for url because it does not match tracePropagationTargets:', url);\n      return;\n    }\n\n    const existingBaggageHeader = getExistingBaggage(carrier);\n    let baggage = api.propagation.getBaggage(context) || api.propagation.createBaggage({});\n\n    const { dynamicSamplingContext, traceId, spanId, sampled } = getInjectionData(context);\n\n    if (existingBaggageHeader) {\n      const baggageEntries = core.parseBaggageHeader(existingBaggageHeader);\n\n      if (baggageEntries) {\n        Object.entries(baggageEntries).forEach(([key, value]) => {\n          baggage = baggage.setEntry(key, { value });\n        });\n      }\n    }\n\n    if (dynamicSamplingContext) {\n      baggage = Object.entries(dynamicSamplingContext).reduce((b, [dscKey, dscValue]) => {\n        if (dscValue) {\n          return b.setEntry(`${core.SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`, { value: dscValue });\n        }\n        return b;\n      }, baggage);\n    }\n\n    // We also want to avoid setting the default OTEL trace ID, if we get that for whatever reason\n    if (traceId && traceId !== api.INVALID_TRACEID) {\n      setter.set(carrier, SENTRY_TRACE_HEADER, core.generateSentryTraceHeader(traceId, spanId, sampled));\n    }\n\n    super.inject(api.propagation.setBaggage(context, baggage), carrier, setter);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   extract(context, carrier, getter) {\n    const maybeSentryTraceHeader = getter.get(carrier, SENTRY_TRACE_HEADER);\n    const baggage = getter.get(carrier, SENTRY_BAGGAGE_HEADER);\n\n    const sentryTrace = maybeSentryTraceHeader\n      ? Array.isArray(maybeSentryTraceHeader)\n        ? maybeSentryTraceHeader[0]\n        : maybeSentryTraceHeader\n      : undefined;\n\n    // Add remote parent span context\n    // If there is no incoming trace, this will return the context as-is\n    return ensureScopesOnContext(getContextWithRemoteActiveSpan(context, { sentryTrace, baggage }));\n  }\n\n  /**\n   * @inheritDoc\n   */\n   fields() {\n    return [SENTRY_TRACE_HEADER, SENTRY_BAGGAGE_HEADER];\n  }\n}\n\nconst NOT_PROPAGATED_MESSAGE =\n  '[Tracing] Not injecting trace data for url because it does not match tracePropagationTargets:';\n\n/**\n * Check if a given URL should be propagated to or not.\n * If no url is defined, or no trace propagation targets are defined, this will always return `true`.\n * You can also optionally provide a decision map, to cache decisions and avoid repeated regex lookups.\n */\nfunction shouldPropagateTraceForUrl(\n  url,\n  tracePropagationTargets,\n  decisionMap,\n) {\n  if (typeof url !== 'string' || !tracePropagationTargets) {\n    return true;\n  }\n\n  const cachedDecision = decisionMap?.get(url);\n  if (cachedDecision !== undefined) {\n    DEBUG_BUILD && !cachedDecision && core.debug.log(NOT_PROPAGATED_MESSAGE, url);\n    return cachedDecision;\n  }\n\n  const decision = core.stringMatchesSomePattern(url, tracePropagationTargets);\n  decisionMap?.set(url, decision);\n\n  DEBUG_BUILD && !decision && core.debug.log(NOT_PROPAGATED_MESSAGE, url);\n  return decision;\n}\n\n/**\n * Get propagation injection data for the given context.\n * The additional options can be passed to override the scope and client that is otherwise derived from the context.\n */\nfunction getInjectionData(\n  context,\n  options = {},\n)\n\n {\n  const span = api.trace.getSpan(context);\n\n  // If we have a remote span, the spanId should be considered as the parentSpanId, not spanId itself\n  // Instead, we use a virtual (generated) spanId for propagation\n  if (span?.spanContext().isRemote) {\n    const spanContext = span.spanContext();\n    const dynamicSamplingContext = core.getDynamicSamplingContextFromSpan(span);\n\n    return {\n      dynamicSamplingContext,\n      traceId: spanContext.traceId,\n      spanId: undefined,\n      sampled: getSamplingDecision(spanContext), // TODO: Do we need to change something here?\n    };\n  }\n\n  // If we have a local span, we just use this\n  if (span) {\n    const spanContext = span.spanContext();\n    const dynamicSamplingContext = core.getDynamicSamplingContextFromSpan(span);\n\n    return {\n      dynamicSamplingContext,\n      traceId: spanContext.traceId,\n      spanId: spanContext.spanId,\n      sampled: getSamplingDecision(spanContext), // TODO: Do we need to change something here?\n    };\n  }\n\n  // Else we try to use the propagation context from the scope\n  // The only scenario where this should happen is when we neither have a span, nor an incoming trace\n  const scope = options.scope || getScopesFromContext(context)?.scope || core.getCurrentScope();\n  const client = options.client || core.getClient();\n\n  const propagationContext = scope.getPropagationContext();\n  const dynamicSamplingContext = client ? core.getDynamicSamplingContextFromScope(client, scope) : undefined;\n  return {\n    dynamicSamplingContext,\n    traceId: propagationContext.traceId,\n    spanId: propagationContext.propagationSpanId,\n    sampled: propagationContext.sampled,\n  };\n}\n\nfunction getContextWithRemoteActiveSpan(\n  ctx,\n  { sentryTrace, baggage },\n) {\n  const propagationContext = core.propagationContextFromHeaders(sentryTrace, baggage);\n\n  const { traceId, parentSpanId, sampled, dsc } = propagationContext;\n\n  const client = core.getClient();\n  const incomingDsc = core.baggageHeaderToDynamicSamplingContext(baggage);\n\n  // We only want to set the virtual span if we are continuing a concrete trace\n  // Otherwise, we ignore the incoming trace here, e.g. if we have no trace headers\n  if (!parentSpanId || (client && !core.shouldContinueTrace(client, incomingDsc?.org_id))) {\n    return ctx;\n  }\n\n  const spanContext = generateRemoteSpanContext({\n    traceId,\n    spanId: parentSpanId,\n    sampled,\n    dsc,\n  });\n\n  return api.trace.setSpanContext(ctx, spanContext);\n}\n\n/**\n * Takes trace strings and propagates them as a remote active span.\n * This should be used in addition to `continueTrace` in OTEL-powered environments.\n */\nfunction continueTraceAsRemoteSpan(\n  ctx,\n  options,\n  callback,\n) {\n  const ctxWithSpanContext = ensureScopesOnContext(getContextWithRemoteActiveSpan(ctx, options));\n\n  return api.context.with(ctxWithSpanContext, callback);\n}\n\nfunction ensureScopesOnContext(ctx) {\n  // If there are no scopes yet on the context, ensure we have them\n  const scopes = getScopesFromContext(ctx);\n  const newScopes = {\n    // If we have no scope here, this is most likely either the root context or a context manually derived from it\n    // In this case, we want to fork the current scope, to ensure we do not pollute the root scope\n    scope: scopes ? scopes.scope : core.getCurrentScope().clone(),\n    isolationScope: scopes ? scopes.isolationScope : core.getIsolationScope(),\n  };\n\n  return setScopesOnContext(ctx, newScopes);\n}\n\n/** Try to get the existing baggage header so we can merge this in. */\nfunction getExistingBaggage(carrier) {\n  try {\n    const baggage = (carrier )[SENTRY_BAGGAGE_HEADER];\n    return Array.isArray(baggage) ? baggage.join(',') : baggage;\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * It is pretty tricky to get access to the outgoing request URL of a request in the propagator.\n * As we only have access to the context of the span to be sent and the carrier (=headers),\n * but the span may be unsampled and thus have no attributes.\n *\n * So we use the following logic:\n * 1. If we have an active span, we check if it has a URL attribute.\n * 2. Else, if the active span has no URL attribute (e.g. it is unsampled), we check a special trace state (which we set in our sampler).\n */\nfunction getCurrentURL(span) {\n  const spanData = core.spanToJSON(span).data;\n  // `ATTR_URL_FULL` is the new attribute, but we still support the old one, `SEMATTRS_HTTP_URL`, for now.\n  // eslint-disable-next-line deprecation/deprecation\n  const urlAttribute = spanData[semanticConventions.SEMATTRS_HTTP_URL] || spanData[semanticConventions.ATTR_URL_FULL];\n  if (typeof urlAttribute === 'string') {\n    return urlAttribute;\n  }\n\n  // Also look at the traceState, which we may set in the sampler even for unsampled spans\n  const urlTraceState = span.spanContext().traceState?.get(SENTRY_TRACE_STATE_URL);\n  if (urlTraceState) {\n    return urlTraceState;\n  }\n\n  return undefined;\n}\n\nfunction generateRemoteSpanContext({\n  spanId,\n  traceId,\n  sampled,\n  dsc,\n}\n\n) {\n  // We store the DSC as OTEL trace state on the span context\n  const traceState = makeTraceState({\n    dsc,\n    sampled,\n  });\n\n  const spanContext = {\n    traceId,\n    spanId,\n    isRemote: true,\n    traceFlags: sampled ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE,\n    traceState,\n  };\n\n  return spanContext;\n}\n\n/**\n * Wraps a function with a transaction/span and finishes the span after the function is done.\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * If you want to create a span that is not set as active, use {@link startInactiveSpan}.\n *\n * You'll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startSpan(options, callback) {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !api.trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? core$1.suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    return tracer.startActiveSpan(name, spanOptions, ctx, span => {\n      return core.handleCallbackErrors(\n        () => callback(span),\n        () => {\n          // Only set the span status to ERROR when there wasn't any status set before, in order to avoid stomping useful span statuses\n          if (core.spanToJSON(span).status === undefined) {\n            span.setStatus({ code: api.SpanStatusCode.ERROR });\n          }\n        },\n        () => span.end(),\n      );\n    });\n  });\n}\n\n/**\n * Similar to `Sentry.startSpan`. Wraps a function with a span, but does not finish the span\n * after the function is done automatically. You'll have to call `span.end()` manually.\n *\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * You'll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startSpanManual(\n  options,\n  callback,\n) {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !api.trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? core$1.suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    return tracer.startActiveSpan(name, spanOptions, ctx, span => {\n      return core.handleCallbackErrors(\n        () => callback(span, () => span.end()),\n        () => {\n          // Only set the span status to ERROR when there wasn't any status set before, in order to avoid stomping useful span statuses\n          if (core.spanToJSON(span).status === undefined) {\n            span.setStatus({ code: api.SpanStatusCode.ERROR });\n          }\n        },\n      );\n    });\n  });\n}\n\n/**\n * Creates a span. This span is not set as active, so will not get automatic instrumentation spans\n * as children or be able to be accessed via `Sentry.getActiveSpan()`.\n *\n * If you want to create a span that is set as active, use {@link startSpan}.\n *\n * This function will always return a span,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startInactiveSpan(options) {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !api.trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? core$1.suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    const span = tracer.startSpan(name, spanOptions, ctx);\n\n    return span;\n  });\n}\n\n/**\n * Forks the current scope and sets the provided span as active span in the context of the provided callback. Can be\n * passed `null` to start an entirely new span tree.\n *\n * @param span Spans started in the context of the provided callback will be children of this span. If `null` is passed,\n * spans started within the callback will be root spans.\n * @param callback Execution context in which the provided span will be active. Is passed the newly forked scope.\n * @returns the value returned from the provided callback function.\n */\nfunction withActiveSpan(span, callback) {\n  const newContextWithActiveSpan = span ? api.trace.setSpan(api.context.active(), span) : api.trace.deleteSpan(api.context.active());\n  return api.context.with(newContextWithActiveSpan, () => callback(core.getCurrentScope()));\n}\n\nfunction getTracer() {\n  const client = core.getClient();\n  return client?.tracer || api.trace.getTracer('@sentry/opentelemetry', core.SDK_VERSION);\n}\n\nfunction getSpanOptions(options) {\n  const { startTime, attributes, kind, op, links } = options;\n\n  // OTEL expects timestamps in ms, not seconds\n  const fixedStartTime = typeof startTime === 'number' ? ensureTimestampInMilliseconds(startTime) : startTime;\n\n  return {\n    attributes: op\n      ? {\n          [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n          ...attributes,\n        }\n      : attributes,\n    kind,\n    links,\n    startTime: fixedStartTime,\n  };\n}\n\nfunction ensureTimestampInMilliseconds(timestamp) {\n  const isMs = timestamp < 9999999999;\n  return isMs ? timestamp * 1000 : timestamp;\n}\n\nfunction getContext(scope, forceTransaction) {\n  const ctx = getContextForScope(scope);\n  const parentSpan = api.trace.getSpan(ctx);\n\n  // In the case that we have no parent span, we start a new trace\n  // Note that if we continue a trace, we'll always have a remote parent span here anyhow\n  if (!parentSpan) {\n    return ctx;\n  }\n\n  // If we don't want to force a transaction, and we have a parent span, all good, we just return as-is!\n  if (!forceTransaction) {\n    return ctx;\n  }\n\n  // Else, if we do have a parent span but want to force a transaction, we have to simulate a \"root\" context\n\n  // Else, we need to do two things:\n  // 1. Unset the parent span from the context, so we'll create a new root span\n  // 2. Ensure the propagation context is correct, so we'll continue from the parent span\n  const ctxWithoutSpan = api.trace.deleteSpan(ctx);\n\n  const { spanId, traceId } = parentSpan.spanContext();\n  const sampled = getSamplingDecision(parentSpan.spanContext());\n\n  // In this case, when we are forcing a transaction, we want to treat this like continuing an incoming trace\n  // so we set the traceState according to the root span\n  const rootSpan = core.getRootSpan(parentSpan);\n  const dsc = core.getDynamicSamplingContextFromSpan(rootSpan);\n\n  const traceState = makeTraceState({\n    dsc,\n    sampled,\n  });\n\n  const spanOptions = {\n    traceId,\n    spanId,\n    isRemote: true,\n    traceFlags: sampled ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE,\n    traceState,\n  };\n\n  const ctxWithSpanContext = api.trace.setSpanContext(ctxWithoutSpan, spanOptions);\n\n  return ctxWithSpanContext;\n}\n\nfunction getContextForScope(scope) {\n  if (scope) {\n    const ctx = getContextFromScope(scope);\n    if (ctx) {\n      return ctx;\n    }\n  }\n\n  return api.context.active();\n}\n\n/**\n * Continue a trace from `sentry-trace` and `baggage` values.\n * These values can be obtained from incoming request headers, or in the browser from `<meta name=\"sentry-trace\">`\n * and `<meta name=\"baggage\">` HTML tags.\n *\n * Spans started with `startSpan`, `startSpanManual` and `startInactiveSpan`, within the callback will automatically\n * be attached to the incoming trace.\n *\n * This is a custom version of `continueTrace` that is used in OTEL-powered environments.\n * It propagates the trace as a remote span, in addition to setting it on the propagation context.\n */\nfunction continueTrace(options, callback) {\n  return continueTraceAsRemoteSpan(api.context.active(), options, callback);\n}\n\n/**\n * Get the trace context for a given scope.\n * We have a custom implementation here because we need an OTEL-specific way to get the span from a scope.\n */\nfunction getTraceContextForScope(\n  client,\n  scope,\n) {\n  const ctx = getContextFromScope(scope);\n  const span = ctx && api.trace.getSpan(ctx);\n\n  const traceContext = span ? core.spanToTraceContext(span) : core.getTraceContextFromScope(scope);\n\n  const dynamicSamplingContext = span\n    ? core.getDynamicSamplingContextFromSpan(span)\n    : core.getDynamicSamplingContextFromScope(client, scope);\n  return [dynamicSamplingContext, traceContext];\n}\n\nfunction getActiveSpanWrapper(parentSpan) {\n  return parentSpan !== undefined\n    ? (callback) => {\n        return withActiveSpan(parentSpan, callback);\n      }\n    : (callback) => callback();\n}\n\n/** Suppress tracing in the given callback, ensuring no spans are generated inside of it. */\nfunction suppressTracing(callback) {\n  const ctx = core$1.suppressTracing(api.context.active());\n  return api.context.with(ctx, callback);\n}\n\n/** Ensure the `trace` context is set on all events. */\nfunction setupEventContextTrace(client) {\n  client.on('preprocessEvent', event => {\n    const span = getActiveSpan();\n    // For transaction events, this is handled separately\n    // Because the active span may not be the span that is actually the transaction event\n    if (!span || event.type === 'transaction') {\n      return;\n    }\n\n    // If event has already set `trace` context, use that one.\n    event.contexts = {\n      trace: core.spanToTraceContext(span),\n      ...event.contexts,\n    };\n\n    const rootSpan = core.getRootSpan(span);\n\n    event.sdkProcessingMetadata = {\n      dynamicSamplingContext: core.getDynamicSamplingContextFromSpan(rootSpan),\n      ...event.sdkProcessingMetadata,\n    };\n\n    return event;\n  });\n}\n\n/**\n * Otel-specific implementation of `getTraceData`.\n * @see `@sentry/core` version of `getTraceData` for more information\n */\nfunction getTraceData({\n  span,\n  scope,\n  client,\n} = {}) {\n  let ctx = (scope && getContextFromScope(scope)) ?? api.context.active();\n\n  if (span) {\n    const { scope } = core.getCapturedScopesOnSpan(span);\n    // fall back to current context if for whatever reason we can't find the one of the span\n    ctx = (scope && getContextFromScope(scope)) || api.trace.setSpan(api.context.active(), span);\n  }\n\n  const { traceId, spanId, sampled, dynamicSamplingContext } = getInjectionData(ctx, { scope, client });\n\n  return {\n    'sentry-trace': core.generateSentryTraceHeader(traceId, spanId, sampled),\n    baggage: core.dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext),\n  };\n}\n\n/**\n * Sets the async context strategy to use follow the OTEL context under the hood.\n * We handle forking a hub inside of our custom OTEL Context Manager (./otelContextManager.ts)\n */\nfunction setOpenTelemetryContextAsyncContextStrategy() {\n  function getScopes() {\n    const ctx = api.context.active();\n    const scopes = getScopesFromContext(ctx);\n\n    if (scopes) {\n      return scopes;\n    }\n\n    // fallback behavior:\n    // if, for whatever reason, we can't find scopes on the context here, we have to fix this somehow\n    return {\n      scope: core.getDefaultCurrentScope(),\n      isolationScope: core.getDefaultIsolationScope(),\n    };\n  }\n\n  function withScope(callback) {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    // as by default, we don't want to fork this, unless triggered explicitly by `withScope`\n    return api.context.with(ctx, () => {\n      return callback(getCurrentScope());\n    });\n  }\n\n  function withSetScope(scope, callback) {\n    const ctx = getContextFromScope(scope) || api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_SET_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which picks up this scope as the current scope\n    return api.context.with(ctx.setValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY, scope), () => {\n      return callback(scope);\n    });\n  }\n\n  function withIsolationScope(callback) {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    return api.context.with(ctx.setValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY, true), () => {\n      return callback(getIsolationScope());\n    });\n  }\n\n  function withSetIsolationScope(isolationScope, callback) {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    return api.context.with(ctx.setValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY, isolationScope), () => {\n      return callback(getIsolationScope());\n    });\n  }\n\n  function getCurrentScope() {\n    return getScopes().scope;\n  }\n\n  function getIsolationScope() {\n    return getScopes().isolationScope;\n  }\n\n  core.setAsyncContextStrategy({\n    withScope,\n    withSetScope,\n    withSetIsolationScope,\n    withIsolationScope,\n    getCurrentScope,\n    getIsolationScope,\n    startSpan,\n    startSpanManual,\n    startInactiveSpan,\n    getActiveSpan,\n    suppressTracing,\n    getTraceData,\n    continueTrace,\n    // The types here don't fully align, because our own `Span` type is narrower\n    // than the OTEL one - but this is OK for here, as we now we'll only have OTEL spans passed around\n    withActiveSpan: withActiveSpan ,\n  });\n}\n\n/**\n * Wrap an OpenTelemetry ContextManager in a way that ensures the context is kept in sync with the Sentry Scope.\n *\n * Usage:\n * import { AsyncLocalStorageContextManager } from '@opentelemetry/context-async-hooks';\n * const SentryContextManager = wrapContextManagerClass(AsyncLocalStorageContextManager);\n * const contextManager = new SentryContextManager();\n */\nfunction wrapContextManagerClass(\n  ContextManagerClass,\n) {\n  /**\n   * This is a custom ContextManager for OpenTelemetry, which extends the default AsyncLocalStorageContextManager.\n   * It ensures that we create new scopes per context, so that the OTEL Context & the Sentry Scope are always in sync.\n   *\n   * Note that we currently only support AsyncHooks with this,\n   * but since this should work for Node 14+ anyhow that should be good enough.\n   */\n\n  // @ts-expect-error TS does not like this, but we know this is fine\n  class SentryContextManager extends ContextManagerClass {\n     constructor(...args) {\n      super(...args);\n      setIsSetup('SentryContextManager');\n    }\n    /**\n     * Overwrite with() of the original AsyncLocalStorageContextManager\n     * to ensure we also create new scopes per context.\n     */\n     with(\n      context,\n      fn,\n      thisArg,\n      ...args\n    ) {\n      const currentScopes = getScopesFromContext(context);\n      const currentScope = currentScopes?.scope || core.getCurrentScope();\n      const currentIsolationScope = currentScopes?.isolationScope || core.getIsolationScope();\n\n      const shouldForkIsolationScope = context.getValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY) === true;\n      const scope = context.getValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY) ;\n      const isolationScope = context.getValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY) ;\n\n      const newCurrentScope = scope || currentScope.clone();\n      const newIsolationScope =\n        isolationScope || (shouldForkIsolationScope ? currentIsolationScope.clone() : currentIsolationScope);\n      const scopes = { scope: newCurrentScope, isolationScope: newIsolationScope };\n\n      const ctx1 = setScopesOnContext(context, scopes);\n\n      // Remove the unneeded values again\n      const ctx2 = ctx1\n        .deleteValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY)\n        .deleteValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY)\n        .deleteValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY);\n\n      setContextOnScope(newCurrentScope, ctx2);\n\n      return super.with(ctx2, fn, thisArg, ...args);\n    }\n  }\n\n  return SentryContextManager ;\n}\n\n/**\n * This function runs through a list of OTEL Spans, and wraps them in an `SpanNode`\n * where each node holds a reference to their parent node.\n */\nfunction groupSpansWithParents(spans) {\n  const nodeMap = new Map();\n\n  for (const span of spans) {\n    createOrUpdateSpanNodeAndRefs(nodeMap, span);\n  }\n\n  return Array.from(nodeMap, function ([_id, spanNode]) {\n    return spanNode;\n  });\n}\n\n/**\n * This returns the _local_ parent ID - `parentId` on the span may point to a remote span.\n */\nfunction getLocalParentId(span) {\n  const parentIsRemote = span.attributes[SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE] === true;\n  // If the parentId is the trace parent ID, we pretend it's undefined\n  // As this means the parent exists somewhere else\n  return !parentIsRemote ? getParentSpanId(span) : undefined;\n}\n\nfunction createOrUpdateSpanNodeAndRefs(nodeMap, span) {\n  const id = span.spanContext().spanId;\n  const parentId = getLocalParentId(span);\n\n  if (!parentId) {\n    createOrUpdateNode(nodeMap, { id, span, children: [] });\n    return;\n  }\n\n  // Else make sure to create parent node as well\n  // Note that the parent may not know it's parent _yet_, this may be updated in a later pass\n  const parentNode = createOrGetParentNode(nodeMap, parentId);\n  const node = createOrUpdateNode(nodeMap, { id, span, parentNode, children: [] });\n  parentNode.children.push(node);\n}\n\nfunction createOrGetParentNode(nodeMap, id) {\n  const existing = nodeMap.get(id);\n\n  if (existing) {\n    return existing;\n  }\n\n  return createOrUpdateNode(nodeMap, { id, children: [] });\n}\n\nfunction createOrUpdateNode(nodeMap, spanNode) {\n  const existing = nodeMap.get(spanNode.id);\n\n  // If span is already set, nothing to do here\n  if (existing?.span) {\n    return existing;\n  }\n\n  // If it exists but span is not set yet, we update it\n  if (existing && !existing.span) {\n    existing.span = spanNode.span;\n    existing.parentNode = spanNode.parentNode;\n    return existing;\n  }\n\n  // Else, we create a new one...\n  nodeMap.set(spanNode.id, spanNode);\n  return spanNode;\n}\n\n// canonicalCodesGrpcMap maps some GRPC codes to Sentry's span statuses. See description in grpc documentation.\nconst canonicalGrpcErrorCodesMap = {\n  '1': 'cancelled',\n  '2': 'unknown_error',\n  '3': 'invalid_argument',\n  '4': 'deadline_exceeded',\n  '5': 'not_found',\n  '6': 'already_exists',\n  '7': 'permission_denied',\n  '8': 'resource_exhausted',\n  '9': 'failed_precondition',\n  '10': 'aborted',\n  '11': 'out_of_range',\n  '12': 'unimplemented',\n  '13': 'internal_error',\n  '14': 'unavailable',\n  '15': 'data_loss',\n  '16': 'unauthenticated',\n} ;\n\nconst isStatusErrorMessageValid = (message) => {\n  return Object.values(canonicalGrpcErrorCodesMap).includes(message );\n};\n\n/**\n * Get a Sentry span status from an otel span.\n */\nfunction mapStatus(span) {\n  const attributes = spanHasAttributes(span) ? span.attributes : {};\n  const status = spanHasStatus(span) ? span.status : undefined;\n\n  if (status) {\n    // Since span status OK is not set by default, we give it priority: https://opentelemetry.io/docs/concepts/signals/traces/#span-status\n    if (status.code === api.SpanStatusCode.OK) {\n      return { code: core.SPAN_STATUS_OK };\n      // If the span is already marked as erroneous we return that exact status\n    } else if (status.code === api.SpanStatusCode.ERROR) {\n      if (typeof status.message === 'undefined') {\n        const inferredStatus = inferStatusFromAttributes(attributes);\n        if (inferredStatus) {\n          return inferredStatus;\n        }\n      }\n\n      if (status.message && isStatusErrorMessageValid(status.message)) {\n        return { code: core.SPAN_STATUS_ERROR, message: status.message };\n      } else {\n        return { code: core.SPAN_STATUS_ERROR, message: 'unknown_error' };\n      }\n    }\n  }\n\n  // If the span status is UNSET, we try to infer it from HTTP or GRPC status codes.\n  const inferredStatus = inferStatusFromAttributes(attributes);\n\n  if (inferredStatus) {\n    return inferredStatus;\n  }\n\n  // We default to setting the spans status to ok.\n  if (status?.code === api.SpanStatusCode.UNSET) {\n    return { code: core.SPAN_STATUS_OK };\n  } else {\n    return { code: core.SPAN_STATUS_ERROR, message: 'unknown_error' };\n  }\n}\n\nfunction inferStatusFromAttributes(attributes) {\n  // If the span status is UNSET, we try to infer it from HTTP or GRPC status codes.\n\n  // eslint-disable-next-line deprecation/deprecation\n  const httpCodeAttribute = attributes[semanticConventions.ATTR_HTTP_RESPONSE_STATUS_CODE] || attributes[semanticConventions.SEMATTRS_HTTP_STATUS_CODE];\n  // eslint-disable-next-line deprecation/deprecation\n  const grpcCodeAttribute = attributes[semanticConventions.SEMATTRS_RPC_GRPC_STATUS_CODE];\n\n  const numberHttpCode =\n    typeof httpCodeAttribute === 'number'\n      ? httpCodeAttribute\n      : typeof httpCodeAttribute === 'string'\n        ? parseInt(httpCodeAttribute)\n        : undefined;\n\n  if (typeof numberHttpCode === 'number') {\n    return core.getSpanStatusFromHttpCode(numberHttpCode);\n  }\n\n  if (typeof grpcCodeAttribute === 'string') {\n    return { code: core.SPAN_STATUS_ERROR, message: canonicalGrpcErrorCodesMap[grpcCodeAttribute] || 'unknown_error' };\n  }\n\n  return undefined;\n}\n\nconst MAX_SPAN_COUNT = 1000;\nconst DEFAULT_TIMEOUT = 300; // 5 min\n\n/**\n * A Sentry-specific exporter that converts OpenTelemetry Spans to Sentry Spans & Transactions.\n */\nclass SentrySpanExporter {\n  /*\n   * A quick explanation on the buckets: We do bucketing of finished spans for efficiency. This span exporter is\n   * accumulating spans until a root span is encountered and then it flushes all the spans that are descendants of that\n   * root span. Because it is totally in the realm of possibilities that root spans are never finished, and we don't\n   * want to accumulate spans indefinitely in memory, we need to periodically evacuate spans. Naively we could simply\n   * store the spans in an array and each time a new span comes in we could iterate through the entire array and\n   * evacuate all spans that have an end-timestamp that is older than our limit. This could get quite expensive because\n   * we would have to iterate a potentially large number of spans every time we evacuate. We want to avoid these large\n   * bursts of computation.\n   *\n   * Instead we go for a bucketing approach and put spans into buckets, based on what second\n   * (modulo the time limit) the span was put into the exporter. With buckets, when we decide to evacuate, we can\n   * iterate through the bucket entries instead, which have an upper bound of items, making the evacuation much more\n   * efficient. Cleaning up also becomes much more efficient since it simply involves de-referencing a bucket within the\n   * bucket array, and letting garbage collection take care of the rest.\n   */\n\n  // Essentially a a set of span ids that are already sent. The values are expiration\n  // times in this cache so we don't hold onto them indefinitely.\n\n  /* Internally, we use a debounced flush to give some wiggle room to the span processor to accumulate more spans. */\n\n   constructor(options\n\n) {\n    this._finishedSpanBucketSize = options?.timeout || DEFAULT_TIMEOUT;\n    this._finishedSpanBuckets = new Array(this._finishedSpanBucketSize).fill(undefined);\n    this._lastCleanupTimestampInS = Math.floor(Date.now() / 1000);\n    this._spansToBucketEntry = new WeakMap();\n    this._sentSpans = new Map();\n    this._debouncedFlush = core.debounce(this.flush.bind(this), 1, { maxWait: 100 });\n  }\n\n  /**\n   * Export a single span.\n   * This is called by the span processor whenever a span is ended.\n   */\n   export(span) {\n    const currentTimestampInS = Math.floor(Date.now() / 1000);\n\n    if (this._lastCleanupTimestampInS !== currentTimestampInS) {\n      let droppedSpanCount = 0;\n      this._finishedSpanBuckets.forEach((bucket, i) => {\n        if (bucket && bucket.timestampInS <= currentTimestampInS - this._finishedSpanBucketSize) {\n          droppedSpanCount += bucket.spans.size;\n          this._finishedSpanBuckets[i] = undefined;\n        }\n      });\n      if (droppedSpanCount > 0) {\n        DEBUG_BUILD &&\n          core.debug.log(\n            `SpanExporter dropped ${droppedSpanCount} spans because they were pending for more than ${this._finishedSpanBucketSize} seconds.`,\n          );\n      }\n      this._lastCleanupTimestampInS = currentTimestampInS;\n    }\n\n    const currentBucketIndex = currentTimestampInS % this._finishedSpanBucketSize;\n    const currentBucket = this._finishedSpanBuckets[currentBucketIndex] || {\n      timestampInS: currentTimestampInS,\n      spans: new Set(),\n    };\n    this._finishedSpanBuckets[currentBucketIndex] = currentBucket;\n    currentBucket.spans.add(span);\n    this._spansToBucketEntry.set(span, currentBucket);\n\n    // If the span doesn't have a local parent ID (it's a root span), we're gonna flush all the ended spans\n    const localParentId = getLocalParentId(span);\n    if (!localParentId || this._sentSpans.has(localParentId)) {\n      this._debouncedFlush();\n    }\n  }\n\n  /**\n   * Try to flush any pending spans immediately.\n   * This is called internally by the exporter (via _debouncedFlush),\n   * but can also be triggered externally if we force-flush.\n   */\n   flush() {\n    const finishedSpans = this._finishedSpanBuckets.flatMap(bucket => (bucket ? Array.from(bucket.spans) : []));\n\n    this._flushSentSpanCache();\n    const sentSpans = this._maybeSend(finishedSpans);\n\n    const sentSpanCount = sentSpans.size;\n    const remainingOpenSpanCount = finishedSpans.length - sentSpanCount;\n    DEBUG_BUILD &&\n      core.debug.log(\n        `SpanExporter exported ${sentSpanCount} spans, ${remainingOpenSpanCount} spans are waiting for their parent spans to finish`,\n      );\n\n    const expirationDate = Date.now() + DEFAULT_TIMEOUT * 1000;\n\n    for (const span of sentSpans) {\n      this._sentSpans.set(span.spanContext().spanId, expirationDate);\n      const bucketEntry = this._spansToBucketEntry.get(span);\n      if (bucketEntry) {\n        bucketEntry.spans.delete(span);\n      }\n    }\n    // Cancel a pending debounced flush, if there is one\n    // This can be relevant if we directly flush, circumventing the debounce\n    // in that case, we want to cancel any pending debounced flush\n    this._debouncedFlush.cancel();\n  }\n\n  /**\n   * Clear the exporter.\n   * This is called when the span processor is shut down.\n   */\n   clear() {\n    this._finishedSpanBuckets = this._finishedSpanBuckets.fill(undefined);\n    this._sentSpans.clear();\n    this._debouncedFlush.cancel();\n  }\n\n  /**\n   * Send the given spans, but only if they are part of a finished transaction.\n   *\n   * Returns the sent spans.\n   * Spans remain unsent when their parent span is not yet finished.\n   * This will happen regularly, as child spans are generally finished before their parents.\n   * But it _could_ also happen because, for whatever reason, a parent span was lost.\n   * In this case, we'll eventually need to clean this up.\n   */\n   _maybeSend(spans) {\n    const grouped = groupSpansWithParents(spans);\n    const sentSpans = new Set();\n\n    const rootNodes = this._getCompletedRootNodes(grouped);\n\n    for (const root of rootNodes) {\n      const span = root.span;\n      sentSpans.add(span);\n      const transactionEvent = createTransactionForOtelSpan(span);\n\n      // Add an attribute to the transaction event to indicate that this transaction is an orphaned transaction\n      if (root.parentNode && this._sentSpans.has(root.parentNode.id)) {\n        const traceData = transactionEvent.contexts?.trace?.data;\n        if (traceData) {\n          traceData['sentry.parent_span_already_sent'] = true;\n        }\n      }\n\n      // We'll recursively add all the child spans to this array\n      const spans = transactionEvent.spans || [];\n\n      for (const child of root.children) {\n        createAndFinishSpanForOtelSpan(child, spans, sentSpans);\n      }\n\n      // spans.sort() mutates the array, but we do not use this anymore after this point\n      // so we can safely mutate it here\n      transactionEvent.spans =\n        spans.length > MAX_SPAN_COUNT\n          ? spans.sort((a, b) => a.start_timestamp - b.start_timestamp).slice(0, MAX_SPAN_COUNT)\n          : spans;\n\n      const measurements = core.timedEventsToMeasurements(span.events);\n      if (measurements) {\n        transactionEvent.measurements = measurements;\n      }\n\n      core.captureEvent(transactionEvent);\n    }\n\n    return sentSpans;\n  }\n\n  /** Remove \"expired\" span id entries from the _sentSpans cache. */\n   _flushSentSpanCache() {\n    const currentTimestamp = Date.now();\n    // Note, it is safe to delete items from the map as we go: https://stackoverflow.com/a/35943995/90297\n    for (const [spanId, expirationTime] of this._sentSpans.entries()) {\n      if (expirationTime <= currentTimestamp) {\n        this._sentSpans.delete(spanId);\n      }\n    }\n  }\n\n  /** Check if a node is a completed root node or a node whose parent has already been sent */\n   _nodeIsCompletedRootNodeOrHasSentParent(node) {\n    return !!node.span && (!node.parentNode || this._sentSpans.has(node.parentNode.id));\n  }\n\n  /** Get all completed root nodes from a list of nodes */\n   _getCompletedRootNodes(nodes) {\n    // TODO: We should be able to remove the explicit `node is SpanNodeCompleted` type guard\n    //       once we stop supporting TS < 5.5\n    return nodes.filter((node) => this._nodeIsCompletedRootNodeOrHasSentParent(node));\n  }\n}\n\nfunction parseSpan(span) {\n  const attributes = span.attributes;\n\n  const origin = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] ;\n  const op = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_OP] ;\n  const source = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] ;\n\n  return { origin, op, source };\n}\n\n/** Exported only for tests. */\nfunction createTransactionForOtelSpan(span) {\n  const { op, description, data, origin = 'manual', source } = getSpanData(span);\n  const capturedSpanScopes = core.getCapturedScopesOnSpan(span );\n\n  const sampleRate = span.attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE] ;\n\n  const attributes = {\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: sampleRate,\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: origin,\n    ...data,\n    ...removeSentryAttributes(span.attributes),\n  };\n\n  const { links } = span;\n  const { traceId: trace_id, spanId: span_id } = span.spanContext();\n\n  // If parentSpanIdFromTraceState is defined at all, we want it to take precedence\n  // In that case, an empty string should be interpreted as \"no parent span id\",\n  // even if `span.parentSpanId` is set\n  // this is the case when we are starting a new trace, where we have a virtual span based on the propagationContext\n  // We only want to continue the traceId in this case, but ignore the parent span\n  const parent_span_id = getParentSpanId(span);\n\n  const status = mapStatus(span);\n\n  const traceContext = {\n    parent_span_id,\n    span_id,\n    trace_id,\n    data: attributes,\n    origin,\n    op,\n    status: core.getStatusMessage(status), // As per protocol, span status is allowed to be undefined\n    links: core.convertSpanLinksForEnvelope(links),\n  };\n\n  const statusCode = attributes[semanticConventions.ATTR_HTTP_RESPONSE_STATUS_CODE];\n  const responseContext = typeof statusCode === 'number' ? { response: { status_code: statusCode } } : undefined;\n\n  const transactionEvent = {\n    contexts: {\n      trace: traceContext,\n      otel: {\n        resource: span.resource.attributes,\n      },\n      ...responseContext,\n    },\n    spans: [],\n    start_timestamp: core.spanTimeInputToSeconds(span.startTime),\n    timestamp: core.spanTimeInputToSeconds(span.endTime),\n    transaction: description,\n    type: 'transaction',\n    sdkProcessingMetadata: {\n      capturedSpanScope: capturedSpanScopes.scope,\n      capturedSpanIsolationScope: capturedSpanScopes.isolationScope,\n      sampleRate,\n      dynamicSamplingContext: core.getDynamicSamplingContextFromSpan(span ),\n    },\n    ...(source && {\n      transaction_info: {\n        source,\n      },\n    }),\n  };\n\n  return transactionEvent;\n}\n\nfunction createAndFinishSpanForOtelSpan(node, spans, sentSpans) {\n  const span = node.span;\n\n  if (span) {\n    sentSpans.add(span);\n  }\n\n  const shouldDrop = !span;\n\n  // If this span should be dropped, we still want to create spans for the children of this\n  if (shouldDrop) {\n    node.children.forEach(child => {\n      createAndFinishSpanForOtelSpan(child, spans, sentSpans);\n    });\n    return;\n  }\n\n  const span_id = span.spanContext().spanId;\n  const trace_id = span.spanContext().traceId;\n  const parentSpanId = getParentSpanId(span);\n\n  const { attributes, startTime, endTime, links } = span;\n\n  const { op, description, data, origin = 'manual' } = getSpanData(span);\n  const allData = {\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: origin,\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n    ...removeSentryAttributes(attributes),\n    ...data,\n  };\n\n  const status = mapStatus(span);\n\n  const spanJSON = {\n    span_id,\n    trace_id,\n    data: allData,\n    description,\n    parent_span_id: parentSpanId,\n    start_timestamp: core.spanTimeInputToSeconds(startTime),\n    // This is [0,0] by default in OTEL, in which case we want to interpret this as no end time\n    timestamp: core.spanTimeInputToSeconds(endTime) || undefined,\n    status: core.getStatusMessage(status), // As per protocol, span status is allowed to be undefined\n    op,\n    origin,\n    measurements: core.timedEventsToMeasurements(span.events),\n    links: core.convertSpanLinksForEnvelope(links),\n  };\n\n  spans.push(spanJSON);\n\n  node.children.forEach(child => {\n    createAndFinishSpanForOtelSpan(child, spans, sentSpans);\n  });\n}\n\nfunction getSpanData(span)\n\n {\n  const { op: definedOp, source: definedSource, origin } = parseSpan(span);\n  const { op: inferredOp, description, source: inferredSource, data: inferredData } = parseSpanDescription(span);\n\n  const op = definedOp || inferredOp;\n  const source = definedSource || inferredSource;\n\n  const data = { ...inferredData, ...getData(span) };\n\n  return {\n    op,\n    description,\n    source,\n    origin,\n    data,\n  };\n}\n\n/**\n * Remove custom `sentry.` attributes we do not need to send.\n * These are more carrier attributes we use inside of the SDK, we do not need to send them to the API.\n */\nfunction removeSentryAttributes(data) {\n  const cleanedData = { ...data };\n\n  /* eslint-disable @typescript-eslint/no-dynamic-delete */\n  delete cleanedData[core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE];\n  delete cleanedData[SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE];\n  delete cleanedData[core.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n  /* eslint-enable @typescript-eslint/no-dynamic-delete */\n\n  return cleanedData;\n}\n\nfunction getData(span) {\n  const attributes = span.attributes;\n  const data = {};\n\n  if (span.kind !== api.SpanKind.INTERNAL) {\n    data['otel.kind'] = api.SpanKind[span.kind];\n  }\n\n  // eslint-disable-next-line deprecation/deprecation\n  const maybeHttpStatusCodeAttribute = attributes[semanticConventions.SEMATTRS_HTTP_STATUS_CODE];\n  if (maybeHttpStatusCodeAttribute) {\n    data[semanticConventions.ATTR_HTTP_RESPONSE_STATUS_CODE] = maybeHttpStatusCodeAttribute ;\n  }\n\n  const requestData = getRequestSpanData(span);\n\n  if (requestData.url) {\n    data.url = requestData.url;\n  }\n\n  if (requestData['http.query']) {\n    data['http.query'] = requestData['http.query'].slice(1);\n  }\n  if (requestData['http.fragment']) {\n    data['http.fragment'] = requestData['http.fragment'].slice(1);\n  }\n\n  return data;\n}\n\nfunction onSpanStart(span, parentContext) {\n  // This is a reliable way to get the parent span - because this is exactly how the parent is identified in the OTEL SDK\n  const parentSpan = api.trace.getSpan(parentContext);\n\n  let scopes = getScopesFromContext(parentContext);\n\n  // We need access to the parent span in order to be able to move up the span tree for breadcrumbs\n  if (parentSpan && !parentSpan.spanContext().isRemote) {\n    core.addChildSpanToSpan(parentSpan, span);\n  }\n\n  // We need this in the span exporter\n  if (parentSpan?.spanContext().isRemote) {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE, true);\n  }\n\n  // The root context does not have scopes stored, so we check for this specifically\n  // As fallback we attach the global scopes\n  if (parentContext === api.ROOT_CONTEXT) {\n    scopes = {\n      scope: core.getDefaultCurrentScope(),\n      isolationScope: core.getDefaultIsolationScope(),\n    };\n  }\n\n  // We need the scope at time of span creation in order to apply it to the event when the span is finished\n  if (scopes) {\n    core.setCapturedScopesOnSpan(span, scopes.scope, scopes.isolationScope);\n  }\n\n  core.logSpanStart(span);\n\n  const client = core.getClient();\n  client?.emit('spanStart', span);\n}\n\nfunction onSpanEnd(span) {\n  core.logSpanEnd(span);\n\n  const client = core.getClient();\n  client?.emit('spanEnd', span);\n}\n\n/**\n * Converts OpenTelemetry Spans to Sentry Spans and sends them to Sentry via\n * the Sentry SDK.\n */\nclass SentrySpanProcessor  {\n\n   constructor(options) {\n    setIsSetup('SentrySpanProcessor');\n    this._exporter = new SentrySpanExporter(options);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   async forceFlush() {\n    this._exporter.flush();\n  }\n\n  /**\n   * @inheritDoc\n   */\n   async shutdown() {\n    this._exporter.clear();\n  }\n\n  /**\n   * @inheritDoc\n   */\n   onStart(span, parentContext) {\n    onSpanStart(span, parentContext);\n  }\n\n  /** @inheritDoc */\n   onEnd(span) {\n    onSpanEnd(span);\n\n    this._exporter.export(span);\n  }\n}\n\n/**\n * A custom OTEL sampler that uses Sentry sampling rates to make its decision\n */\nclass SentrySampler  {\n\n   constructor(client) {\n    this._client = client;\n    setIsSetup('SentrySampler');\n  }\n\n  /** @inheritDoc */\n   shouldSample(\n    context,\n    traceId,\n    spanName,\n    spanKind,\n    spanAttributes,\n    _links,\n  ) {\n    const options = this._client.getOptions();\n\n    const parentSpan = getValidSpan(context);\n    const parentContext = parentSpan?.spanContext();\n\n    if (!core.hasSpansEnabled(options)) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    // `ATTR_HTTP_REQUEST_METHOD` is the new attribute, but we still support the old one, `SEMATTRS_HTTP_METHOD`, for now.\n    // eslint-disable-next-line deprecation/deprecation\n    const maybeSpanHttpMethod = spanAttributes[semanticConventions.SEMATTRS_HTTP_METHOD] || spanAttributes[semanticConventions.ATTR_HTTP_REQUEST_METHOD];\n\n    // If we have a http.client span that has no local parent, we never want to sample it\n    // but we want to leave downstream sampling decisions up to the server\n    if (spanKind === api.SpanKind.CLIENT && maybeSpanHttpMethod && (!parentSpan || parentContext?.isRemote)) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    const parentSampled = parentSpan ? getParentSampled(parentSpan, traceId, spanName) : undefined;\n    const isRootSpan = !parentSpan || parentContext?.isRemote;\n\n    // We only sample based on parameters (like tracesSampleRate or tracesSampler) for root spans (which is done in sampleSpan).\n    // Non-root-spans simply inherit the sampling decision from their parent.\n    if (!isRootSpan) {\n      return wrapSamplingDecision({\n        decision: parentSampled ? sdkTraceBase.SamplingDecision.RECORD_AND_SAMPLED : sdkTraceBase.SamplingDecision.NOT_RECORD,\n        context,\n        spanAttributes,\n      });\n    }\n\n    // We want to pass the inferred name & attributes to the sampler method\n    const {\n      description: inferredSpanName,\n      data: inferredAttributes,\n      op,\n    } = inferSpanData(spanName, spanAttributes, spanKind);\n\n    const mergedAttributes = {\n      ...inferredAttributes,\n      ...spanAttributes,\n    };\n\n    if (op) {\n      mergedAttributes[core.SEMANTIC_ATTRIBUTE_SENTRY_OP] = op;\n    }\n\n    const mutableSamplingDecision = { decision: true };\n    this._client.emit(\n      'beforeSampling',\n      {\n        spanAttributes: mergedAttributes,\n        spanName: inferredSpanName,\n        parentSampled: parentSampled,\n        parentContext: parentContext,\n      },\n      mutableSamplingDecision,\n    );\n    if (!mutableSamplingDecision.decision) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    const { isolationScope } = getScopesFromContext(context) ?? {};\n\n    const dscString = parentContext?.traceState ? parentContext.traceState.get(SENTRY_TRACE_STATE_DSC) : undefined;\n    const dsc = dscString ? core.baggageHeaderToDynamicSamplingContext(dscString) : undefined;\n\n    const sampleRand = core.parseSampleRate(dsc?.sample_rand) ?? Math.random();\n\n    const [sampled, sampleRate, localSampleRateWasApplied] = core.sampleSpan(\n      options,\n      {\n        name: inferredSpanName,\n        attributes: mergedAttributes,\n        normalizedRequest: isolationScope?.getScopeData().sdkProcessingMetadata.normalizedRequest,\n        parentSampled,\n        parentSampleRate: core.parseSampleRate(dsc?.sample_rate),\n      },\n      sampleRand,\n    );\n\n    const method = `${maybeSpanHttpMethod}`.toUpperCase();\n    if (method === 'OPTIONS' || method === 'HEAD') {\n      DEBUG_BUILD && core.debug.log(`[Tracing] Not sampling span because HTTP method is '${method}' for ${spanName}`);\n\n      return wrapSamplingDecision({\n        decision: sdkTraceBase.SamplingDecision.NOT_RECORD,\n        context,\n        spanAttributes,\n        sampleRand,\n        downstreamTraceSampleRate: 0, // we don't want to sample anything in the downstream trace either\n      });\n    }\n\n    if (\n      !sampled &&\n      // We check for `parentSampled === undefined` because we only want to record client reports for spans that are trace roots (ie. when there was incoming trace)\n      parentSampled === undefined\n    ) {\n      DEBUG_BUILD && core.debug.log('[Tracing] Discarding root span because its trace was not chosen to be sampled.');\n      this._client.recordDroppedEvent('sample_rate', 'transaction');\n    }\n\n    return {\n      ...wrapSamplingDecision({\n        decision: sampled ? sdkTraceBase.SamplingDecision.RECORD_AND_SAMPLED : sdkTraceBase.SamplingDecision.NOT_RECORD,\n        context,\n        spanAttributes,\n        sampleRand,\n        downstreamTraceSampleRate: localSampleRateWasApplied ? sampleRate : undefined,\n      }),\n      attributes: {\n        // We set the sample rate on the span when a local sample rate was applied to better understand how traces were sampled in Sentry\n        [core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: localSampleRateWasApplied ? sampleRate : undefined,\n      },\n    };\n  }\n\n  /** Returns the sampler name or short description with the configuration. */\n   toString() {\n    return 'SentrySampler';\n  }\n}\n\nfunction getParentSampled(parentSpan, traceId, spanName) {\n  const parentContext = parentSpan.spanContext();\n\n  // Only inherit sample rate if `traceId` is the same\n  // Note for testing: `isSpanContextValid()` checks the format of the traceId/spanId, so we need to pass valid ones\n  if (api.isSpanContextValid(parentContext) && parentContext.traceId === traceId) {\n    if (parentContext.isRemote) {\n      const parentSampled = getSamplingDecision(parentSpan.spanContext());\n      DEBUG_BUILD &&\n        core.debug.log(`[Tracing] Inheriting remote parent's sampled decision for ${spanName}: ${parentSampled}`);\n      return parentSampled;\n    }\n\n    const parentSampled = getSamplingDecision(parentContext);\n    DEBUG_BUILD && core.debug.log(`[Tracing] Inheriting parent's sampled decision for ${spanName}: ${parentSampled}`);\n    return parentSampled;\n  }\n\n  return undefined;\n}\n\n/**\n * Wrap a sampling decision with data that Sentry needs to work properly with it.\n * If you pass `decision: undefined`, it will be treated as `NOT_RECORDING`, but in contrast to passing `NOT_RECORDING`\n * it will not propagate this decision to downstream Sentry SDKs.\n */\nfunction wrapSamplingDecision({\n  decision,\n  context,\n  spanAttributes,\n  sampleRand,\n  downstreamTraceSampleRate,\n}\n\n) {\n  let traceState = getBaseTraceState(context, spanAttributes);\n\n  // We will override the propagated sample rate downstream when\n  // - the tracesSampleRate is applied\n  // - the tracesSampler is invoked\n  // Since unsampled OTEL spans (NonRecordingSpans) cannot hold attributes we need to store this on the (trace)context.\n  if (downstreamTraceSampleRate !== undefined) {\n    traceState = traceState.set(SENTRY_TRACE_STATE_SAMPLE_RATE, `${downstreamTraceSampleRate}`);\n  }\n\n  if (sampleRand !== undefined) {\n    traceState = traceState.set(SENTRY_TRACE_STATE_SAMPLE_RAND, `${sampleRand}`);\n  }\n\n  // If the decision is undefined, we treat it as NOT_RECORDING, but we don't propagate this decision to downstream SDKs\n  // Which is done by not setting `SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING` traceState\n  if (decision == undefined) {\n    return { decision: sdkTraceBase.SamplingDecision.NOT_RECORD, traceState };\n  }\n\n  if (decision === sdkTraceBase.SamplingDecision.NOT_RECORD) {\n    return { decision, traceState: traceState.set(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING, '1') };\n  }\n\n  return { decision, traceState };\n}\n\nfunction getBaseTraceState(context, spanAttributes) {\n  const parentSpan = api.trace.getSpan(context);\n  const parentContext = parentSpan?.spanContext();\n\n  let traceState = parentContext?.traceState || new core$1.TraceState();\n\n  // We always keep the URL on the trace state, so we can access it in the propagator\n  // `ATTR_URL_FULL` is the new attribute, but we still support the old one, `ATTR_HTTP_URL`, for now.\n  // eslint-disable-next-line deprecation/deprecation\n  const url = spanAttributes[semanticConventions.SEMATTRS_HTTP_URL] || spanAttributes[semanticConventions.ATTR_URL_FULL];\n  if (url && typeof url === 'string') {\n    traceState = traceState.set(SENTRY_TRACE_STATE_URL, url);\n  }\n\n  return traceState;\n}\n\n/**\n * If the active span is invalid, we want to ignore it as parent.\n * This aligns with how otel tracers and default samplers handle these cases.\n */\nfunction getValidSpan(context) {\n  const span = api.trace.getSpan(context);\n  return span && api.isSpanContextValid(span.spanContext()) ? span : undefined;\n}\n\nexports.getClient = core.getClient;\nexports.getDynamicSamplingContextFromSpan = core.getDynamicSamplingContextFromSpan;\nexports.SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION = SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION;\nexports.SentryPropagator = SentryPropagator;\nexports.SentrySampler = SentrySampler;\nexports.SentrySpanProcessor = SentrySpanProcessor;\nexports.continueTrace = continueTrace;\nexports.enhanceDscWithOpenTelemetryRootSpanName = enhanceDscWithOpenTelemetryRootSpanName;\nexports.getActiveSpan = getActiveSpan;\nexports.getRequestSpanData = getRequestSpanData;\nexports.getScopesFromContext = getScopesFromContext;\nexports.getSpanKind = getSpanKind;\nexports.getTraceContextForScope = getTraceContextForScope;\nexports.isSentryRequestSpan = isSentryRequestSpan;\nexports.openTelemetrySetupCheck = openTelemetrySetupCheck;\nexports.setOpenTelemetryContextAsyncContextStrategy = setOpenTelemetryContextAsyncContextStrategy;\nexports.setupEventContextTrace = setupEventContextTrace;\nexports.shouldPropagateTraceForUrl = shouldPropagateTraceForUrl;\nexports.spanHasAttributes = spanHasAttributes;\nexports.spanHasEvents = spanHasEvents;\nexports.spanHasKind = spanHasKind;\nexports.spanHasName = spanHasName;\nexports.spanHasParentId = spanHasParentId;\nexports.spanHasStatus = spanHasStatus;\nexports.startInactiveSpan = startInactiveSpan;\nexports.startSpan = startSpan;\nexports.startSpanManual = startSpanManual;\nexports.suppressTracing = suppressTracing;\nexports.withActiveSpan = withActiveSpan;\nexports.wrapClientClass = wrapClientClass;\nexports.wrapContextManagerClass = wrapContextManagerClass;\nexports.wrapSamplingDecision = wrapSamplingDecision;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzZW50cnkrb3BlbnRlbGVtZXRyeUAxMC4xNy4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMF9Ab3BlbnRlbGVtZXRyeStjb250ZXh0LWFzeW5jLWhvb2tzQDIuMV9sbmFuanRiZWFvcmc3Y3B5ZDZkNWFqN2xqaS9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L2J1aWxkL2Nqcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsaUJBQWlCOztBQUV0RSw0QkFBNEIsbUJBQU8sQ0FBQywwTEFBcUM7QUFDekUsYUFBYSxtQkFBTyxDQUFDLHNIQUFjO0FBQ25DLFlBQVksbUJBQU8sQ0FBQyxzSUFBb0I7QUFDeEMsZUFBZSxtQkFBTyxDQUFDLGtLQUFxQjtBQUM1QyxxQkFBcUIsbUJBQU8sQ0FBQyxnTUFBK0I7O0FBRTVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGFBQWE7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7O0FBRW5DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxrQ0FBa0M7QUFDeEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsNEJBQTRCO0FBQ2hFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtDQUFrQyxrQkFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsSUFBSSx3QkFBd0I7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSwwQ0FBMEM7O0FBRXBEO0FBQ0EsYUFBYTtBQUNiOztBQUVBOztBQUVBO0FBQ0EsNkJBQTZCLFlBQVksRUFBRSxRQUFROztBQUVuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlCQUFpQixHQUFHLGtFQUFrRTtBQUMvRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTzs7QUFFbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsVUFBVSxzQkFBc0I7QUFDaEMsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxnQkFBZ0IsOEJBQThCLEtBQUssa0JBQWtCO0FBQ3JFO0FBQ0E7O0FBRUEsWUFBWSxLQUFLO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUEsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVksY0FBYyw2REFBNkQ7QUFDdkY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUZBQXlGOztBQUV6RixZQUFZLG1EQUFtRDs7QUFFL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLCtCQUErQixFQUFFLE9BQU8sS0FBSyxpQkFBaUI7QUFDN0Y7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyRUFBMkUsc0JBQXNCO0FBQ2pHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxzQkFBc0I7QUFDMUI7QUFDQTs7QUFFQSxVQUFVLHNDQUFzQzs7QUFFaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHdCQUF3QjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxxQ0FBcUM7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdDQUFnQztBQUM3RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxxQ0FBcUM7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdDQUFnQztBQUM3RDtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsZ0JBQWdCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLHFDQUFxQzs7QUFFL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUseUNBQXlDOztBQUVuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGtCQUFrQjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBOztBQUVBLFVBQVUsbURBQW1ELDBCQUEwQixlQUFlOztBQUV0RztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0NBQWtDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0Msd0JBQXdCO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG9DQUFvQztBQUNqRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxrQkFBa0I7QUFDekQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLFFBQVE7QUFDUixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsSUFBSTtBQUNKLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLGNBQWM7QUFDbkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0IsZ0RBQWdELDhCQUE4QjtBQUNwSTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGVBQWUsU0FBUyx3QkFBd0I7QUFDakY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLFVBQVUsbURBQW1EO0FBQzdEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxRQUFRO0FBQ2xCLFVBQVUscUNBQXFDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2REFBNkQsWUFBWSw0QkFBNEI7O0FBRXJHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFVBQVUsd0NBQXdDOztBQUVsRCxVQUFVLDJDQUEyQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQSxVQUFVLCtDQUErQztBQUN6RCxVQUFVLDBFQUEwRTs7QUFFcEY7QUFDQTs7QUFFQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLDhDQUE4QztBQUNsRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDhDQUE4QztBQUNsRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDhDQUE4QztBQUNsRjs7QUFFQSxZQUFZLGlCQUFpQjs7QUFFN0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBLDJGQUEyRixPQUFPLFFBQVEsU0FBUzs7QUFFbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixTQUFTLElBQUksY0FBYztBQUMvRztBQUNBOztBQUVBO0FBQ0Esd0ZBQXdGLFNBQVMsSUFBSSxjQUFjO0FBQ25IO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLDBCQUEwQjtBQUM3Rjs7QUFFQTtBQUNBLG1FQUFtRSxXQUFXO0FBQzlFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakIseUNBQXlDO0FBQ3pDLG1EQUFtRDtBQUNuRCx3QkFBd0I7QUFDeEIscUJBQXFCO0FBQ3JCLDJCQUEyQjtBQUMzQixxQkFBcUI7QUFDckIsK0NBQStDO0FBQy9DLHFCQUFxQjtBQUNyQiwwQkFBMEI7QUFDMUIsNEJBQTRCO0FBQzVCLG1CQUFtQjtBQUNuQiwrQkFBK0I7QUFDL0IsMkJBQTJCO0FBQzNCLCtCQUErQjtBQUMvQixtREFBbUQ7QUFDbkQsOEJBQThCO0FBQzlCLGtDQUFrQztBQUNsQyx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQix5QkFBeUI7QUFDekIsaUJBQWlCO0FBQ2pCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2QiwrQkFBK0I7QUFDL0IsNEJBQTRCO0FBQzVCIiwic291cmNlcyI6WyIvVXNlcnMvY29keWRlYXJrbGFuZC9zZW50cnl2aWJlL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5K29wZW50ZWxlbWV0cnlAMTAuMTcuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjBfQG9wZW50ZWxlbWV0cnkrY29udGV4dC1hc3luYy1ob29rc0AyLjFfbG5hbmp0YmVhb3JnN2NweWQ2ZDVhajdsamkvbm9kZV9tb2R1bGVzL0BzZW50cnkvb3BlbnRlbGVtZXRyeS9idWlsZC9janMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmNvbnN0IHNlbWFudGljQ29udmVudGlvbnMgPSByZXF1aXJlKCdAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9ucycpO1xuY29uc3QgY29yZSA9IHJlcXVpcmUoJ0BzZW50cnkvY29yZScpO1xuY29uc3QgYXBpID0gcmVxdWlyZSgnQG9wZW50ZWxlbWV0cnkvYXBpJyk7XG5jb25zdCBjb3JlJDEgPSByZXF1aXJlKCdAb3BlbnRlbGVtZXRyeS9jb3JlJyk7XG5jb25zdCBzZGtUcmFjZUJhc2UgPSByZXF1aXJlKCdAb3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZScpO1xuXG4vKiogSWYgdGhpcyBhdHRyaWJ1dGUgaXMgdHJ1ZSwgaXQgbWVhbnMgdGhhdCB0aGUgcGFyZW50IGlzIGEgcmVtb3RlIHNwYW4uICovXG5jb25zdCBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1BBUkVOVF9JU19SRU1PVEUgPSAnc2VudHJ5LnBhcmVudElzUmVtb3RlJztcblxuLy8gVGhlc2UgYXJlIG5vdCBzdGFuZGFyZGl6ZWQgeWV0LCBidXQgdXNlZCBieSB0aGUgZ3JhcGhxbCBpbnN0cnVtZW50YXRpb25cbmNvbnN0IFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfR1JBUEhRTF9PUEVSQVRJT04gPSAnc2VudHJ5LmdyYXBocWwub3BlcmF0aW9uJztcblxuLyoqXG4gKiBHZXQgdGhlIHBhcmVudCBzcGFuIGlkIGZyb20gYSBzcGFuLlxuICogSW4gT1RlbCB2MSwgdGhlIHBhcmVudCBzcGFuIGlkIGlzIGFjY2Vzc2VkIGFzIGBwYXJlbnRTcGFuSWRgXG4gKiBJbiBPVGVsIHYyLCB0aGUgcGFyZW50IHNwYW4gaWQgaXMgYWNjZXNzZWQgYXMgYHNwYW5JZGAgb24gdGhlIGBwYXJlbnRTcGFuQ29udGV4dGBcbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50U3BhbklkKHNwYW4pIHtcbiAgaWYgKCdwYXJlbnRTcGFuSWQnIGluIHNwYW4pIHtcbiAgICByZXR1cm4gc3Bhbi5wYXJlbnRTcGFuSWQgO1xuICB9IGVsc2UgaWYgKCdwYXJlbnRTcGFuQ29udGV4dCcgaW4gc3Bhbikge1xuICAgIHJldHVybiAoc3Bhbi5wYXJlbnRTcGFuQ29udGV4dCApPy5zcGFuSWQ7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgZ2l2ZW4gc3BhbiBoYXMgYXR0cmlidXRlcy5cbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdGhlIGJhc2UgYFNwYW5gIHR5cGUgZG9lcyBub3QgaGF2ZSBhdHRyaWJ1dGVzLFxuICogc28gaW4gcGxhY2VzIHdoZXJlIHdlIGFyZSBwYXNzZWQgYSBnZW5lcmljIHNwYW4sIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2Ugd2FudCB0byBhY2Nlc3MgdGhlbS5cbiAqL1xuZnVuY3Rpb24gc3Bhbkhhc0F0dHJpYnV0ZXMoXG4gIHNwYW4sXG4pIHtcbiAgY29uc3QgY2FzdFNwYW4gPSBzcGFuIDtcbiAgcmV0dXJuICEhY2FzdFNwYW4uYXR0cmlidXRlcyAmJiB0eXBlb2YgY2FzdFNwYW4uYXR0cmlidXRlcyA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBnaXZlbiBzcGFuIGhhcyBhIGtpbmQuXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBiYXNlIGBTcGFuYCB0eXBlIGRvZXMgbm90IGhhdmUgYSBraW5kLFxuICogc28gaW4gcGxhY2VzIHdoZXJlIHdlIGFyZSBwYXNzZWQgYSBnZW5lcmljIHNwYW4sIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2Ugd2FudCB0byBhY2Nlc3MgaXQuXG4gKi9cbmZ1bmN0aW9uIHNwYW5IYXNLaW5kKHNwYW4pIHtcbiAgY29uc3QgY2FzdFNwYW4gPSBzcGFuIDtcbiAgcmV0dXJuIHR5cGVvZiBjYXN0U3Bhbi5raW5kID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGdpdmVuIHNwYW4gaGFzIGEgc3RhdHVzLlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB0aGUgYmFzZSBgU3BhbmAgdHlwZSBkb2VzIG5vdCBoYXZlIGEgc3RhdHVzLFxuICogc28gaW4gcGxhY2VzIHdoZXJlIHdlIGFyZSBwYXNzZWQgYSBnZW5lcmljIHNwYW4sIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2Ugd2FudCB0byBhY2Nlc3MgaXQuXG4gKi9cbmZ1bmN0aW9uIHNwYW5IYXNTdGF0dXMoXG4gIHNwYW4sXG4pIHtcbiAgY29uc3QgY2FzdFNwYW4gPSBzcGFuIDtcbiAgcmV0dXJuICEhY2FzdFNwYW4uc3RhdHVzO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgZ2l2ZW4gc3BhbiBoYXMgYSBuYW1lLlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB0aGUgYmFzZSBgU3BhbmAgdHlwZSBkb2VzIG5vdCBoYXZlIGEgbmFtZSxcbiAqIHNvIGluIHBsYWNlcyB3aGVyZSB3ZSBhcmUgcGFzc2VkIGEgZ2VuZXJpYyBzcGFuLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIHdhbnQgdG8gYWNjZXNzIGl0LlxuICovXG5mdW5jdGlvbiBzcGFuSGFzTmFtZShzcGFuKSB7XG4gIGNvbnN0IGNhc3RTcGFuID0gc3BhbiA7XG4gIHJldHVybiAhIWNhc3RTcGFuLm5hbWU7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBnaXZlbiBzcGFuIGhhcyBhIGtpbmQuXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBiYXNlIGBTcGFuYCB0eXBlIGRvZXMgbm90IGhhdmUgYSBraW5kLFxuICogc28gaW4gcGxhY2VzIHdoZXJlIHdlIGFyZSBwYXNzZWQgYSBnZW5lcmljIHNwYW4sIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2Ugd2FudCB0byBhY2Nlc3MgaXQuXG4gKi9cbmZ1bmN0aW9uIHNwYW5IYXNQYXJlbnRJZChcbiAgc3Bhbixcbikge1xuICBjb25zdCBjYXN0U3BhbiA9IHNwYW4gO1xuICByZXR1cm4gISFnZXRQYXJlbnRTcGFuSWQoY2FzdFNwYW4pO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgZ2l2ZW4gc3BhbiBoYXMgZXZlbnRzLlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB0aGUgYmFzZSBgU3BhbmAgdHlwZSBkb2VzIG5vdCBoYXZlIGV2ZW50cyxcbiAqIHNvIGluIHBsYWNlcyB3aGVyZSB3ZSBhcmUgcGFzc2VkIGEgZ2VuZXJpYyBzcGFuLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIHdhbnQgdG8gYWNjZXNzIGl0LlxuICovXG5mdW5jdGlvbiBzcGFuSGFzRXZlbnRzKFxuICBzcGFuLFxuKSB7XG4gIGNvbnN0IGNhc3RTcGFuID0gc3BhbiA7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGNhc3RTcGFuLmV2ZW50cyk7XG59XG5cbi8qKlxuICogR2V0IHNhbml0aXppZWQgcmVxdWVzdCBkYXRhIGZyb20gYW4gT1RFTCBzcGFuLlxuICovXG5mdW5jdGlvbiBnZXRSZXF1ZXN0U3BhbkRhdGEoc3Bhbikge1xuICAvLyBUaGUgYmFzZSBgU3BhbmAgdHlwZSBoYXMgbm8gYGF0dHJpYnV0ZXNgLCBzbyB3ZSBuZWVkIHRvIGd1YXJkIGhlcmUgYWdhaW5zdCB0aGF0XG4gIGlmICghc3Bhbkhhc0F0dHJpYnV0ZXMoc3BhbikpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgY29uc3QgbWF5YmVVcmxBdHRyaWJ1dGUgPSAoc3Bhbi5hdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuQVRUUl9VUkxfRlVMTF0gfHwgc3Bhbi5hdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9VUkxdKVxuXG47XG5cbiAgY29uc3QgZGF0YSA9IHtcbiAgICB1cmw6IG1heWJlVXJsQXR0cmlidXRlLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgICdodHRwLm1ldGhvZCc6IChzcGFuLmF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5BVFRSX0hUVFBfUkVRVUVTVF9NRVRIT0RdIHx8IHNwYW4uYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfTUVUSE9EXSlcblxuLFxuICB9O1xuXG4gIC8vIERlZmF1bHQgdG8gR0VUIGlmIFVSTCBpcyBzZXQgYnV0IG1ldGhvZCBpcyBub3RcbiAgaWYgKCFkYXRhWydodHRwLm1ldGhvZCddICYmIGRhdGEudXJsKSB7XG4gICAgZGF0YVsnaHR0cC5tZXRob2QnXSA9ICdHRVQnO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIG1heWJlVXJsQXR0cmlidXRlID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgdXJsID0gY29yZS5wYXJzZVVybChtYXliZVVybEF0dHJpYnV0ZSk7XG5cbiAgICAgIGRhdGEudXJsID0gY29yZS5nZXRTYW5pdGl6ZWRVcmxTdHJpbmcodXJsKTtcblxuICAgICAgaWYgKHVybC5zZWFyY2gpIHtcbiAgICAgICAgZGF0YVsnaHR0cC5xdWVyeSddID0gdXJsLnNlYXJjaDtcbiAgICAgIH1cbiAgICAgIGlmICh1cmwuaGFzaCkge1xuICAgICAgICBkYXRhWydodHRwLmZyYWdtZW50J10gPSB1cmwuaGFzaDtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2gge1xuICAgIC8vIGlnbm9yZVxuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8vIFR5cGVzY3JpcHQgY29tcGxhaW5zIGlmIHdlIGRvIG5vdCB1c2UgYC4uLmFyZ3M6IGFueVtdYCBmb3IgdGhlIG1peGluLCB3aXRoOlxuLy8gQSBtaXhpbiBjbGFzcyBtdXN0IGhhdmUgYSBjb25zdHJ1Y3RvciB3aXRoIGEgc2luZ2xlIHJlc3QgcGFyYW1ldGVyIG9mIHR5cGUgJ2FueVtdJy50cygyNTQ1KVxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuXG4vKipcbiAqIFdyYXAgYW4gQ2xpZW50IGNsYXNzIHdpdGggdGhpbmdzIHdlIG5lZWQgZm9yIE9wZW5UZWxlbWV0cnkgc3VwcG9ydC5cbiAqIE1ha2Ugc3VyZSB0aGF0IHRoZSBDbGllbnQgY2xhc3MgcGFzc2VkIGluIGlzIG5vbi1hYnN0cmFjdCFcbiAqXG4gKiBVc2FnZTpcbiAqIGNvbnN0IE9wZW5UZWxlbWV0cnlDbGllbnQgPSBnZXRXcmFwcGVkQ2xpZW50Q2xhc3MoTm9kZUNsaWVudCk7XG4gKiBjb25zdCBjbGllbnQgPSBuZXcgT3BlblRlbGVtZXRyeUNsaWVudChvcHRpb25zKTtcbiAqL1xuZnVuY3Rpb24gd3JhcENsaWVudENsYXNzXG5cbihDbGllbnRDbGFzcykge1xuICAvLyBAdHMtZXhwZWN0LWVycm9yIFdlIGp1c3QgYXNzdW1lIHRoYXQgdGhpcyBpcyBub24tYWJzdHJhY3QsIGlmIHlvdSBwYXNzIGluIGFuIGFic3RyYWN0IGNsYXNzIHRoaXMgd291bGQgbWFrZSBpdCBub24tYWJzdHJhY3RcbiAgY2xhc3MgT3BlblRlbGVtZXRyeUNsaWVudCBleHRlbmRzIENsaWVudENsYXNzICB7XG5cbiAgICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgfVxuXG4gICAgLyoqIEdldCB0aGUgT1RFTCB0cmFjZXIuICovXG4gICAgIGdldCB0cmFjZXIoKSB7XG4gICAgICBpZiAodGhpcy5fdHJhY2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFjZXI7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5hbWUgPSAnQHNlbnRyeS9vcGVudGVsZW1ldHJ5JztcbiAgICAgIGNvbnN0IHZlcnNpb24gPSBjb3JlLlNES19WRVJTSU9OO1xuICAgICAgY29uc3QgdHJhY2VyID0gYXBpLnRyYWNlLmdldFRyYWNlcihuYW1lLCB2ZXJzaW9uKTtcbiAgICAgIHRoaXMuX3RyYWNlciA9IHRyYWNlcjtcblxuICAgICAgcmV0dXJuIHRyYWNlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgICBhc3luYyBmbHVzaCh0aW1lb3V0KSB7XG4gICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMudHJhY2VQcm92aWRlcjtcbiAgICAgIGF3YWl0IHByb3ZpZGVyPy5mb3JjZUZsdXNoKCk7XG4gICAgICByZXR1cm4gc3VwZXIuZmx1c2godGltZW91dCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIE9wZW5UZWxlbWV0cnlDbGllbnQgO1xufVxuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5cbi8qKlxuICogR2V0IHRoZSBzcGFuIGtpbmQgZnJvbSBhIHNwYW4uXG4gKiBGb3Igd2hhdGV2ZXIgcmVhc29uLCB0aGlzIGlzIG5vdCBwdWJsaWMgQVBJIG9uIHRoZSBnZW5lcmljIFwiU3BhblwiIHR5cGUsXG4gKiBzbyB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGFjdHVhbGx5IGhhdmUgYSBgU0RLVHJhY2VCYXNlU3BhbmAgd2hlcmUgd2UgY2FuIGZldGNoIHRoaXMgZnJvbS5cbiAqIE90aGVyd2lzZSwgd2UgZmFsbCBiYWNrIHRvIGBTcGFuS2luZC5JTlRFUk5BTGAuXG4gKi9cbmZ1bmN0aW9uIGdldFNwYW5LaW5kKHNwYW4pIHtcbiAgaWYgKHNwYW5IYXNLaW5kKHNwYW4pKSB7XG4gICAgcmV0dXJuIHNwYW4ua2luZDtcbiAgfVxuXG4gIHJldHVybiBhcGkuU3BhbktpbmQuSU5URVJOQUw7XG59XG5cbmNvbnN0IFNFTlRSWV9UUkFDRV9IRUFERVIgPSAnc2VudHJ5LXRyYWNlJztcbmNvbnN0IFNFTlRSWV9CQUdHQUdFX0hFQURFUiA9ICdiYWdnYWdlJztcblxuY29uc3QgU0VOVFJZX1RSQUNFX1NUQVRFX0RTQyA9ICdzZW50cnkuZHNjJztcbmNvbnN0IFNFTlRSWV9UUkFDRV9TVEFURV9TQU1QTEVEX05PVF9SRUNPUkRJTkcgPSAnc2VudHJ5LnNhbXBsZWRfbm90X3JlY29yZGluZyc7XG5jb25zdCBTRU5UUllfVFJBQ0VfU1RBVEVfVVJMID0gJ3NlbnRyeS51cmwnO1xuY29uc3QgU0VOVFJZX1RSQUNFX1NUQVRFX1NBTVBMRV9SQU5EID0gJ3NlbnRyeS5zYW1wbGVfcmFuZCc7XG5jb25zdCBTRU5UUllfVFJBQ0VfU1RBVEVfU0FNUExFX1JBVEUgPSAnc2VudHJ5LnNhbXBsZV9yYXRlJztcblxuY29uc3QgU0VOVFJZX1NDT1BFU19DT05URVhUX0tFWSA9IGFwaS5jcmVhdGVDb250ZXh0S2V5KCdzZW50cnlfc2NvcGVzJyk7XG5cbmNvbnN0IFNFTlRSWV9GT1JLX0lTT0xBVElPTl9TQ09QRV9DT05URVhUX0tFWSA9IGFwaS5jcmVhdGVDb250ZXh0S2V5KCdzZW50cnlfZm9ya19pc29sYXRpb25fc2NvcGUnKTtcblxuY29uc3QgU0VOVFJZX0ZPUktfU0VUX1NDT1BFX0NPTlRFWFRfS0VZID0gYXBpLmNyZWF0ZUNvbnRleHRLZXkoJ3NlbnRyeV9mb3JrX3NldF9zY29wZScpO1xuXG5jb25zdCBTRU5UUllfRk9SS19TRVRfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZID0gYXBpLmNyZWF0ZUNvbnRleHRLZXkoJ3NlbnRyeV9mb3JrX3NldF9pc29sYXRpb25fc2NvcGUnKTtcblxuY29uc3QgU0NPUEVfQ09OVEVYVF9GSUVMRCA9ICdfc2NvcGVDb250ZXh0JztcblxuLyoqXG4gKiBUcnkgdG8gZ2V0IHRoZSBjdXJyZW50IHNjb3BlcyBmcm9tIHRoZSBnaXZlbiBPVEVMIGNvbnRleHQuXG4gKiBUaGlzIHJlcXVpcmVzIGEgQ29udGV4dCBNYW5hZ2VyIHRoYXQgd2FzIHdyYXBwZWQgd2l0aCBnZXRXcmFwcGVkQ29udGV4dE1hbmFnZXIuXG4gKi9cbmZ1bmN0aW9uIGdldFNjb3Blc0Zyb21Db250ZXh0KGNvbnRleHQpIHtcbiAgcmV0dXJuIGNvbnRleHQuZ2V0VmFsdWUoU0VOVFJZX1NDT1BFU19DT05URVhUX0tFWSkgO1xufVxuXG4vKipcbiAqIFNldCB0aGUgY3VycmVudCBzY29wZXMgb24gYW4gT1RFTCBjb250ZXh0LlxuICogVGhpcyB3aWxsIHJldHVybiBhIGZvcmtlZCBjb250ZXh0IHdpdGggdGhlIFByb3BhZ2F0aW9uIENvbnRleHQgc2V0LlxuICovXG5mdW5jdGlvbiBzZXRTY29wZXNPbkNvbnRleHQoY29udGV4dCwgc2NvcGVzKSB7XG4gIHJldHVybiBjb250ZXh0LnNldFZhbHVlKFNFTlRSWV9TQ09QRVNfQ09OVEVYVF9LRVksIHNjb3Blcyk7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjb250ZXh0IG9uIHRoZSBzY29wZSBzbyB3ZSBjYW4gbGF0ZXIgbG9vayBpdCB1cC5cbiAqIFdlIG5lZWQgdGhpcyB0byBnZXQgdGhlIGNvbnRleHQgZnJvbSB0aGUgc2NvcGUgaW4gdGhlIGB0cmFjZWAgZnVuY3Rpb25zLlxuICovXG5mdW5jdGlvbiBzZXRDb250ZXh0T25TY29wZShzY29wZSwgY29udGV4dCkge1xuICBjb3JlLmFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eShzY29wZSwgU0NPUEVfQ09OVEVYVF9GSUVMRCwgY29udGV4dCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjb250ZXh0IHJlbGF0ZWQgdG8gYSBzY29wZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Q29udGV4dEZyb21TY29wZShzY29wZSkge1xuICByZXR1cm4gKHNjb3BlIClbU0NPUEVfQ09OVEVYVF9GSUVMRF07XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBvdGVsU3BhbiBDaGVja3Mgd2hldGhlciBhIGdpdmVuIE9URUwgU3BhbiBpcyBhbiBodHRwIHJlcXVlc3QgdG8gc2VudHJ5LlxuICogQHJldHVybnMgYm9vbGVhblxuICovXG5mdW5jdGlvbiBpc1NlbnRyeVJlcXVlc3RTcGFuKHNwYW4pIHtcbiAgaWYgKCFzcGFuSGFzQXR0cmlidXRlcyhzcGFuKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHsgYXR0cmlidXRlcyB9ID0gc3BhbjtcblxuICAvLyBgQVRUUl9VUkxfRlVMTGAgaXMgdGhlIG5ldyBhdHRyaWJ1dGUsIGJ1dCB3ZSBzdGlsbCBzdXBwb3J0IHRoZSBvbGQgb25lLCBgQVRUUl9IVFRQX1VSTGAsIGZvciBub3cuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBjb25zdCBodHRwVXJsID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfVVJMXSB8fCBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuQVRUUl9VUkxfRlVMTF07XG5cbiAgaWYgKCFodHRwVXJsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGNvcmUuaXNTZW50cnlSZXF1ZXN0VXJsKGh0dHBVcmwudG9TdHJpbmcoKSwgY29yZS5nZXRDbGllbnQoKSk7XG59XG5cbi8qKlxuICogT3BlblRlbGVtZXRyeSBvbmx5IGtub3dzIGFib3V0IFNBTVBMRUQgb3IgTk9ORSBkZWNpc2lvbixcbiAqIGJ1dCBmb3IgdXMgaXQgaXMgaW1wb3J0YW50IHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiB1bnNldCBhbmQgdW5zYW1wbGVkLlxuICpcbiAqIEJvdGggb2YgdGhlc2UgYXJlIGlkZW50aWZpZWQgYXMgYHRyYWNlRmxhZ3MgPT09IFRyYWNlZ0ZsYWdzLk5PTkVgLFxuICogYnV0IHdlIGFkZGl0aW9uYWxseSBsb29rIGF0IGEgc3BlY2lhbCB0cmFjZSBzdGF0ZSB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gdGhlbS5cbiAqL1xuZnVuY3Rpb24gZ2V0U2FtcGxpbmdEZWNpc2lvbihzcGFuQ29udGV4dCkge1xuICBjb25zdCB7IHRyYWNlRmxhZ3MsIHRyYWNlU3RhdGUgfSA9IHNwYW5Db250ZXh0O1xuXG4gIGNvbnN0IHNhbXBsZWROb3RSZWNvcmRpbmcgPSB0cmFjZVN0YXRlID8gdHJhY2VTdGF0ZS5nZXQoU0VOVFJZX1RSQUNFX1NUQVRFX1NBTVBMRURfTk9UX1JFQ09SRElORykgPT09ICcxJyA6IGZhbHNlO1xuXG4gIC8vIElmIHRyYWNlIGZsYWcgaXMgYFNBTVBMRURgLCB3ZSBpbnRlcnByZXQgdGhpcyBhcyBzYW1wbGVkXG4gIC8vIElmIGl0IGlzIGBOT05FYCwgaXQgY291bGQgbWVhbiBlaXRoZXIgaXQgd2FzIHNhbXBsZWQgdG8gYmUgbm90IHJlY29yZGVyLCBvciB0aGF0IGl0IHdhcyBub3Qgc2FtcGxlZCBhdCBhbGxcbiAgLy8gRm9yIHVzIHRoaXMgaXMgYW4gaW1wb3J0YW50IGRpZmZlcmVuY2UsIHNvdyBlIGxvb2sgYXQgdGhlIFNFTlRSWV9UUkFDRV9TVEFURV9TQU1QTEVEX05PVF9SRUNPUkRJTkdcbiAgLy8gdG8gaWRlbnRpZnkgd2hpY2ggaXQgaXNcbiAgaWYgKHRyYWNlRmxhZ3MgPT09IGFwaS5UcmFjZUZsYWdzLlNBTVBMRUQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChzYW1wbGVkTm90UmVjb3JkaW5nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRmFsbCBiYWNrIHRvIERTQyBhcyBhIGxhc3QgcmVzb3J0LCB0aGF0IG1heSBhbHNvIGNvbnRhaW4gYHNhbXBsZWRgLi4uXG4gIGNvbnN0IGRzY1N0cmluZyA9IHRyYWNlU3RhdGUgPyB0cmFjZVN0YXRlLmdldChTRU5UUllfVFJBQ0VfU1RBVEVfRFNDKSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgZHNjID0gZHNjU3RyaW5nID8gY29yZS5iYWdnYWdlSGVhZGVyVG9EeW5hbWljU2FtcGxpbmdDb250ZXh0KGRzY1N0cmluZykgOiB1bmRlZmluZWQ7XG5cbiAgaWYgKGRzYz8uc2FtcGxlZCA9PT0gJ3RydWUnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGRzYz8uc2FtcGxlZCA9PT0gJ2ZhbHNlJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogSW5mZXIgdGhlIG9wICYgZGVzY3JpcHRpb24gZm9yIGEgc2V0IG9mIG5hbWUsIGF0dHJpYnV0ZXMgYW5kIGtpbmQgb2YgYSBzcGFuLlxuICovXG5mdW5jdGlvbiBpbmZlclNwYW5EYXRhKHNwYW5OYW1lLCBhdHRyaWJ1dGVzLCBraW5kKSB7XG4gIC8vIGlmIGh0dHAubWV0aG9kIGV4aXN0cywgdGhpcyBpcyBhbiBodHRwIHJlcXVlc3Qgc3BhblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgY29uc3QgaHR0cE1ldGhvZCA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5BVFRSX0hUVFBfUkVRVUVTVF9NRVRIT0RdIHx8IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19IVFRQX01FVEhPRF07XG4gIGlmIChodHRwTWV0aG9kKSB7XG4gICAgcmV0dXJuIGRlc2NyaXB0aW9uRm9ySHR0cE1ldGhvZCh7IGF0dHJpYnV0ZXMsIG5hbWU6IHNwYW5OYW1lLCBraW5kIH0sIGh0dHBNZXRob2QpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIGNvbnN0IGRiU3lzdGVtID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0RCX1NZU1RFTV07XG4gIGNvbnN0IG9wSXNDYWNoZSA9XG4gICAgdHlwZW9mIGF0dHJpYnV0ZXNbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09QXSA9PT0gJ3N0cmluZycgJiZcbiAgICBhdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUF0uc3RhcnRzV2l0aCgnY2FjaGUuJyk7XG5cbiAgLy8gSWYgZGIudHlwZSBleGlzdHMgdGhlbiB0aGlzIGlzIGEgZGF0YWJhc2UgY2FsbCBzcGFuXG4gIC8vIElmIHRoZSBSZWRpcyBEQiBpcyB1c2VkIGFzIGEgY2FjaGUsIHRoZSBzcGFuIGRlc2NyaXB0aW9uIHNob3VsZCBub3QgYmUgY2hhbmdlZFxuICBpZiAoZGJTeXN0ZW0gJiYgIW9wSXNDYWNoZSkge1xuICAgIHJldHVybiBkZXNjcmlwdGlvbkZvckRiU3lzdGVtKHsgYXR0cmlidXRlcywgbmFtZTogc3Bhbk5hbWUgfSk7XG4gIH1cblxuICBjb25zdCBjdXN0b21Tb3VyY2VPclJvdXRlID0gYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFXSA9PT0gJ2N1c3RvbScgPyAnY3VzdG9tJyA6ICdyb3V0ZSc7XG5cbiAgLy8gSWYgcnBjLnNlcnZpY2UgZXhpc3RzIHRoZW4gdGhpcyBpcyBhIHJwYyBjYWxsIHNwYW4uXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBjb25zdCBycGNTZXJ2aWNlID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX1JQQ19TRVJWSUNFXTtcbiAgaWYgKHJwY1NlcnZpY2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZ2V0VXNlclVwZGF0ZWROYW1lQW5kU291cmNlKHNwYW5OYW1lLCBhdHRyaWJ1dGVzLCAncm91dGUnKSxcbiAgICAgIG9wOiAncnBjJyxcbiAgICB9O1xuICB9XG5cbiAgLy8gSWYgbWVzc2FnaW5nLnN5c3RlbSBleGlzdHMgdGhlbiB0aGlzIGlzIGEgbWVzc2FnaW5nIHN5c3RlbSBzcGFuLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgY29uc3QgbWVzc2FnaW5nU3lzdGVtID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX01FU1NBR0lOR19TWVNURU1dO1xuICBpZiAobWVzc2FnaW5nU3lzdGVtKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmdldFVzZXJVcGRhdGVkTmFtZUFuZFNvdXJjZShzcGFuTmFtZSwgYXR0cmlidXRlcywgY3VzdG9tU291cmNlT3JSb3V0ZSksXG4gICAgICBvcDogJ21lc3NhZ2UnLFxuICAgIH07XG4gIH1cblxuICAvLyBJZiBmYWFzLnRyaWdnZXIgZXhpc3RzIHRoZW4gdGhpcyBpcyBhIGZ1bmN0aW9uIGFzIGEgc2VydmljZSBzcGFuLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgY29uc3QgZmFhc1RyaWdnZXIgPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfRkFBU19UUklHR0VSXTtcbiAgaWYgKGZhYXNUcmlnZ2VyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmdldFVzZXJVcGRhdGVkTmFtZUFuZFNvdXJjZShzcGFuTmFtZSwgYXR0cmlidXRlcywgY3VzdG9tU291cmNlT3JSb3V0ZSksXG4gICAgICBvcDogZmFhc1RyaWdnZXIudG9TdHJpbmcoKSxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHsgb3A6IHVuZGVmaW5lZCwgZGVzY3JpcHRpb246IHNwYW5OYW1lLCBzb3VyY2U6ICdjdXN0b20nIH07XG59XG5cbi8qKlxuICogRXh0cmFjdCBiZXR0ZXIgb3AvZGVzY3JpcHRpb24gZnJvbSBhbiBvdGVsIHNwYW4uXG4gKlxuICogRG9lcyBub3Qgb3ZlcndyaXRlIHRoZSBzcGFuIG5hbWUgaWYgdGhlIHNvdXJjZSBpcyBhbHJlYWR5IHNldCB0byBjdXN0b20gdG8gZW5zdXJlXG4gKiB0aGF0IHVzZXItdXBkYXRlZCBzcGFuIG5hbWVzIGFyZSBwcmVzZXJ2ZWQuIEluIHRoaXMgY2FzZSwgd2Ugb25seSBhZGp1c3QgdGhlIG9wIGJ1dFxuICogbGVhdmUgc3BhbiBkZXNjcmlwdGlvbiBhbmQgc291cmNlIHVuY2hhbmdlZC5cbiAqXG4gKiBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vb3Blbi10ZWxlbWV0cnkvb3BlbnRlbGVtZXRyeS1jb2xsZWN0b3ItY29udHJpYi9ibG9iLzc0MjJjZTJhMDYzMzdmNjhhNTliNTUyYjhjNWEyYWMxMjVkNmJhZTUvZXhwb3J0ZXIvc2VudHJ5ZXhwb3J0ZXIvc2VudHJ5X2V4cG9ydGVyLmdvI0wzMDZcbiAqL1xuZnVuY3Rpb24gcGFyc2VTcGFuRGVzY3JpcHRpb24oc3Bhbikge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gc3Bhbkhhc0F0dHJpYnV0ZXMoc3BhbikgPyBzcGFuLmF0dHJpYnV0ZXMgOiB7fTtcbiAgY29uc3QgbmFtZSA9IHNwYW5IYXNOYW1lKHNwYW4pID8gc3Bhbi5uYW1lIDogJzx1bmtub3duPic7XG4gIGNvbnN0IGtpbmQgPSBnZXRTcGFuS2luZChzcGFuKTtcblxuICByZXR1cm4gaW5mZXJTcGFuRGF0YShuYW1lLCBhdHRyaWJ1dGVzLCBraW5kKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpcHRpb25Gb3JEYlN5c3RlbSh7IGF0dHJpYnV0ZXMsIG5hbWUgfSkge1xuICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBjdXN0b20gbmFtZSwgd2UgZG9uJ3Qgb3ZlcndyaXRlIGl0IGJ1dCBvbmx5IHNldCB0aGUgb3BcbiAgY29uc3QgdXNlckRlZmluZWROYW1lID0gYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfQ1VTVE9NX1NQQU5fTkFNRV07XG4gIGlmICh0eXBlb2YgdXNlckRlZmluZWROYW1lID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB7XG4gICAgICBvcDogJ2RiJyxcbiAgICAgIGRlc2NyaXB0aW9uOiB1c2VyRGVmaW5lZE5hbWUsXG4gICAgICBzb3VyY2U6IChhdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0VdICkgfHwgJ2N1c3RvbScsXG4gICAgfTtcbiAgfVxuXG4gIC8vIGlmIHdlIGFscmVhZHkgaGF2ZSB0aGUgc291cmNlIHNldCB0byBjdXN0b20sIHdlIGRvbid0IG92ZXJ3cml0ZSB0aGUgc3BhbiBkZXNjcmlwdGlvbiBidXQgb25seSBzZXQgdGhlIG9wXG4gIGlmIChhdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0VdID09PSAnY3VzdG9tJykge1xuICAgIHJldHVybiB7IG9wOiAnZGInLCBkZXNjcmlwdGlvbjogbmFtZSwgc291cmNlOiAnY3VzdG9tJyB9O1xuICB9XG5cbiAgLy8gVXNlIERCIHN0YXRlbWVudCAoRXggXCJTRUxFQ1QgKiBGUk9NIHRhYmxlXCIpIGlmIHBvc3NpYmxlIGFzIGRlc2NyaXB0aW9uLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgY29uc3Qgc3RhdGVtZW50ID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0RCX1NUQVRFTUVOVF07XG5cbiAgY29uc3QgZGVzY3JpcHRpb24gPSBzdGF0ZW1lbnQgPyBzdGF0ZW1lbnQudG9TdHJpbmcoKSA6IG5hbWU7XG5cbiAgcmV0dXJuIHsgb3A6ICdkYicsIGRlc2NyaXB0aW9uLCBzb3VyY2U6ICd0YXNrJyB9O1xufVxuXG4vKiogT25seSBleHBvcnRlZCBmb3IgdGVzdHMuICovXG5mdW5jdGlvbiBkZXNjcmlwdGlvbkZvckh0dHBNZXRob2QoXG4gIHsgbmFtZSwga2luZCwgYXR0cmlidXRlcyB9LFxuICBodHRwTWV0aG9kLFxuKSB7XG4gIGNvbnN0IG9wUGFydHMgPSBbJ2h0dHAnXTtcblxuICBzd2l0Y2ggKGtpbmQpIHtcbiAgICBjYXNlIGFwaS5TcGFuS2luZC5DTElFTlQ6XG4gICAgICBvcFBhcnRzLnB1c2goJ2NsaWVudCcpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhcGkuU3BhbktpbmQuU0VSVkVSOlxuICAgICAgb3BQYXJ0cy5wdXNoKCdzZXJ2ZXInKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gU3BhbnMgZm9yIEhUVFAgcmVxdWVzdHMgd2UgaGF2ZSBkZXRlcm1pbmVkIHRvIGJlIHByZWZldGNoIHJlcXVlc3RzIHdpbGwgaGF2ZSBhIGAucHJlZmV0Y2hgIHBvc3RmaXggaW4gdGhlIG9wXG4gIGlmIChhdHRyaWJ1dGVzWydzZW50cnkuaHR0cC5wcmVmZXRjaCddKSB7XG4gICAgb3BQYXJ0cy5wdXNoKCdwcmVmZXRjaCcpO1xuICB9XG5cbiAgY29uc3QgeyB1cmxQYXRoLCB1cmwsIHF1ZXJ5LCBmcmFnbWVudCwgaGFzUm91dGUgfSA9IGdldFNhbml0aXplZFVybChhdHRyaWJ1dGVzLCBraW5kKTtcblxuICBpZiAoIXVybFBhdGgpIHtcbiAgICByZXR1cm4geyAuLi5nZXRVc2VyVXBkYXRlZE5hbWVBbmRTb3VyY2UobmFtZSwgYXR0cmlidXRlcyksIG9wOiBvcFBhcnRzLmpvaW4oJy4nKSB9O1xuICB9XG5cbiAgY29uc3QgZ3JhcGhxbE9wZXJhdGlvbnNBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW1NFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfR1JBUEhRTF9PUEVSQVRJT05dO1xuXG4gIC8vIEV4LiBHRVQgL2FwaS91c2Vyc1xuICBjb25zdCBiYXNlRGVzY3JpcHRpb24gPSBgJHtodHRwTWV0aG9kfSAke3VybFBhdGh9YDtcblxuICAvLyBXaGVuIHRoZSBodHRwIHNwYW4gaGFzIGEgZ3JhcGhxbCBvcGVyYXRpb24sIGFwcGVuZCBpdCB0byB0aGUgZGVzY3JpcHRpb25cbiAgLy8gV2UgYWRkIHRoZXNlIGluIHRoZSBncmFwaHFsSW50ZWdyYXRpb25cbiAgY29uc3QgaW5mZXJyZWREZXNjcmlwdGlvbiA9IGdyYXBocWxPcGVyYXRpb25zQXR0cmlidXRlXG4gICAgPyBgJHtiYXNlRGVzY3JpcHRpb259ICgke2dldEdyYXBocWxPcGVyYXRpb25OYW1lc0Zyb21BdHRyaWJ1dGUoZ3JhcGhxbE9wZXJhdGlvbnNBdHRyaWJ1dGUpfSlgXG4gICAgOiBiYXNlRGVzY3JpcHRpb247XG5cbiAgLy8gSWYgYGh0dHBQYXRoYCBpcyBhIHJvb3QgcGF0aCwgdGhlbiB3ZSBjYW4gY2F0ZWdvcml6ZSB0aGUgdHJhbnNhY3Rpb24gc291cmNlIGFzIHJvdXRlLlxuICBjb25zdCBpbmZlcnJlZFNvdXJjZSA9IGhhc1JvdXRlIHx8IHVybFBhdGggPT09ICcvJyA/ICdyb3V0ZScgOiAndXJsJztcblxuICBjb25zdCBkYXRhID0ge307XG5cbiAgaWYgKHVybCkge1xuICAgIGRhdGEudXJsID0gdXJsO1xuICB9XG4gIGlmIChxdWVyeSkge1xuICAgIGRhdGFbJ2h0dHAucXVlcnknXSA9IHF1ZXJ5O1xuICB9XG4gIGlmIChmcmFnbWVudCkge1xuICAgIGRhdGFbJ2h0dHAuZnJhZ21lbnQnXSA9IGZyYWdtZW50O1xuICB9XG5cbiAgLy8gSWYgdGhlIHNwYW4ga2luZCBpcyBuZWl0aGVyIGNsaWVudCBub3Igc2VydmVyLCB3ZSB1c2UgdGhlIG9yaWdpbmFsIG5hbWVcbiAgLy8gdGhpcyBpbmZlcnMgdGhhdCBzb21lYm9keSBtYW51YWxseSBzdGFydGVkIHRoaXMgc3BhbiwgaW4gd2hpY2ggY2FzZSB3ZSBkb24ndCB3YW50IHRvIG92ZXJ3cml0ZSB0aGUgbmFtZVxuICBjb25zdCBpc0NsaWVudE9yU2VydmVyS2luZCA9IGtpbmQgPT09IGFwaS5TcGFuS2luZC5DTElFTlQgfHwga2luZCA9PT0gYXBpLlNwYW5LaW5kLlNFUlZFUjtcblxuICAvLyBJZiB0aGUgc3BhbiBpcyBhbiBhdXRvLXNwYW4gKD1pdCBjb21lcyBmcm9tIG9uZSBvZiBvdXIgaW5zdHJ1bWVudGF0aW9ucyksXG4gIC8vIHdlIGFsd2F5cyB3YW50IHRvIGluZmVyIHRoZSBuYW1lXG4gIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc29tZSBvZiB0aGUgYXV0by1pbnN0cnVtZW50YXRpb24gd2UgdXNlIHVzZXMga2luZD1JTlRFUk5BTFxuICBjb25zdCBvcmlnaW4gPSBhdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU5dIHx8ICdtYW51YWwnO1xuICBjb25zdCBpc01hbnVhbFNwYW4gPSAhYCR7b3JpZ2lufWAuc3RhcnRzV2l0aCgnYXV0bycpO1xuXG4gIC8vIElmIHVzZXJzIChvciBpbiB2ZXJ5IHJhcmUgb2NjYXNpb25zIHdlKSBzZXQgdGhlIHNvdXJjZSB0byBjdXN0b20sIHdlIGRvbid0IG92ZXJ3cml0ZSB0aGUgbmFtZVxuICBjb25zdCBhbHJlYWR5SGFzQ3VzdG9tU291cmNlID0gYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFXSA9PT0gJ2N1c3RvbSc7XG4gIGNvbnN0IGN1c3RvbVNwYW5OYW1lID0gYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfQ1VTVE9NX1NQQU5fTkFNRV07XG5cbiAgY29uc3QgdXNlSW5mZXJyZWREZXNjcmlwdGlvbiA9XG4gICAgIWFscmVhZHlIYXNDdXN0b21Tb3VyY2UgJiYgY3VzdG9tU3Bhbk5hbWUgPT0gbnVsbCAmJiAoaXNDbGllbnRPclNlcnZlcktpbmQgfHwgIWlzTWFudWFsU3Bhbik7XG5cbiAgY29uc3QgeyBkZXNjcmlwdGlvbiwgc291cmNlIH0gPSB1c2VJbmZlcnJlZERlc2NyaXB0aW9uXG4gICAgPyB7IGRlc2NyaXB0aW9uOiBpbmZlcnJlZERlc2NyaXB0aW9uLCBzb3VyY2U6IGluZmVycmVkU291cmNlIH1cbiAgICA6IGdldFVzZXJVcGRhdGVkTmFtZUFuZFNvdXJjZShuYW1lLCBhdHRyaWJ1dGVzKTtcblxuICByZXR1cm4ge1xuICAgIG9wOiBvcFBhcnRzLmpvaW4oJy4nKSxcbiAgICBkZXNjcmlwdGlvbixcbiAgICBzb3VyY2UsXG4gICAgZGF0YSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0R3JhcGhxbE9wZXJhdGlvbk5hbWVzRnJvbUF0dHJpYnV0ZShhdHRyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGF0dHIpKSB7XG4gICAgY29uc3Qgc29ydGVkID0gYXR0ci5zbGljZSgpLnNvcnQoKTtcblxuICAgIC8vIFVwIHRvIDUgaXRlbXMsIHdlIGp1c3QgYWRkIGFsbCBvZiB0aGVtXG4gICAgaWYgKHNvcnRlZC5sZW5ndGggPD0gNSkge1xuICAgICAgcmV0dXJuIHNvcnRlZC5qb2luKCcsICcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFbHNlLCB3ZSBhZGQgdGhlIGZpcnN0IDUgYW5kIHRoZSBkaWZmIG9mIG90aGVyIG9wZXJhdGlvbnNcbiAgICAgIHJldHVybiBgJHtzb3J0ZWQuc2xpY2UoMCwgNSkuam9pbignLCAnKX0sICske3NvcnRlZC5sZW5ndGggLSA1fWA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGAke2F0dHJ9YDtcbn1cblxuLyoqIEV4cG9ydGVkIGZvciB0ZXN0cyBvbmx5ICovXG5mdW5jdGlvbiBnZXRTYW5pdGl6ZWRVcmwoXG4gIGF0dHJpYnV0ZXMsXG4gIGtpbmQsXG4pXG5cbiB7XG4gIC8vIFRoaXMgaXMgdGhlIHJlbGF0aXZlIHBhdGggb2YgdGhlIFVSTCwgZS5nLiAvc3ViXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBjb25zdCBodHRwVGFyZ2V0ID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfVEFSR0VUXTtcbiAgLy8gVGhpcyBpcyB0aGUgZnVsbCBVUkwsIGluY2x1ZGluZyBob3N0ICYgcXVlcnkgcGFyYW1zIGV0Yy4sIGUuZy4gaHR0cHM6Ly9leGFtcGxlLmNvbS9zdWI/Zm9vPWJhclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgY29uc3QgaHR0cFVybCA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19IVFRQX1VSTF0gfHwgYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLkFUVFJfVVJMX0ZVTExdO1xuICAvLyBUaGlzIGlzIHRoZSBub3JtYWxpemVkIHJvdXRlIG5hbWUgLSBtYXkgbm90IGFsd2F5cyBiZSBhdmFpbGFibGUhXG4gIGNvbnN0IGh0dHBSb3V0ZSA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5BVFRSX0hUVFBfUk9VVEVdO1xuXG4gIGNvbnN0IHBhcnNlZFVybCA9IHR5cGVvZiBodHRwVXJsID09PSAnc3RyaW5nJyA/IGNvcmUucGFyc2VVcmwoaHR0cFVybCkgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHVybCA9IHBhcnNlZFVybCA/IGNvcmUuZ2V0U2FuaXRpemVkVXJsU3RyaW5nKHBhcnNlZFVybCkgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHF1ZXJ5ID0gcGFyc2VkVXJsPy5zZWFyY2ggfHwgdW5kZWZpbmVkO1xuICBjb25zdCBmcmFnbWVudCA9IHBhcnNlZFVybD8uaGFzaCB8fCB1bmRlZmluZWQ7XG5cbiAgaWYgKHR5cGVvZiBodHRwUm91dGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHsgdXJsUGF0aDogaHR0cFJvdXRlLCB1cmwsIHF1ZXJ5LCBmcmFnbWVudCwgaGFzUm91dGU6IHRydWUgfTtcbiAgfVxuXG4gIGlmIChraW5kID09PSBhcGkuU3BhbktpbmQuU0VSVkVSICYmIHR5cGVvZiBodHRwVGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB7IHVybFBhdGg6IGNvcmUuc3RyaXBVcmxRdWVyeUFuZEZyYWdtZW50KGh0dHBUYXJnZXQpLCB1cmwsIHF1ZXJ5LCBmcmFnbWVudCwgaGFzUm91dGU6IGZhbHNlIH07XG4gIH1cblxuICBpZiAocGFyc2VkVXJsKSB7XG4gICAgcmV0dXJuIHsgdXJsUGF0aDogdXJsLCB1cmwsIHF1ZXJ5LCBmcmFnbWVudCwgaGFzUm91dGU6IGZhbHNlIH07XG4gIH1cblxuICAvLyBmYWxsIGJhY2sgdG8gdGFyZ2V0IGV2ZW4gZm9yIGNsaWVudCBzcGFucywgaWYgbm8gVVJMIGlzIHByZXNlbnRcbiAgaWYgKHR5cGVvZiBodHRwVGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB7IHVybFBhdGg6IGNvcmUuc3RyaXBVcmxRdWVyeUFuZEZyYWdtZW50KGh0dHBUYXJnZXQpLCB1cmwsIHF1ZXJ5LCBmcmFnbWVudCwgaGFzUm91dGU6IGZhbHNlIH07XG4gIH1cblxuICByZXR1cm4geyB1cmxQYXRoOiB1bmRlZmluZWQsIHVybCwgcXVlcnksIGZyYWdtZW50LCBoYXNSb3V0ZTogZmFsc2UgfTtcbn1cblxuLyoqXG4gKiBCZWNhdXNlIE90ZWwgaW5zdHJ1bWVudGF0aW9uIHNvbWV0aW1lcyBtdXRhdGVzIHNwYW4gbmFtZXMgdmlhIGBzcGFuLnVwZGF0ZU5hbWVgLCB0aGUgb25seSB3YXlcbiAqIHRvIGVuc3VyZSB0aGF0IGEgdXNlci1zZXQgc3BhbiBuYW1lIGlzIHByZXNlcnZlZCBpcyB0byBzdG9yZSBpdCBhcyBhIHRtcCBhdHRyaWJ1dGUgb24gdGhlIHNwYW4uXG4gKiBXZSBkZWxldGUgdGhpcyBhdHRyaWJ1dGUgb25jZSB3ZSdyZSBkb25lIHdpdGggaXQgd2hlbiBwcmVwYXJpbmcgdGhlIGV2ZW50IGVudmVsb3BlLlxuICpcbiAqIFRoaXMgdGVtcCBhdHRyaWJ1dGUgYWx3YXlzIHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0aGUgb3JpZ2luYWwgbmFtZS5cbiAqXG4gKiBXZSBhbHNvIG5lZWQgdG8gdGFrZSBjYXJlIG9mIHNldHRpbmcgdGhlIGNvcnJlY3Qgc291cmNlLiBVc2VycyBjYW4gYWx3YXlzIHVwZGF0ZSB0aGUgc291cmNlXG4gKiBhZnRlciB1cGRhdGluZyB0aGUgbmFtZSwgc28gd2UgbmVlZCB0byByZXNwZWN0IHRoYXQuXG4gKlxuICogQGludGVybmFsIGV4cG9ydGVkIG9ubHkgZm9yIHRlc3RpbmdcbiAqL1xuZnVuY3Rpb24gZ2V0VXNlclVwZGF0ZWROYW1lQW5kU291cmNlKFxuICBvcmlnaW5hbE5hbWUsXG4gIGF0dHJpYnV0ZXMsXG4gIGZhbGxiYWNrU291cmNlID0gJ2N1c3RvbScsXG4pXG5cbiB7XG4gIGNvbnN0IHNvdXJjZSA9IChhdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0VdICkgfHwgZmFsbGJhY2tTb3VyY2U7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfQ1VTVE9NX1NQQU5fTkFNRV07XG5cbiAgaWYgKGRlc2NyaXB0aW9uICYmIHR5cGVvZiBkZXNjcmlwdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGVzY3JpcHRpb24sXG4gICAgICBzb3VyY2UsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7IGRlc2NyaXB0aW9uOiBvcmlnaW5hbE5hbWUsIHNvdXJjZSB9O1xufVxuXG4vKipcbiAqIFNldHVwIGEgRFNDIGhhbmRsZXIgb24gdGhlIHBhc3NlZCBjbGllbnQsXG4gKiBlbnN1cmluZyB0aGF0IHRoZSB0cmFuc2FjdGlvbiBuYW1lIGlzIGluZmVycmVkIGZyb20gdGhlIHNwYW4gY29ycmVjdGx5LlxuICovXG5mdW5jdGlvbiBlbmhhbmNlRHNjV2l0aE9wZW5UZWxlbWV0cnlSb290U3Bhbk5hbWUoY2xpZW50KSB7XG4gIGNsaWVudC5vbignY3JlYXRlRHNjJywgKGRzYywgcm9vdFNwYW4pID0+IHtcbiAgICBpZiAoIXJvb3RTcGFuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gV2Ugd2FudCB0byBvdmVyd3JpdGUgdGhlIHRyYW5zYWN0aW9uIG9uIHRoZSBEU0MgdGhhdCBpcyBjcmVhdGVkIGJ5IGRlZmF1bHQgaW4gY29yZVxuICAgIC8vIFRoZSByZWFzb24gZm9yIHRoaXMgaXMgdGhhdCB3ZSB3YW50IHRvIGluZmVyIHRoZSBzcGFuIG5hbWUsIG5vdCB1c2UgdGhlIGluaXRpYWwgb25lXG4gICAgLy8gT3RoZXJ3aXNlLCB3ZSdsbCBnZXQgbmFtZXMgbGlrZSBcIkdFVFwiIGluc3RlYWQgb2YgZS5nLiBcIkdFVCAvZm9vXCJcbiAgICAvLyBgcGFyc2VTcGFuRGVzY3JpcHRpb25gIHRha2VzIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBzcGFuIGludG8gYWNjb3VudCBmb3IgdGhlIG5hbWVcbiAgICAvLyBUaGlzIG11dGF0ZXMgdGhlIHBhc3NlZC1pbiBEU0NcblxuICAgIGNvbnN0IGpzb25TcGFuID0gY29yZS5zcGFuVG9KU09OKHJvb3RTcGFuKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ganNvblNwYW4uZGF0YTtcbiAgICBjb25zdCBzb3VyY2UgPSBhdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0VdO1xuXG4gICAgY29uc3QgeyBkZXNjcmlwdGlvbiB9ID0gc3Bhbkhhc05hbWUocm9vdFNwYW4pID8gcGFyc2VTcGFuRGVzY3JpcHRpb24ocm9vdFNwYW4pIDogeyBkZXNjcmlwdGlvbjogdW5kZWZpbmVkIH07XG4gICAgaWYgKHNvdXJjZSAhPT0gJ3VybCcgJiYgZGVzY3JpcHRpb24pIHtcbiAgICAgIGRzYy50cmFuc2FjdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgIH1cblxuICAgIC8vIEFsc28gZW5zdXJlIHNhbXBsaW5nIGRlY2lzaW9uIGlzIGNvcnJlY3RseSBpbmZlcnJlZFxuICAgIC8vIEluIGNvcmUsIHdlIHVzZSBgc3BhbklzU2FtcGxlZGAsIHdoaWNoIGp1c3QgbG9va3MgYXQgdGhlIHRyYWNlIGZsYWdzXG4gICAgLy8gYnV0IGluIE9URUwsIHdlIHVzZSBhIHNsaWdodGx5IG1vcmUgY29tcGxleCBsb2dpYyB0byBiZSBhYmxlIHRvIGRpZmZlcm50aWF0ZSBiZXR3ZWVuIHVuc2FtcGxlZCBhbmQgZGVmZXJyZWQgc2FtcGxpbmdcbiAgICBpZiAoY29yZS5oYXNTcGFuc0VuYWJsZWQoKSkge1xuICAgICAgY29uc3Qgc2FtcGxlZCA9IGdldFNhbXBsaW5nRGVjaXNpb24ocm9vdFNwYW4uc3BhbkNvbnRleHQoKSk7XG4gICAgICBkc2Muc2FtcGxlZCA9IHNhbXBsZWQgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogU3RyaW5nKHNhbXBsZWQpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudGx5IGFjdGl2ZSBzcGFuLlxuICovXG5mdW5jdGlvbiBnZXRBY3RpdmVTcGFuKCkge1xuICByZXR1cm4gYXBpLnRyYWNlLmdldEFjdGl2ZVNwYW4oKTtcbn1cblxuLyoqXG4gKiBUaGlzIHNlcnZlcyBhcyBhIGJ1aWxkIHRpbWUgZmxhZyB0aGF0IHdpbGwgYmUgdHJ1ZSBieSBkZWZhdWx0LCBidXQgZmFsc2UgaW4gbm9uLWRlYnVnIGJ1aWxkcyBvciBpZiB1c2VycyByZXBsYWNlIGBfX1NFTlRSWV9ERUJVR19fYCBpbiB0aGVpciBnZW5lcmF0ZWQgY29kZS5cbiAqXG4gKiBBVFRFTlRJT046IFRoaXMgY29uc3RhbnQgbXVzdCBuZXZlciBjcm9zcyBwYWNrYWdlIGJvdW5kYXJpZXMgKGkuZS4gYmUgZXhwb3J0ZWQpIHRvIGd1YXJhbnRlZSB0aGF0IGl0IGNhbiBiZSB1c2VkIGZvciB0cmVlIHNoYWtpbmcuXG4gKi9cbmNvbnN0IERFQlVHX0JVSUxEID0gKHR5cGVvZiBfX1NFTlRSWV9ERUJVR19fID09PSAndW5kZWZpbmVkJyB8fCBfX1NFTlRSWV9ERUJVR19fKTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIFRyYWNlU3RhdGUgZm9yIHRoZSBnaXZlbiBkYXRhLlxuICovXG5mdW5jdGlvbiBtYWtlVHJhY2VTdGF0ZSh7XG4gIGRzYyxcbiAgc2FtcGxlZCxcbn1cblxuKSB7XG4gIC8vIFdlIHN0b3JlIHRoZSBEU0MgYXMgT1RFTCB0cmFjZSBzdGF0ZSBvbiB0aGUgc3BhbiBjb250ZXh0XG4gIGNvbnN0IGRzY1N0cmluZyA9IGRzYyA/IGNvcmUuZHluYW1pY1NhbXBsaW5nQ29udGV4dFRvU2VudHJ5QmFnZ2FnZUhlYWRlcihkc2MpIDogdW5kZWZpbmVkO1xuXG4gIGNvbnN0IHRyYWNlU3RhdGVCYXNlID0gbmV3IGNvcmUkMS5UcmFjZVN0YXRlKCk7XG5cbiAgY29uc3QgdHJhY2VTdGF0ZVdpdGhEc2MgPSBkc2NTdHJpbmcgPyB0cmFjZVN0YXRlQmFzZS5zZXQoU0VOVFJZX1RSQUNFX1NUQVRFX0RTQywgZHNjU3RyaW5nKSA6IHRyYWNlU3RhdGVCYXNlO1xuXG4gIC8vIFdlIGFsc28gc3BlY2lmaWNhbGx5IHdhbnQgdG8gc3RvcmUgaWYgdGhpcyBpcyBzYW1wbGVkIHRvIGJlIG5vdCByZWNvcmRpbmcsXG4gIC8vIG9yIHVuc2FtcGxlZCAoPWNvdWxkIGJlIGVpdGhlciBzYW1wbGVkIG9yIG5vdClcbiAgcmV0dXJuIHNhbXBsZWQgPT09IGZhbHNlID8gdHJhY2VTdGF0ZVdpdGhEc2Muc2V0KFNFTlRSWV9UUkFDRV9TVEFURV9TQU1QTEVEX05PVF9SRUNPUkRJTkcsICcxJykgOiB0cmFjZVN0YXRlV2l0aERzYztcbn1cblxuY29uc3Qgc2V0dXBFbGVtZW50cyA9IG5ldyBTZXQoKTtcblxuLyoqIEdldCBhbGwgdGhlIE9wZW5UZWxlbWV0cnkgZWxlbWVudHMgdGhhdCBoYXZlIGJlZW4gc2V0IHVwLiAqL1xuZnVuY3Rpb24gb3BlblRlbGVtZXRyeVNldHVwQ2hlY2soKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHNldHVwRWxlbWVudHMpO1xufVxuXG4vKiogTWFyayBhbiBPcGVuVGVsZW1ldHJ5IGVsZW1lbnQgYXMgc2V0dXAuICovXG5mdW5jdGlvbiBzZXRJc1NldHVwKGVsZW1lbnQpIHtcbiAgc2V0dXBFbGVtZW50cy5hZGQoZWxlbWVudCk7XG59XG5cbi8qKlxuICogSW5qZWN0cyBhbmQgZXh0cmFjdHMgYHNlbnRyeS10cmFjZWAgYW5kIGBiYWdnYWdlYCBoZWFkZXJzIGZyb20gY2FycmllcnMuXG4gKi9cbmNsYXNzIFNlbnRyeVByb3BhZ2F0b3IgZXh0ZW5kcyBjb3JlJDEuVzNDQmFnZ2FnZVByb3BhZ2F0b3Ige1xuICAvKiogQSBtYXAgb2YgVVJMcyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGNoZWNrZWQgZm9yIGlmIHRoZXkgbWF0Y2ggdHJhY2VQcm9wYWdhdGlvblRhcmdldHMuICovXG5cbiAgIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgc2V0SXNTZXR1cCgnU2VudHJ5UHJvcGFnYXRvcicpO1xuXG4gICAgLy8gV2UncmUgY2FjaGluZyByZXN1bHRzIHNvIHdlIGRvbid0IGhhdmUgdG8gcmVjb21wdXRlIHJlZ2V4cCBldmVyeSB0aW1lIHdlIGNyZWF0ZSBhIHJlcXVlc3QuXG4gICAgdGhpcy5fdXJsTWF0Y2hlc1RhcmdldHNNYXAgPSBuZXcgY29yZS5MUlVNYXAoMTAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIGluamVjdChjb250ZXh0LCBjYXJyaWVyLCBzZXR0ZXIpIHtcbiAgICBpZiAoY29yZSQxLmlzVHJhY2luZ1N1cHByZXNzZWQoY29udGV4dCkpIHtcbiAgICAgIERFQlVHX0JVSUxEICYmIGNvcmUuZGVidWcubG9nKCdbVHJhY2luZ10gTm90IGluamVjdGluZyB0cmFjZSBkYXRhIGZvciB1cmwgYmVjYXVzZSB0cmFjaW5nIGlzIHN1cHByZXNzZWQuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYWN0aXZlU3BhbiA9IGFwaS50cmFjZS5nZXRTcGFuKGNvbnRleHQpO1xuICAgIGNvbnN0IHVybCA9IGFjdGl2ZVNwYW4gJiYgZ2V0Q3VycmVudFVSTChhY3RpdmVTcGFuKTtcblxuICAgIGNvbnN0IHRyYWNlUHJvcGFnYXRpb25UYXJnZXRzID0gY29yZS5nZXRDbGllbnQoKT8uZ2V0T3B0aW9ucygpPy50cmFjZVByb3BhZ2F0aW9uVGFyZ2V0cztcbiAgICBpZiAoIXNob3VsZFByb3BhZ2F0ZVRyYWNlRm9yVXJsKHVybCwgdHJhY2VQcm9wYWdhdGlvblRhcmdldHMsIHRoaXMuX3VybE1hdGNoZXNUYXJnZXRzTWFwKSkge1xuICAgICAgREVCVUdfQlVJTEQgJiZcbiAgICAgICAgY29yZS5kZWJ1Zy5sb2coJ1tUcmFjaW5nXSBOb3QgaW5qZWN0aW5nIHRyYWNlIGRhdGEgZm9yIHVybCBiZWNhdXNlIGl0IGRvZXMgbm90IG1hdGNoIHRyYWNlUHJvcGFnYXRpb25UYXJnZXRzOicsIHVybCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZXhpc3RpbmdCYWdnYWdlSGVhZGVyID0gZ2V0RXhpc3RpbmdCYWdnYWdlKGNhcnJpZXIpO1xuICAgIGxldCBiYWdnYWdlID0gYXBpLnByb3BhZ2F0aW9uLmdldEJhZ2dhZ2UoY29udGV4dCkgfHwgYXBpLnByb3BhZ2F0aW9uLmNyZWF0ZUJhZ2dhZ2Uoe30pO1xuXG4gICAgY29uc3QgeyBkeW5hbWljU2FtcGxpbmdDb250ZXh0LCB0cmFjZUlkLCBzcGFuSWQsIHNhbXBsZWQgfSA9IGdldEluamVjdGlvbkRhdGEoY29udGV4dCk7XG5cbiAgICBpZiAoZXhpc3RpbmdCYWdnYWdlSGVhZGVyKSB7XG4gICAgICBjb25zdCBiYWdnYWdlRW50cmllcyA9IGNvcmUucGFyc2VCYWdnYWdlSGVhZGVyKGV4aXN0aW5nQmFnZ2FnZUhlYWRlcik7XG5cbiAgICAgIGlmIChiYWdnYWdlRW50cmllcykge1xuICAgICAgICBPYmplY3QuZW50cmllcyhiYWdnYWdlRW50cmllcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgYmFnZ2FnZSA9IGJhZ2dhZ2Uuc2V0RW50cnkoa2V5LCB7IHZhbHVlIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZHluYW1pY1NhbXBsaW5nQ29udGV4dCkge1xuICAgICAgYmFnZ2FnZSA9IE9iamVjdC5lbnRyaWVzKGR5bmFtaWNTYW1wbGluZ0NvbnRleHQpLnJlZHVjZSgoYiwgW2RzY0tleSwgZHNjVmFsdWVdKSA9PiB7XG4gICAgICAgIGlmIChkc2NWYWx1ZSkge1xuICAgICAgICAgIHJldHVybiBiLnNldEVudHJ5KGAke2NvcmUuU0VOVFJZX0JBR0dBR0VfS0VZX1BSRUZJWH0ke2RzY0tleX1gLCB7IHZhbHVlOiBkc2NWYWx1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH0sIGJhZ2dhZ2UpO1xuICAgIH1cblxuICAgIC8vIFdlIGFsc28gd2FudCB0byBhdm9pZCBzZXR0aW5nIHRoZSBkZWZhdWx0IE9URUwgdHJhY2UgSUQsIGlmIHdlIGdldCB0aGF0IGZvciB3aGF0ZXZlciByZWFzb25cbiAgICBpZiAodHJhY2VJZCAmJiB0cmFjZUlkICE9PSBhcGkuSU5WQUxJRF9UUkFDRUlEKSB7XG4gICAgICBzZXR0ZXIuc2V0KGNhcnJpZXIsIFNFTlRSWV9UUkFDRV9IRUFERVIsIGNvcmUuZ2VuZXJhdGVTZW50cnlUcmFjZUhlYWRlcih0cmFjZUlkLCBzcGFuSWQsIHNhbXBsZWQpKTtcbiAgICB9XG5cbiAgICBzdXBlci5pbmplY3QoYXBpLnByb3BhZ2F0aW9uLnNldEJhZ2dhZ2UoY29udGV4dCwgYmFnZ2FnZSksIGNhcnJpZXIsIHNldHRlcik7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBleHRyYWN0KGNvbnRleHQsIGNhcnJpZXIsIGdldHRlcikge1xuICAgIGNvbnN0IG1heWJlU2VudHJ5VHJhY2VIZWFkZXIgPSBnZXR0ZXIuZ2V0KGNhcnJpZXIsIFNFTlRSWV9UUkFDRV9IRUFERVIpO1xuICAgIGNvbnN0IGJhZ2dhZ2UgPSBnZXR0ZXIuZ2V0KGNhcnJpZXIsIFNFTlRSWV9CQUdHQUdFX0hFQURFUik7XG5cbiAgICBjb25zdCBzZW50cnlUcmFjZSA9IG1heWJlU2VudHJ5VHJhY2VIZWFkZXJcbiAgICAgID8gQXJyYXkuaXNBcnJheShtYXliZVNlbnRyeVRyYWNlSGVhZGVyKVxuICAgICAgICA/IG1heWJlU2VudHJ5VHJhY2VIZWFkZXJbMF1cbiAgICAgICAgOiBtYXliZVNlbnRyeVRyYWNlSGVhZGVyXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIC8vIEFkZCByZW1vdGUgcGFyZW50IHNwYW4gY29udGV4dFxuICAgIC8vIElmIHRoZXJlIGlzIG5vIGluY29taW5nIHRyYWNlLCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBjb250ZXh0IGFzLWlzXG4gICAgcmV0dXJuIGVuc3VyZVNjb3Blc09uQ29udGV4dChnZXRDb250ZXh0V2l0aFJlbW90ZUFjdGl2ZVNwYW4oY29udGV4dCwgeyBzZW50cnlUcmFjZSwgYmFnZ2FnZSB9KSk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBmaWVsZHMoKSB7XG4gICAgcmV0dXJuIFtTRU5UUllfVFJBQ0VfSEVBREVSLCBTRU5UUllfQkFHR0FHRV9IRUFERVJdO1xuICB9XG59XG5cbmNvbnN0IE5PVF9QUk9QQUdBVEVEX01FU1NBR0UgPVxuICAnW1RyYWNpbmddIE5vdCBpbmplY3RpbmcgdHJhY2UgZGF0YSBmb3IgdXJsIGJlY2F1c2UgaXQgZG9lcyBub3QgbWF0Y2ggdHJhY2VQcm9wYWdhdGlvblRhcmdldHM6JztcblxuLyoqXG4gKiBDaGVjayBpZiBhIGdpdmVuIFVSTCBzaG91bGQgYmUgcHJvcGFnYXRlZCB0byBvciBub3QuXG4gKiBJZiBubyB1cmwgaXMgZGVmaW5lZCwgb3Igbm8gdHJhY2UgcHJvcGFnYXRpb24gdGFyZ2V0cyBhcmUgZGVmaW5lZCwgdGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gYHRydWVgLlxuICogWW91IGNhbiBhbHNvIG9wdGlvbmFsbHkgcHJvdmlkZSBhIGRlY2lzaW9uIG1hcCwgdG8gY2FjaGUgZGVjaXNpb25zIGFuZCBhdm9pZCByZXBlYXRlZCByZWdleCBsb29rdXBzLlxuICovXG5mdW5jdGlvbiBzaG91bGRQcm9wYWdhdGVUcmFjZUZvclVybChcbiAgdXJsLFxuICB0cmFjZVByb3BhZ2F0aW9uVGFyZ2V0cyxcbiAgZGVjaXNpb25NYXAsXG4pIHtcbiAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnIHx8ICF0cmFjZVByb3BhZ2F0aW9uVGFyZ2V0cykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgY2FjaGVkRGVjaXNpb24gPSBkZWNpc2lvbk1hcD8uZ2V0KHVybCk7XG4gIGlmIChjYWNoZWREZWNpc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgREVCVUdfQlVJTEQgJiYgIWNhY2hlZERlY2lzaW9uICYmIGNvcmUuZGVidWcubG9nKE5PVF9QUk9QQUdBVEVEX01FU1NBR0UsIHVybCk7XG4gICAgcmV0dXJuIGNhY2hlZERlY2lzaW9uO1xuICB9XG5cbiAgY29uc3QgZGVjaXNpb24gPSBjb3JlLnN0cmluZ01hdGNoZXNTb21lUGF0dGVybih1cmwsIHRyYWNlUHJvcGFnYXRpb25UYXJnZXRzKTtcbiAgZGVjaXNpb25NYXA/LnNldCh1cmwsIGRlY2lzaW9uKTtcblxuICBERUJVR19CVUlMRCAmJiAhZGVjaXNpb24gJiYgY29yZS5kZWJ1Zy5sb2coTk9UX1BST1BBR0FURURfTUVTU0FHRSwgdXJsKTtcbiAgcmV0dXJuIGRlY2lzaW9uO1xufVxuXG4vKipcbiAqIEdldCBwcm9wYWdhdGlvbiBpbmplY3Rpb24gZGF0YSBmb3IgdGhlIGdpdmVuIGNvbnRleHQuXG4gKiBUaGUgYWRkaXRpb25hbCBvcHRpb25zIGNhbiBiZSBwYXNzZWQgdG8gb3ZlcnJpZGUgdGhlIHNjb3BlIGFuZCBjbGllbnQgdGhhdCBpcyBvdGhlcndpc2UgZGVyaXZlZCBmcm9tIHRoZSBjb250ZXh0LlxuICovXG5mdW5jdGlvbiBnZXRJbmplY3Rpb25EYXRhKFxuICBjb250ZXh0LFxuICBvcHRpb25zID0ge30sXG4pXG5cbiB7XG4gIGNvbnN0IHNwYW4gPSBhcGkudHJhY2UuZ2V0U3Bhbihjb250ZXh0KTtcblxuICAvLyBJZiB3ZSBoYXZlIGEgcmVtb3RlIHNwYW4sIHRoZSBzcGFuSWQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYXMgdGhlIHBhcmVudFNwYW5JZCwgbm90IHNwYW5JZCBpdHNlbGZcbiAgLy8gSW5zdGVhZCwgd2UgdXNlIGEgdmlydHVhbCAoZ2VuZXJhdGVkKSBzcGFuSWQgZm9yIHByb3BhZ2F0aW9uXG4gIGlmIChzcGFuPy5zcGFuQ29udGV4dCgpLmlzUmVtb3RlKSB7XG4gICAgY29uc3Qgc3BhbkNvbnRleHQgPSBzcGFuLnNwYW5Db250ZXh0KCk7XG4gICAgY29uc3QgZHluYW1pY1NhbXBsaW5nQ29udGV4dCA9IGNvcmUuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuKHNwYW4pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGR5bmFtaWNTYW1wbGluZ0NvbnRleHQsXG4gICAgICB0cmFjZUlkOiBzcGFuQ29udGV4dC50cmFjZUlkLFxuICAgICAgc3BhbklkOiB1bmRlZmluZWQsXG4gICAgICBzYW1wbGVkOiBnZXRTYW1wbGluZ0RlY2lzaW9uKHNwYW5Db250ZXh0KSwgLy8gVE9ETzogRG8gd2UgbmVlZCB0byBjaGFuZ2Ugc29tZXRoaW5nIGhlcmU/XG4gICAgfTtcbiAgfVxuXG4gIC8vIElmIHdlIGhhdmUgYSBsb2NhbCBzcGFuLCB3ZSBqdXN0IHVzZSB0aGlzXG4gIGlmIChzcGFuKSB7XG4gICAgY29uc3Qgc3BhbkNvbnRleHQgPSBzcGFuLnNwYW5Db250ZXh0KCk7XG4gICAgY29uc3QgZHluYW1pY1NhbXBsaW5nQ29udGV4dCA9IGNvcmUuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuKHNwYW4pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGR5bmFtaWNTYW1wbGluZ0NvbnRleHQsXG4gICAgICB0cmFjZUlkOiBzcGFuQ29udGV4dC50cmFjZUlkLFxuICAgICAgc3BhbklkOiBzcGFuQ29udGV4dC5zcGFuSWQsXG4gICAgICBzYW1wbGVkOiBnZXRTYW1wbGluZ0RlY2lzaW9uKHNwYW5Db250ZXh0KSwgLy8gVE9ETzogRG8gd2UgbmVlZCB0byBjaGFuZ2Ugc29tZXRoaW5nIGhlcmU/XG4gICAgfTtcbiAgfVxuXG4gIC8vIEVsc2Ugd2UgdHJ5IHRvIHVzZSB0aGUgcHJvcGFnYXRpb24gY29udGV4dCBmcm9tIHRoZSBzY29wZVxuICAvLyBUaGUgb25seSBzY2VuYXJpbyB3aGVyZSB0aGlzIHNob3VsZCBoYXBwZW4gaXMgd2hlbiB3ZSBuZWl0aGVyIGhhdmUgYSBzcGFuLCBub3IgYW4gaW5jb21pbmcgdHJhY2VcbiAgY29uc3Qgc2NvcGUgPSBvcHRpb25zLnNjb3BlIHx8IGdldFNjb3Blc0Zyb21Db250ZXh0KGNvbnRleHQpPy5zY29wZSB8fCBjb3JlLmdldEN1cnJlbnRTY29wZSgpO1xuICBjb25zdCBjbGllbnQgPSBvcHRpb25zLmNsaWVudCB8fCBjb3JlLmdldENsaWVudCgpO1xuXG4gIGNvbnN0IHByb3BhZ2F0aW9uQ29udGV4dCA9IHNjb3BlLmdldFByb3BhZ2F0aW9uQ29udGV4dCgpO1xuICBjb25zdCBkeW5hbWljU2FtcGxpbmdDb250ZXh0ID0gY2xpZW50ID8gY29yZS5nZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNjb3BlKGNsaWVudCwgc2NvcGUpIDogdW5kZWZpbmVkO1xuICByZXR1cm4ge1xuICAgIGR5bmFtaWNTYW1wbGluZ0NvbnRleHQsXG4gICAgdHJhY2VJZDogcHJvcGFnYXRpb25Db250ZXh0LnRyYWNlSWQsXG4gICAgc3BhbklkOiBwcm9wYWdhdGlvbkNvbnRleHQucHJvcGFnYXRpb25TcGFuSWQsXG4gICAgc2FtcGxlZDogcHJvcGFnYXRpb25Db250ZXh0LnNhbXBsZWQsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHRXaXRoUmVtb3RlQWN0aXZlU3BhbihcbiAgY3R4LFxuICB7IHNlbnRyeVRyYWNlLCBiYWdnYWdlIH0sXG4pIHtcbiAgY29uc3QgcHJvcGFnYXRpb25Db250ZXh0ID0gY29yZS5wcm9wYWdhdGlvbkNvbnRleHRGcm9tSGVhZGVycyhzZW50cnlUcmFjZSwgYmFnZ2FnZSk7XG5cbiAgY29uc3QgeyB0cmFjZUlkLCBwYXJlbnRTcGFuSWQsIHNhbXBsZWQsIGRzYyB9ID0gcHJvcGFnYXRpb25Db250ZXh0O1xuXG4gIGNvbnN0IGNsaWVudCA9IGNvcmUuZ2V0Q2xpZW50KCk7XG4gIGNvbnN0IGluY29taW5nRHNjID0gY29yZS5iYWdnYWdlSGVhZGVyVG9EeW5hbWljU2FtcGxpbmdDb250ZXh0KGJhZ2dhZ2UpO1xuXG4gIC8vIFdlIG9ubHkgd2FudCB0byBzZXQgdGhlIHZpcnR1YWwgc3BhbiBpZiB3ZSBhcmUgY29udGludWluZyBhIGNvbmNyZXRlIHRyYWNlXG4gIC8vIE90aGVyd2lzZSwgd2UgaWdub3JlIHRoZSBpbmNvbWluZyB0cmFjZSBoZXJlLCBlLmcuIGlmIHdlIGhhdmUgbm8gdHJhY2UgaGVhZGVyc1xuICBpZiAoIXBhcmVudFNwYW5JZCB8fCAoY2xpZW50ICYmICFjb3JlLnNob3VsZENvbnRpbnVlVHJhY2UoY2xpZW50LCBpbmNvbWluZ0RzYz8ub3JnX2lkKSkpIHtcbiAgICByZXR1cm4gY3R4O1xuICB9XG5cbiAgY29uc3Qgc3BhbkNvbnRleHQgPSBnZW5lcmF0ZVJlbW90ZVNwYW5Db250ZXh0KHtcbiAgICB0cmFjZUlkLFxuICAgIHNwYW5JZDogcGFyZW50U3BhbklkLFxuICAgIHNhbXBsZWQsXG4gICAgZHNjLFxuICB9KTtcblxuICByZXR1cm4gYXBpLnRyYWNlLnNldFNwYW5Db250ZXh0KGN0eCwgc3BhbkNvbnRleHQpO1xufVxuXG4vKipcbiAqIFRha2VzIHRyYWNlIHN0cmluZ3MgYW5kIHByb3BhZ2F0ZXMgdGhlbSBhcyBhIHJlbW90ZSBhY3RpdmUgc3Bhbi5cbiAqIFRoaXMgc2hvdWxkIGJlIHVzZWQgaW4gYWRkaXRpb24gdG8gYGNvbnRpbnVlVHJhY2VgIGluIE9URUwtcG93ZXJlZCBlbnZpcm9ubWVudHMuXG4gKi9cbmZ1bmN0aW9uIGNvbnRpbnVlVHJhY2VBc1JlbW90ZVNwYW4oXG4gIGN0eCxcbiAgb3B0aW9ucyxcbiAgY2FsbGJhY2ssXG4pIHtcbiAgY29uc3QgY3R4V2l0aFNwYW5Db250ZXh0ID0gZW5zdXJlU2NvcGVzT25Db250ZXh0KGdldENvbnRleHRXaXRoUmVtb3RlQWN0aXZlU3BhbihjdHgsIG9wdGlvbnMpKTtcblxuICByZXR1cm4gYXBpLmNvbnRleHQud2l0aChjdHhXaXRoU3BhbkNvbnRleHQsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlU2NvcGVzT25Db250ZXh0KGN0eCkge1xuICAvLyBJZiB0aGVyZSBhcmUgbm8gc2NvcGVzIHlldCBvbiB0aGUgY29udGV4dCwgZW5zdXJlIHdlIGhhdmUgdGhlbVxuICBjb25zdCBzY29wZXMgPSBnZXRTY29wZXNGcm9tQ29udGV4dChjdHgpO1xuICBjb25zdCBuZXdTY29wZXMgPSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBubyBzY29wZSBoZXJlLCB0aGlzIGlzIG1vc3QgbGlrZWx5IGVpdGhlciB0aGUgcm9vdCBjb250ZXh0IG9yIGEgY29udGV4dCBtYW51YWxseSBkZXJpdmVkIGZyb20gaXRcbiAgICAvLyBJbiB0aGlzIGNhc2UsIHdlIHdhbnQgdG8gZm9yayB0aGUgY3VycmVudCBzY29wZSwgdG8gZW5zdXJlIHdlIGRvIG5vdCBwb2xsdXRlIHRoZSByb290IHNjb3BlXG4gICAgc2NvcGU6IHNjb3BlcyA/IHNjb3Blcy5zY29wZSA6IGNvcmUuZ2V0Q3VycmVudFNjb3BlKCkuY2xvbmUoKSxcbiAgICBpc29sYXRpb25TY29wZTogc2NvcGVzID8gc2NvcGVzLmlzb2xhdGlvblNjb3BlIDogY29yZS5nZXRJc29sYXRpb25TY29wZSgpLFxuICB9O1xuXG4gIHJldHVybiBzZXRTY29wZXNPbkNvbnRleHQoY3R4LCBuZXdTY29wZXMpO1xufVxuXG4vKiogVHJ5IHRvIGdldCB0aGUgZXhpc3RpbmcgYmFnZ2FnZSBoZWFkZXIgc28gd2UgY2FuIG1lcmdlIHRoaXMgaW4uICovXG5mdW5jdGlvbiBnZXRFeGlzdGluZ0JhZ2dhZ2UoY2Fycmllcikge1xuICB0cnkge1xuICAgIGNvbnN0IGJhZ2dhZ2UgPSAoY2FycmllciApW1NFTlRSWV9CQUdHQUdFX0hFQURFUl07XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYmFnZ2FnZSkgPyBiYWdnYWdlLmpvaW4oJywnKSA6IGJhZ2dhZ2U7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBJdCBpcyBwcmV0dHkgdHJpY2t5IHRvIGdldCBhY2Nlc3MgdG8gdGhlIG91dGdvaW5nIHJlcXVlc3QgVVJMIG9mIGEgcmVxdWVzdCBpbiB0aGUgcHJvcGFnYXRvci5cbiAqIEFzIHdlIG9ubHkgaGF2ZSBhY2Nlc3MgdG8gdGhlIGNvbnRleHQgb2YgdGhlIHNwYW4gdG8gYmUgc2VudCBhbmQgdGhlIGNhcnJpZXIgKD1oZWFkZXJzKSxcbiAqIGJ1dCB0aGUgc3BhbiBtYXkgYmUgdW5zYW1wbGVkIGFuZCB0aHVzIGhhdmUgbm8gYXR0cmlidXRlcy5cbiAqXG4gKiBTbyB3ZSB1c2UgdGhlIGZvbGxvd2luZyBsb2dpYzpcbiAqIDEuIElmIHdlIGhhdmUgYW4gYWN0aXZlIHNwYW4sIHdlIGNoZWNrIGlmIGl0IGhhcyBhIFVSTCBhdHRyaWJ1dGUuXG4gKiAyLiBFbHNlLCBpZiB0aGUgYWN0aXZlIHNwYW4gaGFzIG5vIFVSTCBhdHRyaWJ1dGUgKGUuZy4gaXQgaXMgdW5zYW1wbGVkKSwgd2UgY2hlY2sgYSBzcGVjaWFsIHRyYWNlIHN0YXRlICh3aGljaCB3ZSBzZXQgaW4gb3VyIHNhbXBsZXIpLlxuICovXG5mdW5jdGlvbiBnZXRDdXJyZW50VVJMKHNwYW4pIHtcbiAgY29uc3Qgc3BhbkRhdGEgPSBjb3JlLnNwYW5Ub0pTT04oc3BhbikuZGF0YTtcbiAgLy8gYEFUVFJfVVJMX0ZVTExgIGlzIHRoZSBuZXcgYXR0cmlidXRlLCBidXQgd2Ugc3RpbGwgc3VwcG9ydCB0aGUgb2xkIG9uZSwgYFNFTUFUVFJTX0hUVFBfVVJMYCwgZm9yIG5vdy5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIGNvbnN0IHVybEF0dHJpYnV0ZSA9IHNwYW5EYXRhW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9VUkxdIHx8IHNwYW5EYXRhW3NlbWFudGljQ29udmVudGlvbnMuQVRUUl9VUkxfRlVMTF07XG4gIGlmICh0eXBlb2YgdXJsQXR0cmlidXRlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB1cmxBdHRyaWJ1dGU7XG4gIH1cblxuICAvLyBBbHNvIGxvb2sgYXQgdGhlIHRyYWNlU3RhdGUsIHdoaWNoIHdlIG1heSBzZXQgaW4gdGhlIHNhbXBsZXIgZXZlbiBmb3IgdW5zYW1wbGVkIHNwYW5zXG4gIGNvbnN0IHVybFRyYWNlU3RhdGUgPSBzcGFuLnNwYW5Db250ZXh0KCkudHJhY2VTdGF0ZT8uZ2V0KFNFTlRSWV9UUkFDRV9TVEFURV9VUkwpO1xuICBpZiAodXJsVHJhY2VTdGF0ZSkge1xuICAgIHJldHVybiB1cmxUcmFjZVN0YXRlO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVSZW1vdGVTcGFuQ29udGV4dCh7XG4gIHNwYW5JZCxcbiAgdHJhY2VJZCxcbiAgc2FtcGxlZCxcbiAgZHNjLFxufVxuXG4pIHtcbiAgLy8gV2Ugc3RvcmUgdGhlIERTQyBhcyBPVEVMIHRyYWNlIHN0YXRlIG9uIHRoZSBzcGFuIGNvbnRleHRcbiAgY29uc3QgdHJhY2VTdGF0ZSA9IG1ha2VUcmFjZVN0YXRlKHtcbiAgICBkc2MsXG4gICAgc2FtcGxlZCxcbiAgfSk7XG5cbiAgY29uc3Qgc3BhbkNvbnRleHQgPSB7XG4gICAgdHJhY2VJZCxcbiAgICBzcGFuSWQsXG4gICAgaXNSZW1vdGU6IHRydWUsXG4gICAgdHJhY2VGbGFnczogc2FtcGxlZCA/IGFwaS5UcmFjZUZsYWdzLlNBTVBMRUQgOiBhcGkuVHJhY2VGbGFncy5OT05FLFxuICAgIHRyYWNlU3RhdGUsXG4gIH07XG5cbiAgcmV0dXJuIHNwYW5Db250ZXh0O1xufVxuXG4vKipcbiAqIFdyYXBzIGEgZnVuY3Rpb24gd2l0aCBhIHRyYW5zYWN0aW9uL3NwYW4gYW5kIGZpbmlzaGVzIHRoZSBzcGFuIGFmdGVyIHRoZSBmdW5jdGlvbiBpcyBkb25lLlxuICogVGhlIGNyZWF0ZWQgc3BhbiBpcyB0aGUgYWN0aXZlIHNwYW4gYW5kIHdpbGwgYmUgdXNlZCBhcyBwYXJlbnQgYnkgb3RoZXIgc3BhbnMgY3JlYXRlZCBpbnNpZGUgdGhlIGZ1bmN0aW9uXG4gKiBhbmQgY2FuIGJlIGFjY2Vzc2VkIHZpYSBgU2VudHJ5LmdldEFjdGl2ZVNwYW4oKWAsIGFzIGxvbmcgYXMgdGhlIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIHdoaWxlIHRoZSBzY29wZSBpcyBhY3RpdmUuXG4gKlxuICogSWYgeW91IHdhbnQgdG8gY3JlYXRlIGEgc3BhbiB0aGF0IGlzIG5vdCBzZXQgYXMgYWN0aXZlLCB1c2Uge0BsaW5rIHN0YXJ0SW5hY3RpdmVTcGFufS5cbiAqXG4gKiBZb3UnbGwgYWx3YXlzIGdldCBhIHNwYW4gcGFzc2VkIHRvIHRoZSBjYWxsYmFjayxcbiAqIGl0IG1heSBqdXN0IGJlIGEgbm9uLXJlY29yZGluZyBzcGFuIGlmIHRoZSBzcGFuIGlzIG5vdCBzYW1wbGVkIG9yIGlmIHRyYWNpbmcgaXMgZGlzYWJsZWQuXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0U3BhbihvcHRpb25zLCBjYWxsYmFjaykge1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIoKTtcblxuICBjb25zdCB7IG5hbWUsIHBhcmVudFNwYW46IGN1c3RvbVBhcmVudFNwYW4gfSA9IG9wdGlvbnM7XG5cbiAgLy8gSWYgYG9wdGlvbnMucGFyZW50U3BhbmAgaXMgZGVmaW5lZCwgd2Ugd2FudCB0byB3cmFwIHRoZSBjYWxsYmFjayBpbiBgd2l0aEFjdGl2ZVNwYW5gXG4gIGNvbnN0IHdyYXBwZXIgPSBnZXRBY3RpdmVTcGFuV3JhcHBlcihjdXN0b21QYXJlbnRTcGFuKTtcblxuICByZXR1cm4gd3JhcHBlcigoKSA9PiB7XG4gICAgY29uc3QgYWN0aXZlQ3R4ID0gZ2V0Q29udGV4dChvcHRpb25zLnNjb3BlLCBvcHRpb25zLmZvcmNlVHJhbnNhY3Rpb24pO1xuICAgIGNvbnN0IHNob3VsZFNraXBTcGFuID0gb3B0aW9ucy5vbmx5SWZQYXJlbnQgJiYgIWFwaS50cmFjZS5nZXRTcGFuKGFjdGl2ZUN0eCk7XG4gICAgY29uc3QgY3R4ID0gc2hvdWxkU2tpcFNwYW4gPyBjb3JlJDEuc3VwcHJlc3NUcmFjaW5nKGFjdGl2ZUN0eCkgOiBhY3RpdmVDdHg7XG5cbiAgICBjb25zdCBzcGFuT3B0aW9ucyA9IGdldFNwYW5PcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHRyYWNlci5zdGFydEFjdGl2ZVNwYW4obmFtZSwgc3Bhbk9wdGlvbnMsIGN0eCwgc3BhbiA9PiB7XG4gICAgICByZXR1cm4gY29yZS5oYW5kbGVDYWxsYmFja0Vycm9ycyhcbiAgICAgICAgKCkgPT4gY2FsbGJhY2soc3BhbiksXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICAvLyBPbmx5IHNldCB0aGUgc3BhbiBzdGF0dXMgdG8gRVJST1Igd2hlbiB0aGVyZSB3YXNuJ3QgYW55IHN0YXR1cyBzZXQgYmVmb3JlLCBpbiBvcmRlciB0byBhdm9pZCBzdG9tcGluZyB1c2VmdWwgc3BhbiBzdGF0dXNlc1xuICAgICAgICAgIGlmIChjb3JlLnNwYW5Ub0pTT04oc3Bhbikuc3RhdHVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHsgY29kZTogYXBpLlNwYW5TdGF0dXNDb2RlLkVSUk9SIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgKCkgPT4gc3Bhbi5lbmQoKSxcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNpbWlsYXIgdG8gYFNlbnRyeS5zdGFydFNwYW5gLiBXcmFwcyBhIGZ1bmN0aW9uIHdpdGggYSBzcGFuLCBidXQgZG9lcyBub3QgZmluaXNoIHRoZSBzcGFuXG4gKiBhZnRlciB0aGUgZnVuY3Rpb24gaXMgZG9uZSBhdXRvbWF0aWNhbGx5LiBZb3UnbGwgaGF2ZSB0byBjYWxsIGBzcGFuLmVuZCgpYCBtYW51YWxseS5cbiAqXG4gKiBUaGUgY3JlYXRlZCBzcGFuIGlzIHRoZSBhY3RpdmUgc3BhbiBhbmQgd2lsbCBiZSB1c2VkIGFzIHBhcmVudCBieSBvdGhlciBzcGFucyBjcmVhdGVkIGluc2lkZSB0aGUgZnVuY3Rpb25cbiAqIGFuZCBjYW4gYmUgYWNjZXNzZWQgdmlhIGBTZW50cnkuZ2V0QWN0aXZlU3BhbigpYCwgYXMgbG9uZyBhcyB0aGUgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgd2hpbGUgdGhlIHNjb3BlIGlzIGFjdGl2ZS5cbiAqXG4gKiBZb3UnbGwgYWx3YXlzIGdldCBhIHNwYW4gcGFzc2VkIHRvIHRoZSBjYWxsYmFjayxcbiAqIGl0IG1heSBqdXN0IGJlIGEgbm9uLXJlY29yZGluZyBzcGFuIGlmIHRoZSBzcGFuIGlzIG5vdCBzYW1wbGVkIG9yIGlmIHRyYWNpbmcgaXMgZGlzYWJsZWQuXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0U3Bhbk1hbnVhbChcbiAgb3B0aW9ucyxcbiAgY2FsbGJhY2ssXG4pIHtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKCk7XG5cbiAgY29uc3QgeyBuYW1lLCBwYXJlbnRTcGFuOiBjdXN0b21QYXJlbnRTcGFuIH0gPSBvcHRpb25zO1xuXG4gIC8vIElmIGBvcHRpb25zLnBhcmVudFNwYW5gIGlzIGRlZmluZWQsIHdlIHdhbnQgdG8gd3JhcCB0aGUgY2FsbGJhY2sgaW4gYHdpdGhBY3RpdmVTcGFuYFxuICBjb25zdCB3cmFwcGVyID0gZ2V0QWN0aXZlU3BhbldyYXBwZXIoY3VzdG9tUGFyZW50U3Bhbik7XG5cbiAgcmV0dXJuIHdyYXBwZXIoKCkgPT4ge1xuICAgIGNvbnN0IGFjdGl2ZUN0eCA9IGdldENvbnRleHQob3B0aW9ucy5zY29wZSwgb3B0aW9ucy5mb3JjZVRyYW5zYWN0aW9uKTtcbiAgICBjb25zdCBzaG91bGRTa2lwU3BhbiA9IG9wdGlvbnMub25seUlmUGFyZW50ICYmICFhcGkudHJhY2UuZ2V0U3BhbihhY3RpdmVDdHgpO1xuICAgIGNvbnN0IGN0eCA9IHNob3VsZFNraXBTcGFuID8gY29yZSQxLnN1cHByZXNzVHJhY2luZyhhY3RpdmVDdHgpIDogYWN0aXZlQ3R4O1xuXG4gICAgY29uc3Qgc3Bhbk9wdGlvbnMgPSBnZXRTcGFuT3B0aW9ucyhvcHRpb25zKTtcblxuICAgIHJldHVybiB0cmFjZXIuc3RhcnRBY3RpdmVTcGFuKG5hbWUsIHNwYW5PcHRpb25zLCBjdHgsIHNwYW4gPT4ge1xuICAgICAgcmV0dXJuIGNvcmUuaGFuZGxlQ2FsbGJhY2tFcnJvcnMoXG4gICAgICAgICgpID0+IGNhbGxiYWNrKHNwYW4sICgpID0+IHNwYW4uZW5kKCkpLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgLy8gT25seSBzZXQgdGhlIHNwYW4gc3RhdHVzIHRvIEVSUk9SIHdoZW4gdGhlcmUgd2Fzbid0IGFueSBzdGF0dXMgc2V0IGJlZm9yZSwgaW4gb3JkZXIgdG8gYXZvaWQgc3RvbXBpbmcgdXNlZnVsIHNwYW4gc3RhdHVzZXNcbiAgICAgICAgICBpZiAoY29yZS5zcGFuVG9KU09OKHNwYW4pLnN0YXR1cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzcGFuLnNldFN0YXR1cyh7IGNvZGU6IGFwaS5TcGFuU3RhdHVzQ29kZS5FUlJPUiB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3Bhbi4gVGhpcyBzcGFuIGlzIG5vdCBzZXQgYXMgYWN0aXZlLCBzbyB3aWxsIG5vdCBnZXQgYXV0b21hdGljIGluc3RydW1lbnRhdGlvbiBzcGFuc1xuICogYXMgY2hpbGRyZW4gb3IgYmUgYWJsZSB0byBiZSBhY2Nlc3NlZCB2aWEgYFNlbnRyeS5nZXRBY3RpdmVTcGFuKClgLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIGNyZWF0ZSBhIHNwYW4gdGhhdCBpcyBzZXQgYXMgYWN0aXZlLCB1c2Uge0BsaW5rIHN0YXJ0U3Bhbn0uXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGFsd2F5cyByZXR1cm4gYSBzcGFuLFxuICogaXQgbWF5IGp1c3QgYmUgYSBub24tcmVjb3JkaW5nIHNwYW4gaWYgdGhlIHNwYW4gaXMgbm90IHNhbXBsZWQgb3IgaWYgdHJhY2luZyBpcyBkaXNhYmxlZC5cbiAqL1xuZnVuY3Rpb24gc3RhcnRJbmFjdGl2ZVNwYW4ob3B0aW9ucykge1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIoKTtcblxuICBjb25zdCB7IG5hbWUsIHBhcmVudFNwYW46IGN1c3RvbVBhcmVudFNwYW4gfSA9IG9wdGlvbnM7XG5cbiAgLy8gSWYgYG9wdGlvbnMucGFyZW50U3BhbmAgaXMgZGVmaW5lZCwgd2Ugd2FudCB0byB3cmFwIHRoZSBjYWxsYmFjayBpbiBgd2l0aEFjdGl2ZVNwYW5gXG4gIGNvbnN0IHdyYXBwZXIgPSBnZXRBY3RpdmVTcGFuV3JhcHBlcihjdXN0b21QYXJlbnRTcGFuKTtcblxuICByZXR1cm4gd3JhcHBlcigoKSA9PiB7XG4gICAgY29uc3QgYWN0aXZlQ3R4ID0gZ2V0Q29udGV4dChvcHRpb25zLnNjb3BlLCBvcHRpb25zLmZvcmNlVHJhbnNhY3Rpb24pO1xuICAgIGNvbnN0IHNob3VsZFNraXBTcGFuID0gb3B0aW9ucy5vbmx5SWZQYXJlbnQgJiYgIWFwaS50cmFjZS5nZXRTcGFuKGFjdGl2ZUN0eCk7XG4gICAgY29uc3QgY3R4ID0gc2hvdWxkU2tpcFNwYW4gPyBjb3JlJDEuc3VwcHJlc3NUcmFjaW5nKGFjdGl2ZUN0eCkgOiBhY3RpdmVDdHg7XG5cbiAgICBjb25zdCBzcGFuT3B0aW9ucyA9IGdldFNwYW5PcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgY29uc3Qgc3BhbiA9IHRyYWNlci5zdGFydFNwYW4obmFtZSwgc3Bhbk9wdGlvbnMsIGN0eCk7XG5cbiAgICByZXR1cm4gc3BhbjtcbiAgfSk7XG59XG5cbi8qKlxuICogRm9ya3MgdGhlIGN1cnJlbnQgc2NvcGUgYW5kIHNldHMgdGhlIHByb3ZpZGVkIHNwYW4gYXMgYWN0aXZlIHNwYW4gaW4gdGhlIGNvbnRleHQgb2YgdGhlIHByb3ZpZGVkIGNhbGxiYWNrLiBDYW4gYmVcbiAqIHBhc3NlZCBgbnVsbGAgdG8gc3RhcnQgYW4gZW50aXJlbHkgbmV3IHNwYW4gdHJlZS5cbiAqXG4gKiBAcGFyYW0gc3BhbiBTcGFucyBzdGFydGVkIGluIHRoZSBjb250ZXh0IG9mIHRoZSBwcm92aWRlZCBjYWxsYmFjayB3aWxsIGJlIGNoaWxkcmVuIG9mIHRoaXMgc3Bhbi4gSWYgYG51bGxgIGlzIHBhc3NlZCxcbiAqIHNwYW5zIHN0YXJ0ZWQgd2l0aGluIHRoZSBjYWxsYmFjayB3aWxsIGJlIHJvb3Qgc3BhbnMuXG4gKiBAcGFyYW0gY2FsbGJhY2sgRXhlY3V0aW9uIGNvbnRleHQgaW4gd2hpY2ggdGhlIHByb3ZpZGVkIHNwYW4gd2lsbCBiZSBhY3RpdmUuIElzIHBhc3NlZCB0aGUgbmV3bHkgZm9ya2VkIHNjb3BlLlxuICogQHJldHVybnMgdGhlIHZhbHVlIHJldHVybmVkIGZyb20gdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB3aXRoQWN0aXZlU3BhbihzcGFuLCBjYWxsYmFjaykge1xuICBjb25zdCBuZXdDb250ZXh0V2l0aEFjdGl2ZVNwYW4gPSBzcGFuID8gYXBpLnRyYWNlLnNldFNwYW4oYXBpLmNvbnRleHQuYWN0aXZlKCksIHNwYW4pIDogYXBpLnRyYWNlLmRlbGV0ZVNwYW4oYXBpLmNvbnRleHQuYWN0aXZlKCkpO1xuICByZXR1cm4gYXBpLmNvbnRleHQud2l0aChuZXdDb250ZXh0V2l0aEFjdGl2ZVNwYW4sICgpID0+IGNhbGxiYWNrKGNvcmUuZ2V0Q3VycmVudFNjb3BlKCkpKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJhY2VyKCkge1xuICBjb25zdCBjbGllbnQgPSBjb3JlLmdldENsaWVudCgpO1xuICByZXR1cm4gY2xpZW50Py50cmFjZXIgfHwgYXBpLnRyYWNlLmdldFRyYWNlcignQHNlbnRyeS9vcGVudGVsZW1ldHJ5JywgY29yZS5TREtfVkVSU0lPTik7XG59XG5cbmZ1bmN0aW9uIGdldFNwYW5PcHRpb25zKG9wdGlvbnMpIHtcbiAgY29uc3QgeyBzdGFydFRpbWUsIGF0dHJpYnV0ZXMsIGtpbmQsIG9wLCBsaW5rcyB9ID0gb3B0aW9ucztcblxuICAvLyBPVEVMIGV4cGVjdHMgdGltZXN0YW1wcyBpbiBtcywgbm90IHNlY29uZHNcbiAgY29uc3QgZml4ZWRTdGFydFRpbWUgPSB0eXBlb2Ygc3RhcnRUaW1lID09PSAnbnVtYmVyJyA/IGVuc3VyZVRpbWVzdGFtcEluTWlsbGlzZWNvbmRzKHN0YXJ0VGltZSkgOiBzdGFydFRpbWU7XG5cbiAgcmV0dXJuIHtcbiAgICBhdHRyaWJ1dGVzOiBvcFxuICAgICAgPyB7XG4gICAgICAgICAgW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUF06IG9wLFxuICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgIH1cbiAgICAgIDogYXR0cmlidXRlcyxcbiAgICBraW5kLFxuICAgIGxpbmtzLFxuICAgIHN0YXJ0VGltZTogZml4ZWRTdGFydFRpbWUsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGVuc3VyZVRpbWVzdGFtcEluTWlsbGlzZWNvbmRzKHRpbWVzdGFtcCkge1xuICBjb25zdCBpc01zID0gdGltZXN0YW1wIDwgOTk5OTk5OTk5OTtcbiAgcmV0dXJuIGlzTXMgPyB0aW1lc3RhbXAgKiAxMDAwIDogdGltZXN0YW1wO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0KHNjb3BlLCBmb3JjZVRyYW5zYWN0aW9uKSB7XG4gIGNvbnN0IGN0eCA9IGdldENvbnRleHRGb3JTY29wZShzY29wZSk7XG4gIGNvbnN0IHBhcmVudFNwYW4gPSBhcGkudHJhY2UuZ2V0U3BhbihjdHgpO1xuXG4gIC8vIEluIHRoZSBjYXNlIHRoYXQgd2UgaGF2ZSBubyBwYXJlbnQgc3Bhbiwgd2Ugc3RhcnQgYSBuZXcgdHJhY2VcbiAgLy8gTm90ZSB0aGF0IGlmIHdlIGNvbnRpbnVlIGEgdHJhY2UsIHdlJ2xsIGFsd2F5cyBoYXZlIGEgcmVtb3RlIHBhcmVudCBzcGFuIGhlcmUgYW55aG93XG4gIGlmICghcGFyZW50U3Bhbikge1xuICAgIHJldHVybiBjdHg7XG4gIH1cblxuICAvLyBJZiB3ZSBkb24ndCB3YW50IHRvIGZvcmNlIGEgdHJhbnNhY3Rpb24sIGFuZCB3ZSBoYXZlIGEgcGFyZW50IHNwYW4sIGFsbCBnb29kLCB3ZSBqdXN0IHJldHVybiBhcy1pcyFcbiAgaWYgKCFmb3JjZVRyYW5zYWN0aW9uKSB7XG4gICAgcmV0dXJuIGN0eDtcbiAgfVxuXG4gIC8vIEVsc2UsIGlmIHdlIGRvIGhhdmUgYSBwYXJlbnQgc3BhbiBidXQgd2FudCB0byBmb3JjZSBhIHRyYW5zYWN0aW9uLCB3ZSBoYXZlIHRvIHNpbXVsYXRlIGEgXCJyb290XCIgY29udGV4dFxuXG4gIC8vIEVsc2UsIHdlIG5lZWQgdG8gZG8gdHdvIHRoaW5nczpcbiAgLy8gMS4gVW5zZXQgdGhlIHBhcmVudCBzcGFuIGZyb20gdGhlIGNvbnRleHQsIHNvIHdlJ2xsIGNyZWF0ZSBhIG5ldyByb290IHNwYW5cbiAgLy8gMi4gRW5zdXJlIHRoZSBwcm9wYWdhdGlvbiBjb250ZXh0IGlzIGNvcnJlY3QsIHNvIHdlJ2xsIGNvbnRpbnVlIGZyb20gdGhlIHBhcmVudCBzcGFuXG4gIGNvbnN0IGN0eFdpdGhvdXRTcGFuID0gYXBpLnRyYWNlLmRlbGV0ZVNwYW4oY3R4KTtcblxuICBjb25zdCB7IHNwYW5JZCwgdHJhY2VJZCB9ID0gcGFyZW50U3Bhbi5zcGFuQ29udGV4dCgpO1xuICBjb25zdCBzYW1wbGVkID0gZ2V0U2FtcGxpbmdEZWNpc2lvbihwYXJlbnRTcGFuLnNwYW5Db250ZXh0KCkpO1xuXG4gIC8vIEluIHRoaXMgY2FzZSwgd2hlbiB3ZSBhcmUgZm9yY2luZyBhIHRyYW5zYWN0aW9uLCB3ZSB3YW50IHRvIHRyZWF0IHRoaXMgbGlrZSBjb250aW51aW5nIGFuIGluY29taW5nIHRyYWNlXG4gIC8vIHNvIHdlIHNldCB0aGUgdHJhY2VTdGF0ZSBhY2NvcmRpbmcgdG8gdGhlIHJvb3Qgc3BhblxuICBjb25zdCByb290U3BhbiA9IGNvcmUuZ2V0Um9vdFNwYW4ocGFyZW50U3Bhbik7XG4gIGNvbnN0IGRzYyA9IGNvcmUuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuKHJvb3RTcGFuKTtcblxuICBjb25zdCB0cmFjZVN0YXRlID0gbWFrZVRyYWNlU3RhdGUoe1xuICAgIGRzYyxcbiAgICBzYW1wbGVkLFxuICB9KTtcblxuICBjb25zdCBzcGFuT3B0aW9ucyA9IHtcbiAgICB0cmFjZUlkLFxuICAgIHNwYW5JZCxcbiAgICBpc1JlbW90ZTogdHJ1ZSxcbiAgICB0cmFjZUZsYWdzOiBzYW1wbGVkID8gYXBpLlRyYWNlRmxhZ3MuU0FNUExFRCA6IGFwaS5UcmFjZUZsYWdzLk5PTkUsXG4gICAgdHJhY2VTdGF0ZSxcbiAgfTtcblxuICBjb25zdCBjdHhXaXRoU3BhbkNvbnRleHQgPSBhcGkudHJhY2Uuc2V0U3BhbkNvbnRleHQoY3R4V2l0aG91dFNwYW4sIHNwYW5PcHRpb25zKTtcblxuICByZXR1cm4gY3R4V2l0aFNwYW5Db250ZXh0O1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0Rm9yU2NvcGUoc2NvcGUpIHtcbiAgaWYgKHNjb3BlKSB7XG4gICAgY29uc3QgY3R4ID0gZ2V0Q29udGV4dEZyb21TY29wZShzY29wZSk7XG4gICAgaWYgKGN0eCkge1xuICAgICAgcmV0dXJuIGN0eDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXBpLmNvbnRleHQuYWN0aXZlKCk7XG59XG5cbi8qKlxuICogQ29udGludWUgYSB0cmFjZSBmcm9tIGBzZW50cnktdHJhY2VgIGFuZCBgYmFnZ2FnZWAgdmFsdWVzLlxuICogVGhlc2UgdmFsdWVzIGNhbiBiZSBvYnRhaW5lZCBmcm9tIGluY29taW5nIHJlcXVlc3QgaGVhZGVycywgb3IgaW4gdGhlIGJyb3dzZXIgZnJvbSBgPG1ldGEgbmFtZT1cInNlbnRyeS10cmFjZVwiPmBcbiAqIGFuZCBgPG1ldGEgbmFtZT1cImJhZ2dhZ2VcIj5gIEhUTUwgdGFncy5cbiAqXG4gKiBTcGFucyBzdGFydGVkIHdpdGggYHN0YXJ0U3BhbmAsIGBzdGFydFNwYW5NYW51YWxgIGFuZCBgc3RhcnRJbmFjdGl2ZVNwYW5gLCB3aXRoaW4gdGhlIGNhbGxiYWNrIHdpbGwgYXV0b21hdGljYWxseVxuICogYmUgYXR0YWNoZWQgdG8gdGhlIGluY29taW5nIHRyYWNlLlxuICpcbiAqIFRoaXMgaXMgYSBjdXN0b20gdmVyc2lvbiBvZiBgY29udGludWVUcmFjZWAgdGhhdCBpcyB1c2VkIGluIE9URUwtcG93ZXJlZCBlbnZpcm9ubWVudHMuXG4gKiBJdCBwcm9wYWdhdGVzIHRoZSB0cmFjZSBhcyBhIHJlbW90ZSBzcGFuLCBpbiBhZGRpdGlvbiB0byBzZXR0aW5nIGl0IG9uIHRoZSBwcm9wYWdhdGlvbiBjb250ZXh0LlxuICovXG5mdW5jdGlvbiBjb250aW51ZVRyYWNlKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBjb250aW51ZVRyYWNlQXNSZW1vdGVTcGFuKGFwaS5jb250ZXh0LmFjdGl2ZSgpLCBvcHRpb25zLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogR2V0IHRoZSB0cmFjZSBjb250ZXh0IGZvciBhIGdpdmVuIHNjb3BlLlxuICogV2UgaGF2ZSBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiBoZXJlIGJlY2F1c2Ugd2UgbmVlZCBhbiBPVEVMLXNwZWNpZmljIHdheSB0byBnZXQgdGhlIHNwYW4gZnJvbSBhIHNjb3BlLlxuICovXG5mdW5jdGlvbiBnZXRUcmFjZUNvbnRleHRGb3JTY29wZShcbiAgY2xpZW50LFxuICBzY29wZSxcbikge1xuICBjb25zdCBjdHggPSBnZXRDb250ZXh0RnJvbVNjb3BlKHNjb3BlKTtcbiAgY29uc3Qgc3BhbiA9IGN0eCAmJiBhcGkudHJhY2UuZ2V0U3BhbihjdHgpO1xuXG4gIGNvbnN0IHRyYWNlQ29udGV4dCA9IHNwYW4gPyBjb3JlLnNwYW5Ub1RyYWNlQ29udGV4dChzcGFuKSA6IGNvcmUuZ2V0VHJhY2VDb250ZXh0RnJvbVNjb3BlKHNjb3BlKTtcblxuICBjb25zdCBkeW5hbWljU2FtcGxpbmdDb250ZXh0ID0gc3BhblxuICAgID8gY29yZS5nZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW4oc3BhbilcbiAgICA6IGNvcmUuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TY29wZShjbGllbnQsIHNjb3BlKTtcbiAgcmV0dXJuIFtkeW5hbWljU2FtcGxpbmdDb250ZXh0LCB0cmFjZUNvbnRleHRdO1xufVxuXG5mdW5jdGlvbiBnZXRBY3RpdmVTcGFuV3JhcHBlcihwYXJlbnRTcGFuKSB7XG4gIHJldHVybiBwYXJlbnRTcGFuICE9PSB1bmRlZmluZWRcbiAgICA/IChjYWxsYmFjaykgPT4ge1xuICAgICAgICByZXR1cm4gd2l0aEFjdGl2ZVNwYW4ocGFyZW50U3BhbiwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIDogKGNhbGxiYWNrKSA9PiBjYWxsYmFjaygpO1xufVxuXG4vKiogU3VwcHJlc3MgdHJhY2luZyBpbiB0aGUgZ2l2ZW4gY2FsbGJhY2ssIGVuc3VyaW5nIG5vIHNwYW5zIGFyZSBnZW5lcmF0ZWQgaW5zaWRlIG9mIGl0LiAqL1xuZnVuY3Rpb24gc3VwcHJlc3NUcmFjaW5nKGNhbGxiYWNrKSB7XG4gIGNvbnN0IGN0eCA9IGNvcmUkMS5zdXBwcmVzc1RyYWNpbmcoYXBpLmNvbnRleHQuYWN0aXZlKCkpO1xuICByZXR1cm4gYXBpLmNvbnRleHQud2l0aChjdHgsIGNhbGxiYWNrKTtcbn1cblxuLyoqIEVuc3VyZSB0aGUgYHRyYWNlYCBjb250ZXh0IGlzIHNldCBvbiBhbGwgZXZlbnRzLiAqL1xuZnVuY3Rpb24gc2V0dXBFdmVudENvbnRleHRUcmFjZShjbGllbnQpIHtcbiAgY2xpZW50Lm9uKCdwcmVwcm9jZXNzRXZlbnQnLCBldmVudCA9PiB7XG4gICAgY29uc3Qgc3BhbiA9IGdldEFjdGl2ZVNwYW4oKTtcbiAgICAvLyBGb3IgdHJhbnNhY3Rpb24gZXZlbnRzLCB0aGlzIGlzIGhhbmRsZWQgc2VwYXJhdGVseVxuICAgIC8vIEJlY2F1c2UgdGhlIGFjdGl2ZSBzcGFuIG1heSBub3QgYmUgdGhlIHNwYW4gdGhhdCBpcyBhY3R1YWxseSB0aGUgdHJhbnNhY3Rpb24gZXZlbnRcbiAgICBpZiAoIXNwYW4gfHwgZXZlbnQudHlwZSA9PT0gJ3RyYW5zYWN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIGV2ZW50IGhhcyBhbHJlYWR5IHNldCBgdHJhY2VgIGNvbnRleHQsIHVzZSB0aGF0IG9uZS5cbiAgICBldmVudC5jb250ZXh0cyA9IHtcbiAgICAgIHRyYWNlOiBjb3JlLnNwYW5Ub1RyYWNlQ29udGV4dChzcGFuKSxcbiAgICAgIC4uLmV2ZW50LmNvbnRleHRzLFxuICAgIH07XG5cbiAgICBjb25zdCByb290U3BhbiA9IGNvcmUuZ2V0Um9vdFNwYW4oc3Bhbik7XG5cbiAgICBldmVudC5zZGtQcm9jZXNzaW5nTWV0YWRhdGEgPSB7XG4gICAgICBkeW5hbWljU2FtcGxpbmdDb250ZXh0OiBjb3JlLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3Bhbihyb290U3BhbiksXG4gICAgICAuLi5ldmVudC5zZGtQcm9jZXNzaW5nTWV0YWRhdGEsXG4gICAgfTtcblxuICAgIHJldHVybiBldmVudDtcbiAgfSk7XG59XG5cbi8qKlxuICogT3RlbC1zcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VHJhY2VEYXRhYC5cbiAqIEBzZWUgYEBzZW50cnkvY29yZWAgdmVyc2lvbiBvZiBgZ2V0VHJhY2VEYXRhYCBmb3IgbW9yZSBpbmZvcm1hdGlvblxuICovXG5mdW5jdGlvbiBnZXRUcmFjZURhdGEoe1xuICBzcGFuLFxuICBzY29wZSxcbiAgY2xpZW50LFxufSA9IHt9KSB7XG4gIGxldCBjdHggPSAoc2NvcGUgJiYgZ2V0Q29udGV4dEZyb21TY29wZShzY29wZSkpID8/IGFwaS5jb250ZXh0LmFjdGl2ZSgpO1xuXG4gIGlmIChzcGFuKSB7XG4gICAgY29uc3QgeyBzY29wZSB9ID0gY29yZS5nZXRDYXB0dXJlZFNjb3Blc09uU3BhbihzcGFuKTtcbiAgICAvLyBmYWxsIGJhY2sgdG8gY3VycmVudCBjb250ZXh0IGlmIGZvciB3aGF0ZXZlciByZWFzb24gd2UgY2FuJ3QgZmluZCB0aGUgb25lIG9mIHRoZSBzcGFuXG4gICAgY3R4ID0gKHNjb3BlICYmIGdldENvbnRleHRGcm9tU2NvcGUoc2NvcGUpKSB8fCBhcGkudHJhY2Uuc2V0U3BhbihhcGkuY29udGV4dC5hY3RpdmUoKSwgc3Bhbik7XG4gIH1cblxuICBjb25zdCB7IHRyYWNlSWQsIHNwYW5JZCwgc2FtcGxlZCwgZHluYW1pY1NhbXBsaW5nQ29udGV4dCB9ID0gZ2V0SW5qZWN0aW9uRGF0YShjdHgsIHsgc2NvcGUsIGNsaWVudCB9KTtcblxuICByZXR1cm4ge1xuICAgICdzZW50cnktdHJhY2UnOiBjb3JlLmdlbmVyYXRlU2VudHJ5VHJhY2VIZWFkZXIodHJhY2VJZCwgc3BhbklkLCBzYW1wbGVkKSxcbiAgICBiYWdnYWdlOiBjb3JlLmR5bmFtaWNTYW1wbGluZ0NvbnRleHRUb1NlbnRyeUJhZ2dhZ2VIZWFkZXIoZHluYW1pY1NhbXBsaW5nQ29udGV4dCksXG4gIH07XG59XG5cbi8qKlxuICogU2V0cyB0aGUgYXN5bmMgY29udGV4dCBzdHJhdGVneSB0byB1c2UgZm9sbG93IHRoZSBPVEVMIGNvbnRleHQgdW5kZXIgdGhlIGhvb2QuXG4gKiBXZSBoYW5kbGUgZm9ya2luZyBhIGh1YiBpbnNpZGUgb2Ygb3VyIGN1c3RvbSBPVEVMIENvbnRleHQgTWFuYWdlciAoLi9vdGVsQ29udGV4dE1hbmFnZXIudHMpXG4gKi9cbmZ1bmN0aW9uIHNldE9wZW5UZWxlbWV0cnlDb250ZXh0QXN5bmNDb250ZXh0U3RyYXRlZ3koKSB7XG4gIGZ1bmN0aW9uIGdldFNjb3BlcygpIHtcbiAgICBjb25zdCBjdHggPSBhcGkuY29udGV4dC5hY3RpdmUoKTtcbiAgICBjb25zdCBzY29wZXMgPSBnZXRTY29wZXNGcm9tQ29udGV4dChjdHgpO1xuXG4gICAgaWYgKHNjb3Blcykge1xuICAgICAgcmV0dXJuIHNjb3BlcztcbiAgICB9XG5cbiAgICAvLyBmYWxsYmFjayBiZWhhdmlvcjpcbiAgICAvLyBpZiwgZm9yIHdoYXRldmVyIHJlYXNvbiwgd2UgY2FuJ3QgZmluZCBzY29wZXMgb24gdGhlIGNvbnRleHQgaGVyZSwgd2UgaGF2ZSB0byBmaXggdGhpcyBzb21laG93XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjb3BlOiBjb3JlLmdldERlZmF1bHRDdXJyZW50U2NvcGUoKSxcbiAgICAgIGlzb2xhdGlvblNjb3BlOiBjb3JlLmdldERlZmF1bHRJc29sYXRpb25TY29wZSgpLFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3aXRoU2NvcGUoY2FsbGJhY2spIHtcbiAgICBjb25zdCBjdHggPSBhcGkuY29udGV4dC5hY3RpdmUoKTtcblxuICAgIC8vIFdlIGRlcGVuZCBvbiB0aGUgb3RlbENvbnRleHRNYW5hZ2VyIHRvIGhhbmRsZSB0aGUgY29udGV4dC9odWJcbiAgICAvLyBXZSBzZXQgdGhlIGBTRU5UUllfRk9SS19JU09MQVRJT05fU0NPUEVfQ09OVEVYVF9LRVlgIGNvbnRleHQgdmFsdWUsIHdoaWNoIGlzIHBpY2tlZCB1cCBieVxuICAgIC8vIHRoZSBPVEVMIGNvbnRleHQgbWFuYWdlciwgd2hpY2ggdXNlcyB0aGUgcHJlc2VuY2Ugb2YgdGhpcyBrZXkgdG8gZGV0ZXJtaW5lIGlmIGl0IHNob3VsZFxuICAgIC8vIGZvcmsgdGhlIGlzb2xhdGlvbiBzY29wZSwgb3Igbm90XG4gICAgLy8gYXMgYnkgZGVmYXVsdCwgd2UgZG9uJ3Qgd2FudCB0byBmb3JrIHRoaXMsIHVubGVzcyB0cmlnZ2VyZWQgZXhwbGljaXRseSBieSBgd2l0aFNjb3BlYFxuICAgIHJldHVybiBhcGkuY29udGV4dC53aXRoKGN0eCwgKCkgPT4ge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGdldEN1cnJlbnRTY29wZSgpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpdGhTZXRTY29wZShzY29wZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBjdHggPSBnZXRDb250ZXh0RnJvbVNjb3BlKHNjb3BlKSB8fCBhcGkuY29udGV4dC5hY3RpdmUoKTtcblxuICAgIC8vIFdlIGRlcGVuZCBvbiB0aGUgb3RlbENvbnRleHRNYW5hZ2VyIHRvIGhhbmRsZSB0aGUgY29udGV4dC9odWJcbiAgICAvLyBXZSBzZXQgdGhlIGBTRU5UUllfRk9SS19TRVRfU0NPUEVfQ09OVEVYVF9LRVlgIGNvbnRleHQgdmFsdWUsIHdoaWNoIGlzIHBpY2tlZCB1cCBieVxuICAgIC8vIHRoZSBPVEVMIGNvbnRleHQgbWFuYWdlciwgd2hpY2ggcGlja3MgdXAgdGhpcyBzY29wZSBhcyB0aGUgY3VycmVudCBzY29wZVxuICAgIHJldHVybiBhcGkuY29udGV4dC53aXRoKGN0eC5zZXRWYWx1ZShTRU5UUllfRk9SS19TRVRfU0NPUEVfQ09OVEVYVF9LRVksIHNjb3BlKSwgKCkgPT4ge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHNjb3BlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpdGhJc29sYXRpb25TY29wZShjYWxsYmFjaykge1xuICAgIGNvbnN0IGN0eCA9IGFwaS5jb250ZXh0LmFjdGl2ZSgpO1xuXG4gICAgLy8gV2UgZGVwZW5kIG9uIHRoZSBvdGVsQ29udGV4dE1hbmFnZXIgdG8gaGFuZGxlIHRoZSBjb250ZXh0L2h1YlxuICAgIC8vIFdlIHNldCB0aGUgYFNFTlRSWV9GT1JLX0lTT0xBVElPTl9TQ09QRV9DT05URVhUX0tFWWAgY29udGV4dCB2YWx1ZSwgd2hpY2ggaXMgcGlja2VkIHVwIGJ5XG4gICAgLy8gdGhlIE9URUwgY29udGV4dCBtYW5hZ2VyLCB3aGljaCB1c2VzIHRoZSBwcmVzZW5jZSBvZiB0aGlzIGtleSB0byBkZXRlcm1pbmUgaWYgaXQgc2hvdWxkXG4gICAgLy8gZm9yayB0aGUgaXNvbGF0aW9uIHNjb3BlLCBvciBub3RcbiAgICByZXR1cm4gYXBpLmNvbnRleHQud2l0aChjdHguc2V0VmFsdWUoU0VOVFJZX0ZPUktfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZLCB0cnVlKSwgKCkgPT4ge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGdldElzb2xhdGlvblNjb3BlKCkpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gd2l0aFNldElzb2xhdGlvblNjb3BlKGlzb2xhdGlvblNjb3BlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGN0eCA9IGFwaS5jb250ZXh0LmFjdGl2ZSgpO1xuXG4gICAgLy8gV2UgZGVwZW5kIG9uIHRoZSBvdGVsQ29udGV4dE1hbmFnZXIgdG8gaGFuZGxlIHRoZSBjb250ZXh0L2h1YlxuICAgIC8vIFdlIHNldCB0aGUgYFNFTlRSWV9GT1JLX0lTT0xBVElPTl9TQ09QRV9DT05URVhUX0tFWWAgY29udGV4dCB2YWx1ZSwgd2hpY2ggaXMgcGlja2VkIHVwIGJ5XG4gICAgLy8gdGhlIE9URUwgY29udGV4dCBtYW5hZ2VyLCB3aGljaCB1c2VzIHRoZSBwcmVzZW5jZSBvZiB0aGlzIGtleSB0byBkZXRlcm1pbmUgaWYgaXQgc2hvdWxkXG4gICAgLy8gZm9yayB0aGUgaXNvbGF0aW9uIHNjb3BlLCBvciBub3RcbiAgICByZXR1cm4gYXBpLmNvbnRleHQud2l0aChjdHguc2V0VmFsdWUoU0VOVFJZX0ZPUktfU0VUX0lTT0xBVElPTl9TQ09QRV9DT05URVhUX0tFWSwgaXNvbGF0aW9uU2NvcGUpLCAoKSA9PiB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZ2V0SXNvbGF0aW9uU2NvcGUoKSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDdXJyZW50U2NvcGUoKSB7XG4gICAgcmV0dXJuIGdldFNjb3BlcygpLnNjb3BlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SXNvbGF0aW9uU2NvcGUoKSB7XG4gICAgcmV0dXJuIGdldFNjb3BlcygpLmlzb2xhdGlvblNjb3BlO1xuICB9XG5cbiAgY29yZS5zZXRBc3luY0NvbnRleHRTdHJhdGVneSh7XG4gICAgd2l0aFNjb3BlLFxuICAgIHdpdGhTZXRTY29wZSxcbiAgICB3aXRoU2V0SXNvbGF0aW9uU2NvcGUsXG4gICAgd2l0aElzb2xhdGlvblNjb3BlLFxuICAgIGdldEN1cnJlbnRTY29wZSxcbiAgICBnZXRJc29sYXRpb25TY29wZSxcbiAgICBzdGFydFNwYW4sXG4gICAgc3RhcnRTcGFuTWFudWFsLFxuICAgIHN0YXJ0SW5hY3RpdmVTcGFuLFxuICAgIGdldEFjdGl2ZVNwYW4sXG4gICAgc3VwcHJlc3NUcmFjaW5nLFxuICAgIGdldFRyYWNlRGF0YSxcbiAgICBjb250aW51ZVRyYWNlLFxuICAgIC8vIFRoZSB0eXBlcyBoZXJlIGRvbid0IGZ1bGx5IGFsaWduLCBiZWNhdXNlIG91ciBvd24gYFNwYW5gIHR5cGUgaXMgbmFycm93ZXJcbiAgICAvLyB0aGFuIHRoZSBPVEVMIG9uZSAtIGJ1dCB0aGlzIGlzIE9LIGZvciBoZXJlLCBhcyB3ZSBub3cgd2UnbGwgb25seSBoYXZlIE9URUwgc3BhbnMgcGFzc2VkIGFyb3VuZFxuICAgIHdpdGhBY3RpdmVTcGFuOiB3aXRoQWN0aXZlU3BhbiAsXG4gIH0pO1xufVxuXG4vKipcbiAqIFdyYXAgYW4gT3BlblRlbGVtZXRyeSBDb250ZXh0TWFuYWdlciBpbiBhIHdheSB0aGF0IGVuc3VyZXMgdGhlIGNvbnRleHQgaXMga2VwdCBpbiBzeW5jIHdpdGggdGhlIFNlbnRyeSBTY29wZS5cbiAqXG4gKiBVc2FnZTpcbiAqIGltcG9ydCB7IEFzeW5jTG9jYWxTdG9yYWdlQ29udGV4dE1hbmFnZXIgfSBmcm9tICdAb3BlbnRlbGVtZXRyeS9jb250ZXh0LWFzeW5jLWhvb2tzJztcbiAqIGNvbnN0IFNlbnRyeUNvbnRleHRNYW5hZ2VyID0gd3JhcENvbnRleHRNYW5hZ2VyQ2xhc3MoQXN5bmNMb2NhbFN0b3JhZ2VDb250ZXh0TWFuYWdlcik7XG4gKiBjb25zdCBjb250ZXh0TWFuYWdlciA9IG5ldyBTZW50cnlDb250ZXh0TWFuYWdlcigpO1xuICovXG5mdW5jdGlvbiB3cmFwQ29udGV4dE1hbmFnZXJDbGFzcyhcbiAgQ29udGV4dE1hbmFnZXJDbGFzcyxcbikge1xuICAvKipcbiAgICogVGhpcyBpcyBhIGN1c3RvbSBDb250ZXh0TWFuYWdlciBmb3IgT3BlblRlbGVtZXRyeSwgd2hpY2ggZXh0ZW5kcyB0aGUgZGVmYXVsdCBBc3luY0xvY2FsU3RvcmFnZUNvbnRleHRNYW5hZ2VyLlxuICAgKiBJdCBlbnN1cmVzIHRoYXQgd2UgY3JlYXRlIG5ldyBzY29wZXMgcGVyIGNvbnRleHQsIHNvIHRoYXQgdGhlIE9URUwgQ29udGV4dCAmIHRoZSBTZW50cnkgU2NvcGUgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgd2UgY3VycmVudGx5IG9ubHkgc3VwcG9ydCBBc3luY0hvb2tzIHdpdGggdGhpcyxcbiAgICogYnV0IHNpbmNlIHRoaXMgc2hvdWxkIHdvcmsgZm9yIE5vZGUgMTQrIGFueWhvdyB0aGF0IHNob3VsZCBiZSBnb29kIGVub3VnaC5cbiAgICovXG5cbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBUUyBkb2VzIG5vdCBsaWtlIHRoaXMsIGJ1dCB3ZSBrbm93IHRoaXMgaXMgZmluZVxuICBjbGFzcyBTZW50cnlDb250ZXh0TWFuYWdlciBleHRlbmRzIENvbnRleHRNYW5hZ2VyQ2xhc3Mge1xuICAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgIHNldElzU2V0dXAoJ1NlbnRyeUNvbnRleHRNYW5hZ2VyJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJ3cml0ZSB3aXRoKCkgb2YgdGhlIG9yaWdpbmFsIEFzeW5jTG9jYWxTdG9yYWdlQ29udGV4dE1hbmFnZXJcbiAgICAgKiB0byBlbnN1cmUgd2UgYWxzbyBjcmVhdGUgbmV3IHNjb3BlcyBwZXIgY29udGV4dC5cbiAgICAgKi9cbiAgICAgd2l0aChcbiAgICAgIGNvbnRleHQsXG4gICAgICBmbixcbiAgICAgIHRoaXNBcmcsXG4gICAgICAuLi5hcmdzXG4gICAgKSB7XG4gICAgICBjb25zdCBjdXJyZW50U2NvcGVzID0gZ2V0U2NvcGVzRnJvbUNvbnRleHQoY29udGV4dCk7XG4gICAgICBjb25zdCBjdXJyZW50U2NvcGUgPSBjdXJyZW50U2NvcGVzPy5zY29wZSB8fCBjb3JlLmdldEN1cnJlbnRTY29wZSgpO1xuICAgICAgY29uc3QgY3VycmVudElzb2xhdGlvblNjb3BlID0gY3VycmVudFNjb3Blcz8uaXNvbGF0aW9uU2NvcGUgfHwgY29yZS5nZXRJc29sYXRpb25TY29wZSgpO1xuXG4gICAgICBjb25zdCBzaG91bGRGb3JrSXNvbGF0aW9uU2NvcGUgPSBjb250ZXh0LmdldFZhbHVlKFNFTlRSWV9GT1JLX0lTT0xBVElPTl9TQ09QRV9DT05URVhUX0tFWSkgPT09IHRydWU7XG4gICAgICBjb25zdCBzY29wZSA9IGNvbnRleHQuZ2V0VmFsdWUoU0VOVFJZX0ZPUktfU0VUX1NDT1BFX0NPTlRFWFRfS0VZKSA7XG4gICAgICBjb25zdCBpc29sYXRpb25TY29wZSA9IGNvbnRleHQuZ2V0VmFsdWUoU0VOVFJZX0ZPUktfU0VUX0lTT0xBVElPTl9TQ09QRV9DT05URVhUX0tFWSkgO1xuXG4gICAgICBjb25zdCBuZXdDdXJyZW50U2NvcGUgPSBzY29wZSB8fCBjdXJyZW50U2NvcGUuY2xvbmUoKTtcbiAgICAgIGNvbnN0IG5ld0lzb2xhdGlvblNjb3BlID1cbiAgICAgICAgaXNvbGF0aW9uU2NvcGUgfHwgKHNob3VsZEZvcmtJc29sYXRpb25TY29wZSA/IGN1cnJlbnRJc29sYXRpb25TY29wZS5jbG9uZSgpIDogY3VycmVudElzb2xhdGlvblNjb3BlKTtcbiAgICAgIGNvbnN0IHNjb3BlcyA9IHsgc2NvcGU6IG5ld0N1cnJlbnRTY29wZSwgaXNvbGF0aW9uU2NvcGU6IG5ld0lzb2xhdGlvblNjb3BlIH07XG5cbiAgICAgIGNvbnN0IGN0eDEgPSBzZXRTY29wZXNPbkNvbnRleHQoY29udGV4dCwgc2NvcGVzKTtcblxuICAgICAgLy8gUmVtb3ZlIHRoZSB1bm5lZWRlZCB2YWx1ZXMgYWdhaW5cbiAgICAgIGNvbnN0IGN0eDIgPSBjdHgxXG4gICAgICAgIC5kZWxldGVWYWx1ZShTRU5UUllfRk9SS19JU09MQVRJT05fU0NPUEVfQ09OVEVYVF9LRVkpXG4gICAgICAgIC5kZWxldGVWYWx1ZShTRU5UUllfRk9SS19TRVRfU0NPUEVfQ09OVEVYVF9LRVkpXG4gICAgICAgIC5kZWxldGVWYWx1ZShTRU5UUllfRk9SS19TRVRfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZKTtcblxuICAgICAgc2V0Q29udGV4dE9uU2NvcGUobmV3Q3VycmVudFNjb3BlLCBjdHgyKTtcblxuICAgICAgcmV0dXJuIHN1cGVyLndpdGgoY3R4MiwgZm4sIHRoaXNBcmcsIC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBTZW50cnlDb250ZXh0TWFuYWdlciA7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBydW5zIHRocm91Z2ggYSBsaXN0IG9mIE9URUwgU3BhbnMsIGFuZCB3cmFwcyB0aGVtIGluIGFuIGBTcGFuTm9kZWBcbiAqIHdoZXJlIGVhY2ggbm9kZSBob2xkcyBhIHJlZmVyZW5jZSB0byB0aGVpciBwYXJlbnQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ3JvdXBTcGFuc1dpdGhQYXJlbnRzKHNwYW5zKSB7XG4gIGNvbnN0IG5vZGVNYXAgPSBuZXcgTWFwKCk7XG5cbiAgZm9yIChjb25zdCBzcGFuIG9mIHNwYW5zKSB7XG4gICAgY3JlYXRlT3JVcGRhdGVTcGFuTm9kZUFuZFJlZnMobm9kZU1hcCwgc3Bhbik7XG4gIH1cblxuICByZXR1cm4gQXJyYXkuZnJvbShub2RlTWFwLCBmdW5jdGlvbiAoW19pZCwgc3Bhbk5vZGVdKSB7XG4gICAgcmV0dXJuIHNwYW5Ob2RlO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaGlzIHJldHVybnMgdGhlIF9sb2NhbF8gcGFyZW50IElEIC0gYHBhcmVudElkYCBvbiB0aGUgc3BhbiBtYXkgcG9pbnQgdG8gYSByZW1vdGUgc3Bhbi5cbiAqL1xuZnVuY3Rpb24gZ2V0TG9jYWxQYXJlbnRJZChzcGFuKSB7XG4gIGNvbnN0IHBhcmVudElzUmVtb3RlID0gc3Bhbi5hdHRyaWJ1dGVzW1NFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfUEFSRU5UX0lTX1JFTU9URV0gPT09IHRydWU7XG4gIC8vIElmIHRoZSBwYXJlbnRJZCBpcyB0aGUgdHJhY2UgcGFyZW50IElELCB3ZSBwcmV0ZW5kIGl0J3MgdW5kZWZpbmVkXG4gIC8vIEFzIHRoaXMgbWVhbnMgdGhlIHBhcmVudCBleGlzdHMgc29tZXdoZXJlIGVsc2VcbiAgcmV0dXJuICFwYXJlbnRJc1JlbW90ZSA/IGdldFBhcmVudFNwYW5JZChzcGFuKSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVTcGFuTm9kZUFuZFJlZnMobm9kZU1hcCwgc3Bhbikge1xuICBjb25zdCBpZCA9IHNwYW4uc3BhbkNvbnRleHQoKS5zcGFuSWQ7XG4gIGNvbnN0IHBhcmVudElkID0gZ2V0TG9jYWxQYXJlbnRJZChzcGFuKTtcblxuICBpZiAoIXBhcmVudElkKSB7XG4gICAgY3JlYXRlT3JVcGRhdGVOb2RlKG5vZGVNYXAsIHsgaWQsIHNwYW4sIGNoaWxkcmVuOiBbXSB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBFbHNlIG1ha2Ugc3VyZSB0byBjcmVhdGUgcGFyZW50IG5vZGUgYXMgd2VsbFxuICAvLyBOb3RlIHRoYXQgdGhlIHBhcmVudCBtYXkgbm90IGtub3cgaXQncyBwYXJlbnQgX3lldF8sIHRoaXMgbWF5IGJlIHVwZGF0ZWQgaW4gYSBsYXRlciBwYXNzXG4gIGNvbnN0IHBhcmVudE5vZGUgPSBjcmVhdGVPckdldFBhcmVudE5vZGUobm9kZU1hcCwgcGFyZW50SWQpO1xuICBjb25zdCBub2RlID0gY3JlYXRlT3JVcGRhdGVOb2RlKG5vZGVNYXAsIHsgaWQsIHNwYW4sIHBhcmVudE5vZGUsIGNoaWxkcmVuOiBbXSB9KTtcbiAgcGFyZW50Tm9kZS5jaGlsZHJlbi5wdXNoKG5vZGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPckdldFBhcmVudE5vZGUobm9kZU1hcCwgaWQpIHtcbiAgY29uc3QgZXhpc3RpbmcgPSBub2RlTWFwLmdldChpZCk7XG5cbiAgaWYgKGV4aXN0aW5nKSB7XG4gICAgcmV0dXJuIGV4aXN0aW5nO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlTm9kZShub2RlTWFwLCB7IGlkLCBjaGlsZHJlbjogW10gfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlTm9kZShub2RlTWFwLCBzcGFuTm9kZSkge1xuICBjb25zdCBleGlzdGluZyA9IG5vZGVNYXAuZ2V0KHNwYW5Ob2RlLmlkKTtcblxuICAvLyBJZiBzcGFuIGlzIGFscmVhZHkgc2V0LCBub3RoaW5nIHRvIGRvIGhlcmVcbiAgaWYgKGV4aXN0aW5nPy5zcGFuKSB7XG4gICAgcmV0dXJuIGV4aXN0aW5nO1xuICB9XG5cbiAgLy8gSWYgaXQgZXhpc3RzIGJ1dCBzcGFuIGlzIG5vdCBzZXQgeWV0LCB3ZSB1cGRhdGUgaXRcbiAgaWYgKGV4aXN0aW5nICYmICFleGlzdGluZy5zcGFuKSB7XG4gICAgZXhpc3Rpbmcuc3BhbiA9IHNwYW5Ob2RlLnNwYW47XG4gICAgZXhpc3RpbmcucGFyZW50Tm9kZSA9IHNwYW5Ob2RlLnBhcmVudE5vZGU7XG4gICAgcmV0dXJuIGV4aXN0aW5nO1xuICB9XG5cbiAgLy8gRWxzZSwgd2UgY3JlYXRlIGEgbmV3IG9uZS4uLlxuICBub2RlTWFwLnNldChzcGFuTm9kZS5pZCwgc3Bhbk5vZGUpO1xuICByZXR1cm4gc3Bhbk5vZGU7XG59XG5cbi8vIGNhbm9uaWNhbENvZGVzR3JwY01hcCBtYXBzIHNvbWUgR1JQQyBjb2RlcyB0byBTZW50cnkncyBzcGFuIHN0YXR1c2VzLiBTZWUgZGVzY3JpcHRpb24gaW4gZ3JwYyBkb2N1bWVudGF0aW9uLlxuY29uc3QgY2Fub25pY2FsR3JwY0Vycm9yQ29kZXNNYXAgPSB7XG4gICcxJzogJ2NhbmNlbGxlZCcsXG4gICcyJzogJ3Vua25vd25fZXJyb3InLFxuICAnMyc6ICdpbnZhbGlkX2FyZ3VtZW50JyxcbiAgJzQnOiAnZGVhZGxpbmVfZXhjZWVkZWQnLFxuICAnNSc6ICdub3RfZm91bmQnLFxuICAnNic6ICdhbHJlYWR5X2V4aXN0cycsXG4gICc3JzogJ3Blcm1pc3Npb25fZGVuaWVkJyxcbiAgJzgnOiAncmVzb3VyY2VfZXhoYXVzdGVkJyxcbiAgJzknOiAnZmFpbGVkX3ByZWNvbmRpdGlvbicsXG4gICcxMCc6ICdhYm9ydGVkJyxcbiAgJzExJzogJ291dF9vZl9yYW5nZScsXG4gICcxMic6ICd1bmltcGxlbWVudGVkJyxcbiAgJzEzJzogJ2ludGVybmFsX2Vycm9yJyxcbiAgJzE0JzogJ3VuYXZhaWxhYmxlJyxcbiAgJzE1JzogJ2RhdGFfbG9zcycsXG4gICcxNic6ICd1bmF1dGhlbnRpY2F0ZWQnLFxufSA7XG5cbmNvbnN0IGlzU3RhdHVzRXJyb3JNZXNzYWdlVmFsaWQgPSAobWVzc2FnZSkgPT4ge1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhjYW5vbmljYWxHcnBjRXJyb3JDb2Rlc01hcCkuaW5jbHVkZXMobWVzc2FnZSApO1xufTtcblxuLyoqXG4gKiBHZXQgYSBTZW50cnkgc3BhbiBzdGF0dXMgZnJvbSBhbiBvdGVsIHNwYW4uXG4gKi9cbmZ1bmN0aW9uIG1hcFN0YXR1cyhzcGFuKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBzcGFuSGFzQXR0cmlidXRlcyhzcGFuKSA/IHNwYW4uYXR0cmlidXRlcyA6IHt9O1xuICBjb25zdCBzdGF0dXMgPSBzcGFuSGFzU3RhdHVzKHNwYW4pID8gc3Bhbi5zdGF0dXMgOiB1bmRlZmluZWQ7XG5cbiAgaWYgKHN0YXR1cykge1xuICAgIC8vIFNpbmNlIHNwYW4gc3RhdHVzIE9LIGlzIG5vdCBzZXQgYnkgZGVmYXVsdCwgd2UgZ2l2ZSBpdCBwcmlvcml0eTogaHR0cHM6Ly9vcGVudGVsZW1ldHJ5LmlvL2RvY3MvY29uY2VwdHMvc2lnbmFscy90cmFjZXMvI3NwYW4tc3RhdHVzXG4gICAgaWYgKHN0YXR1cy5jb2RlID09PSBhcGkuU3BhblN0YXR1c0NvZGUuT0spIHtcbiAgICAgIHJldHVybiB7IGNvZGU6IGNvcmUuU1BBTl9TVEFUVVNfT0sgfTtcbiAgICAgIC8vIElmIHRoZSBzcGFuIGlzIGFscmVhZHkgbWFya2VkIGFzIGVycm9uZW91cyB3ZSByZXR1cm4gdGhhdCBleGFjdCBzdGF0dXNcbiAgICB9IGVsc2UgaWYgKHN0YXR1cy5jb2RlID09PSBhcGkuU3BhblN0YXR1c0NvZGUuRVJST1IpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3RhdHVzLm1lc3NhZ2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IGluZmVycmVkU3RhdHVzID0gaW5mZXJTdGF0dXNGcm9tQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcbiAgICAgICAgaWYgKGluZmVycmVkU3RhdHVzKSB7XG4gICAgICAgICAgcmV0dXJuIGluZmVycmVkU3RhdHVzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0dXMubWVzc2FnZSAmJiBpc1N0YXR1c0Vycm9yTWVzc2FnZVZhbGlkKHN0YXR1cy5tZXNzYWdlKSkge1xuICAgICAgICByZXR1cm4geyBjb2RlOiBjb3JlLlNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiBzdGF0dXMubWVzc2FnZSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgY29kZTogY29yZS5TUEFOX1NUQVRVU19FUlJPUiwgbWVzc2FnZTogJ3Vua25vd25fZXJyb3InIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgdGhlIHNwYW4gc3RhdHVzIGlzIFVOU0VULCB3ZSB0cnkgdG8gaW5mZXIgaXQgZnJvbSBIVFRQIG9yIEdSUEMgc3RhdHVzIGNvZGVzLlxuICBjb25zdCBpbmZlcnJlZFN0YXR1cyA9IGluZmVyU3RhdHVzRnJvbUF0dHJpYnV0ZXMoYXR0cmlidXRlcyk7XG5cbiAgaWYgKGluZmVycmVkU3RhdHVzKSB7XG4gICAgcmV0dXJuIGluZmVycmVkU3RhdHVzO1xuICB9XG5cbiAgLy8gV2UgZGVmYXVsdCB0byBzZXR0aW5nIHRoZSBzcGFucyBzdGF0dXMgdG8gb2suXG4gIGlmIChzdGF0dXM/LmNvZGUgPT09IGFwaS5TcGFuU3RhdHVzQ29kZS5VTlNFVCkge1xuICAgIHJldHVybiB7IGNvZGU6IGNvcmUuU1BBTl9TVEFUVVNfT0sgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyBjb2RlOiBjb3JlLlNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAndW5rbm93bl9lcnJvcicgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmZlclN0YXR1c0Zyb21BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpIHtcbiAgLy8gSWYgdGhlIHNwYW4gc3RhdHVzIGlzIFVOU0VULCB3ZSB0cnkgdG8gaW5mZXIgaXQgZnJvbSBIVFRQIG9yIEdSUEMgc3RhdHVzIGNvZGVzLlxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBjb25zdCBodHRwQ29kZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5BVFRSX0hUVFBfUkVTUE9OU0VfU1RBVFVTX0NPREVdIHx8IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19IVFRQX1NUQVRVU19DT0RFXTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIGNvbnN0IGdycGNDb2RlQXR0cmlidXRlID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX1JQQ19HUlBDX1NUQVRVU19DT0RFXTtcblxuICBjb25zdCBudW1iZXJIdHRwQ29kZSA9XG4gICAgdHlwZW9mIGh0dHBDb2RlQXR0cmlidXRlID09PSAnbnVtYmVyJ1xuICAgICAgPyBodHRwQ29kZUF0dHJpYnV0ZVxuICAgICAgOiB0eXBlb2YgaHR0cENvZGVBdHRyaWJ1dGUgPT09ICdzdHJpbmcnXG4gICAgICAgID8gcGFyc2VJbnQoaHR0cENvZGVBdHRyaWJ1dGUpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gIGlmICh0eXBlb2YgbnVtYmVySHR0cENvZGUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGNvcmUuZ2V0U3BhblN0YXR1c0Zyb21IdHRwQ29kZShudW1iZXJIdHRwQ29kZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIGdycGNDb2RlQXR0cmlidXRlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB7IGNvZGU6IGNvcmUuU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6IGNhbm9uaWNhbEdycGNFcnJvckNvZGVzTWFwW2dycGNDb2RlQXR0cmlidXRlXSB8fCAndW5rbm93bl9lcnJvcicgfTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmNvbnN0IE1BWF9TUEFOX0NPVU5UID0gMTAwMDtcbmNvbnN0IERFRkFVTFRfVElNRU9VVCA9IDMwMDsgLy8gNSBtaW5cblxuLyoqXG4gKiBBIFNlbnRyeS1zcGVjaWZpYyBleHBvcnRlciB0aGF0IGNvbnZlcnRzIE9wZW5UZWxlbWV0cnkgU3BhbnMgdG8gU2VudHJ5IFNwYW5zICYgVHJhbnNhY3Rpb25zLlxuICovXG5jbGFzcyBTZW50cnlTcGFuRXhwb3J0ZXIge1xuICAvKlxuICAgKiBBIHF1aWNrIGV4cGxhbmF0aW9uIG9uIHRoZSBidWNrZXRzOiBXZSBkbyBidWNrZXRpbmcgb2YgZmluaXNoZWQgc3BhbnMgZm9yIGVmZmljaWVuY3kuIFRoaXMgc3BhbiBleHBvcnRlciBpc1xuICAgKiBhY2N1bXVsYXRpbmcgc3BhbnMgdW50aWwgYSByb290IHNwYW4gaXMgZW5jb3VudGVyZWQgYW5kIHRoZW4gaXQgZmx1c2hlcyBhbGwgdGhlIHNwYW5zIHRoYXQgYXJlIGRlc2NlbmRhbnRzIG9mIHRoYXRcbiAgICogcm9vdCBzcGFuLiBCZWNhdXNlIGl0IGlzIHRvdGFsbHkgaW4gdGhlIHJlYWxtIG9mIHBvc3NpYmlsaXRpZXMgdGhhdCByb290IHNwYW5zIGFyZSBuZXZlciBmaW5pc2hlZCwgYW5kIHdlIGRvbid0XG4gICAqIHdhbnQgdG8gYWNjdW11bGF0ZSBzcGFucyBpbmRlZmluaXRlbHkgaW4gbWVtb3J5LCB3ZSBuZWVkIHRvIHBlcmlvZGljYWxseSBldmFjdWF0ZSBzcGFucy4gTmFpdmVseSB3ZSBjb3VsZCBzaW1wbHlcbiAgICogc3RvcmUgdGhlIHNwYW5zIGluIGFuIGFycmF5IGFuZCBlYWNoIHRpbWUgYSBuZXcgc3BhbiBjb21lcyBpbiB3ZSBjb3VsZCBpdGVyYXRlIHRocm91Z2ggdGhlIGVudGlyZSBhcnJheSBhbmRcbiAgICogZXZhY3VhdGUgYWxsIHNwYW5zIHRoYXQgaGF2ZSBhbiBlbmQtdGltZXN0YW1wIHRoYXQgaXMgb2xkZXIgdGhhbiBvdXIgbGltaXQuIFRoaXMgY291bGQgZ2V0IHF1aXRlIGV4cGVuc2l2ZSBiZWNhdXNlXG4gICAqIHdlIHdvdWxkIGhhdmUgdG8gaXRlcmF0ZSBhIHBvdGVudGlhbGx5IGxhcmdlIG51bWJlciBvZiBzcGFucyBldmVyeSB0aW1lIHdlIGV2YWN1YXRlLiBXZSB3YW50IHRvIGF2b2lkIHRoZXNlIGxhcmdlXG4gICAqIGJ1cnN0cyBvZiBjb21wdXRhdGlvbi5cbiAgICpcbiAgICogSW5zdGVhZCB3ZSBnbyBmb3IgYSBidWNrZXRpbmcgYXBwcm9hY2ggYW5kIHB1dCBzcGFucyBpbnRvIGJ1Y2tldHMsIGJhc2VkIG9uIHdoYXQgc2Vjb25kXG4gICAqIChtb2R1bG8gdGhlIHRpbWUgbGltaXQpIHRoZSBzcGFuIHdhcyBwdXQgaW50byB0aGUgZXhwb3J0ZXIuIFdpdGggYnVja2V0cywgd2hlbiB3ZSBkZWNpZGUgdG8gZXZhY3VhdGUsIHdlIGNhblxuICAgKiBpdGVyYXRlIHRocm91Z2ggdGhlIGJ1Y2tldCBlbnRyaWVzIGluc3RlYWQsIHdoaWNoIGhhdmUgYW4gdXBwZXIgYm91bmQgb2YgaXRlbXMsIG1ha2luZyB0aGUgZXZhY3VhdGlvbiBtdWNoIG1vcmVcbiAgICogZWZmaWNpZW50LiBDbGVhbmluZyB1cCBhbHNvIGJlY29tZXMgbXVjaCBtb3JlIGVmZmljaWVudCBzaW5jZSBpdCBzaW1wbHkgaW52b2x2ZXMgZGUtcmVmZXJlbmNpbmcgYSBidWNrZXQgd2l0aGluIHRoZVxuICAgKiBidWNrZXQgYXJyYXksIGFuZCBsZXR0aW5nIGdhcmJhZ2UgY29sbGVjdGlvbiB0YWtlIGNhcmUgb2YgdGhlIHJlc3QuXG4gICAqL1xuXG4gIC8vIEVzc2VudGlhbGx5IGEgYSBzZXQgb2Ygc3BhbiBpZHMgdGhhdCBhcmUgYWxyZWFkeSBzZW50LiBUaGUgdmFsdWVzIGFyZSBleHBpcmF0aW9uXG4gIC8vIHRpbWVzIGluIHRoaXMgY2FjaGUgc28gd2UgZG9uJ3QgaG9sZCBvbnRvIHRoZW0gaW5kZWZpbml0ZWx5LlxuXG4gIC8qIEludGVybmFsbHksIHdlIHVzZSBhIGRlYm91bmNlZCBmbHVzaCB0byBnaXZlIHNvbWUgd2lnZ2xlIHJvb20gdG8gdGhlIHNwYW4gcHJvY2Vzc29yIHRvIGFjY3VtdWxhdGUgbW9yZSBzcGFucy4gKi9cblxuICAgY29uc3RydWN0b3Iob3B0aW9uc1xuXG4pIHtcbiAgICB0aGlzLl9maW5pc2hlZFNwYW5CdWNrZXRTaXplID0gb3B0aW9ucz8udGltZW91dCB8fCBERUZBVUxUX1RJTUVPVVQ7XG4gICAgdGhpcy5fZmluaXNoZWRTcGFuQnVja2V0cyA9IG5ldyBBcnJheSh0aGlzLl9maW5pc2hlZFNwYW5CdWNrZXRTaXplKS5maWxsKHVuZGVmaW5lZCk7XG4gICAgdGhpcy5fbGFzdENsZWFudXBUaW1lc3RhbXBJblMgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICB0aGlzLl9zcGFuc1RvQnVja2V0RW50cnkgPSBuZXcgV2Vha01hcCgpO1xuICAgIHRoaXMuX3NlbnRTcGFucyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9kZWJvdW5jZWRGbHVzaCA9IGNvcmUuZGVib3VuY2UodGhpcy5mbHVzaC5iaW5kKHRoaXMpLCAxLCB7IG1heFdhaXQ6IDEwMCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvcnQgYSBzaW5nbGUgc3Bhbi5cbiAgICogVGhpcyBpcyBjYWxsZWQgYnkgdGhlIHNwYW4gcHJvY2Vzc29yIHdoZW5ldmVyIGEgc3BhbiBpcyBlbmRlZC5cbiAgICovXG4gICBleHBvcnQoc3Bhbikge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lc3RhbXBJblMgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcblxuICAgIGlmICh0aGlzLl9sYXN0Q2xlYW51cFRpbWVzdGFtcEluUyAhPT0gY3VycmVudFRpbWVzdGFtcEluUykge1xuICAgICAgbGV0IGRyb3BwZWRTcGFuQ291bnQgPSAwO1xuICAgICAgdGhpcy5fZmluaXNoZWRTcGFuQnVja2V0cy5mb3JFYWNoKChidWNrZXQsIGkpID0+IHtcbiAgICAgICAgaWYgKGJ1Y2tldCAmJiBidWNrZXQudGltZXN0YW1wSW5TIDw9IGN1cnJlbnRUaW1lc3RhbXBJblMgLSB0aGlzLl9maW5pc2hlZFNwYW5CdWNrZXRTaXplKSB7XG4gICAgICAgICAgZHJvcHBlZFNwYW5Db3VudCArPSBidWNrZXQuc3BhbnMuc2l6ZTtcbiAgICAgICAgICB0aGlzLl9maW5pc2hlZFNwYW5CdWNrZXRzW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChkcm9wcGVkU3BhbkNvdW50ID4gMCkge1xuICAgICAgICBERUJVR19CVUlMRCAmJlxuICAgICAgICAgIGNvcmUuZGVidWcubG9nKFxuICAgICAgICAgICAgYFNwYW5FeHBvcnRlciBkcm9wcGVkICR7ZHJvcHBlZFNwYW5Db3VudH0gc3BhbnMgYmVjYXVzZSB0aGV5IHdlcmUgcGVuZGluZyBmb3IgbW9yZSB0aGFuICR7dGhpcy5fZmluaXNoZWRTcGFuQnVja2V0U2l6ZX0gc2Vjb25kcy5gLFxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLl9sYXN0Q2xlYW51cFRpbWVzdGFtcEluUyA9IGN1cnJlbnRUaW1lc3RhbXBJblM7XG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudEJ1Y2tldEluZGV4ID0gY3VycmVudFRpbWVzdGFtcEluUyAlIHRoaXMuX2ZpbmlzaGVkU3BhbkJ1Y2tldFNpemU7XG4gICAgY29uc3QgY3VycmVudEJ1Y2tldCA9IHRoaXMuX2ZpbmlzaGVkU3BhbkJ1Y2tldHNbY3VycmVudEJ1Y2tldEluZGV4XSB8fCB7XG4gICAgICB0aW1lc3RhbXBJblM6IGN1cnJlbnRUaW1lc3RhbXBJblMsXG4gICAgICBzcGFuczogbmV3IFNldCgpLFxuICAgIH07XG4gICAgdGhpcy5fZmluaXNoZWRTcGFuQnVja2V0c1tjdXJyZW50QnVja2V0SW5kZXhdID0gY3VycmVudEJ1Y2tldDtcbiAgICBjdXJyZW50QnVja2V0LnNwYW5zLmFkZChzcGFuKTtcbiAgICB0aGlzLl9zcGFuc1RvQnVja2V0RW50cnkuc2V0KHNwYW4sIGN1cnJlbnRCdWNrZXQpO1xuXG4gICAgLy8gSWYgdGhlIHNwYW4gZG9lc24ndCBoYXZlIGEgbG9jYWwgcGFyZW50IElEIChpdCdzIGEgcm9vdCBzcGFuKSwgd2UncmUgZ29ubmEgZmx1c2ggYWxsIHRoZSBlbmRlZCBzcGFuc1xuICAgIGNvbnN0IGxvY2FsUGFyZW50SWQgPSBnZXRMb2NhbFBhcmVudElkKHNwYW4pO1xuICAgIGlmICghbG9jYWxQYXJlbnRJZCB8fCB0aGlzLl9zZW50U3BhbnMuaGFzKGxvY2FsUGFyZW50SWQpKSB7XG4gICAgICB0aGlzLl9kZWJvdW5jZWRGbHVzaCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcnkgdG8gZmx1c2ggYW55IHBlbmRpbmcgc3BhbnMgaW1tZWRpYXRlbHkuXG4gICAqIFRoaXMgaXMgY2FsbGVkIGludGVybmFsbHkgYnkgdGhlIGV4cG9ydGVyICh2aWEgX2RlYm91bmNlZEZsdXNoKSxcbiAgICogYnV0IGNhbiBhbHNvIGJlIHRyaWdnZXJlZCBleHRlcm5hbGx5IGlmIHdlIGZvcmNlLWZsdXNoLlxuICAgKi9cbiAgIGZsdXNoKCkge1xuICAgIGNvbnN0IGZpbmlzaGVkU3BhbnMgPSB0aGlzLl9maW5pc2hlZFNwYW5CdWNrZXRzLmZsYXRNYXAoYnVja2V0ID0+IChidWNrZXQgPyBBcnJheS5mcm9tKGJ1Y2tldC5zcGFucykgOiBbXSkpO1xuXG4gICAgdGhpcy5fZmx1c2hTZW50U3BhbkNhY2hlKCk7XG4gICAgY29uc3Qgc2VudFNwYW5zID0gdGhpcy5fbWF5YmVTZW5kKGZpbmlzaGVkU3BhbnMpO1xuXG4gICAgY29uc3Qgc2VudFNwYW5Db3VudCA9IHNlbnRTcGFucy5zaXplO1xuICAgIGNvbnN0IHJlbWFpbmluZ09wZW5TcGFuQ291bnQgPSBmaW5pc2hlZFNwYW5zLmxlbmd0aCAtIHNlbnRTcGFuQ291bnQ7XG4gICAgREVCVUdfQlVJTEQgJiZcbiAgICAgIGNvcmUuZGVidWcubG9nKFxuICAgICAgICBgU3BhbkV4cG9ydGVyIGV4cG9ydGVkICR7c2VudFNwYW5Db3VudH0gc3BhbnMsICR7cmVtYWluaW5nT3BlblNwYW5Db3VudH0gc3BhbnMgYXJlIHdhaXRpbmcgZm9yIHRoZWlyIHBhcmVudCBzcGFucyB0byBmaW5pc2hgLFxuICAgICAgKTtcblxuICAgIGNvbnN0IGV4cGlyYXRpb25EYXRlID0gRGF0ZS5ub3coKSArIERFRkFVTFRfVElNRU9VVCAqIDEwMDA7XG5cbiAgICBmb3IgKGNvbnN0IHNwYW4gb2Ygc2VudFNwYW5zKSB7XG4gICAgICB0aGlzLl9zZW50U3BhbnMuc2V0KHNwYW4uc3BhbkNvbnRleHQoKS5zcGFuSWQsIGV4cGlyYXRpb25EYXRlKTtcbiAgICAgIGNvbnN0IGJ1Y2tldEVudHJ5ID0gdGhpcy5fc3BhbnNUb0J1Y2tldEVudHJ5LmdldChzcGFuKTtcbiAgICAgIGlmIChidWNrZXRFbnRyeSkge1xuICAgICAgICBidWNrZXRFbnRyeS5zcGFucy5kZWxldGUoc3Bhbik7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIENhbmNlbCBhIHBlbmRpbmcgZGVib3VuY2VkIGZsdXNoLCBpZiB0aGVyZSBpcyBvbmVcbiAgICAvLyBUaGlzIGNhbiBiZSByZWxldmFudCBpZiB3ZSBkaXJlY3RseSBmbHVzaCwgY2lyY3VtdmVudGluZyB0aGUgZGVib3VuY2VcbiAgICAvLyBpbiB0aGF0IGNhc2UsIHdlIHdhbnQgdG8gY2FuY2VsIGFueSBwZW5kaW5nIGRlYm91bmNlZCBmbHVzaFxuICAgIHRoaXMuX2RlYm91bmNlZEZsdXNoLmNhbmNlbCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIHRoZSBleHBvcnRlci5cbiAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgc3BhbiBwcm9jZXNzb3IgaXMgc2h1dCBkb3duLlxuICAgKi9cbiAgIGNsZWFyKCkge1xuICAgIHRoaXMuX2ZpbmlzaGVkU3BhbkJ1Y2tldHMgPSB0aGlzLl9maW5pc2hlZFNwYW5CdWNrZXRzLmZpbGwodW5kZWZpbmVkKTtcbiAgICB0aGlzLl9zZW50U3BhbnMuY2xlYXIoKTtcbiAgICB0aGlzLl9kZWJvdW5jZWRGbHVzaC5jYW5jZWwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIHRoZSBnaXZlbiBzcGFucywgYnV0IG9ubHkgaWYgdGhleSBhcmUgcGFydCBvZiBhIGZpbmlzaGVkIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBSZXR1cm5zIHRoZSBzZW50IHNwYW5zLlxuICAgKiBTcGFucyByZW1haW4gdW5zZW50IHdoZW4gdGhlaXIgcGFyZW50IHNwYW4gaXMgbm90IHlldCBmaW5pc2hlZC5cbiAgICogVGhpcyB3aWxsIGhhcHBlbiByZWd1bGFybHksIGFzIGNoaWxkIHNwYW5zIGFyZSBnZW5lcmFsbHkgZmluaXNoZWQgYmVmb3JlIHRoZWlyIHBhcmVudHMuXG4gICAqIEJ1dCBpdCBfY291bGRfIGFsc28gaGFwcGVuIGJlY2F1c2UsIGZvciB3aGF0ZXZlciByZWFzb24sIGEgcGFyZW50IHNwYW4gd2FzIGxvc3QuXG4gICAqIEluIHRoaXMgY2FzZSwgd2UnbGwgZXZlbnR1YWxseSBuZWVkIHRvIGNsZWFuIHRoaXMgdXAuXG4gICAqL1xuICAgX21heWJlU2VuZChzcGFucykge1xuICAgIGNvbnN0IGdyb3VwZWQgPSBncm91cFNwYW5zV2l0aFBhcmVudHMoc3BhbnMpO1xuICAgIGNvbnN0IHNlbnRTcGFucyA9IG5ldyBTZXQoKTtcblxuICAgIGNvbnN0IHJvb3ROb2RlcyA9IHRoaXMuX2dldENvbXBsZXRlZFJvb3ROb2Rlcyhncm91cGVkKTtcblxuICAgIGZvciAoY29uc3Qgcm9vdCBvZiByb290Tm9kZXMpIHtcbiAgICAgIGNvbnN0IHNwYW4gPSByb290LnNwYW47XG4gICAgICBzZW50U3BhbnMuYWRkKHNwYW4pO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb25FdmVudCA9IGNyZWF0ZVRyYW5zYWN0aW9uRm9yT3RlbFNwYW4oc3Bhbik7XG5cbiAgICAgIC8vIEFkZCBhbiBhdHRyaWJ1dGUgdG8gdGhlIHRyYW5zYWN0aW9uIGV2ZW50IHRvIGluZGljYXRlIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiBpcyBhbiBvcnBoYW5lZCB0cmFuc2FjdGlvblxuICAgICAgaWYgKHJvb3QucGFyZW50Tm9kZSAmJiB0aGlzLl9zZW50U3BhbnMuaGFzKHJvb3QucGFyZW50Tm9kZS5pZCkpIHtcbiAgICAgICAgY29uc3QgdHJhY2VEYXRhID0gdHJhbnNhY3Rpb25FdmVudC5jb250ZXh0cz8udHJhY2U/LmRhdGE7XG4gICAgICAgIGlmICh0cmFjZURhdGEpIHtcbiAgICAgICAgICB0cmFjZURhdGFbJ3NlbnRyeS5wYXJlbnRfc3Bhbl9hbHJlYWR5X3NlbnQnXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gV2UnbGwgcmVjdXJzaXZlbHkgYWRkIGFsbCB0aGUgY2hpbGQgc3BhbnMgdG8gdGhpcyBhcnJheVxuICAgICAgY29uc3Qgc3BhbnMgPSB0cmFuc2FjdGlvbkV2ZW50LnNwYW5zIHx8IFtdO1xuXG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHJvb3QuY2hpbGRyZW4pIHtcbiAgICAgICAgY3JlYXRlQW5kRmluaXNoU3BhbkZvck90ZWxTcGFuKGNoaWxkLCBzcGFucywgc2VudFNwYW5zKTtcbiAgICAgIH1cblxuICAgICAgLy8gc3BhbnMuc29ydCgpIG11dGF0ZXMgdGhlIGFycmF5LCBidXQgd2UgZG8gbm90IHVzZSB0aGlzIGFueW1vcmUgYWZ0ZXIgdGhpcyBwb2ludFxuICAgICAgLy8gc28gd2UgY2FuIHNhZmVseSBtdXRhdGUgaXQgaGVyZVxuICAgICAgdHJhbnNhY3Rpb25FdmVudC5zcGFucyA9XG4gICAgICAgIHNwYW5zLmxlbmd0aCA+IE1BWF9TUEFOX0NPVU5UXG4gICAgICAgICAgPyBzcGFucy5zb3J0KChhLCBiKSA9PiBhLnN0YXJ0X3RpbWVzdGFtcCAtIGIuc3RhcnRfdGltZXN0YW1wKS5zbGljZSgwLCBNQVhfU1BBTl9DT1VOVClcbiAgICAgICAgICA6IHNwYW5zO1xuXG4gICAgICBjb25zdCBtZWFzdXJlbWVudHMgPSBjb3JlLnRpbWVkRXZlbnRzVG9NZWFzdXJlbWVudHMoc3Bhbi5ldmVudHMpO1xuICAgICAgaWYgKG1lYXN1cmVtZW50cykge1xuICAgICAgICB0cmFuc2FjdGlvbkV2ZW50Lm1lYXN1cmVtZW50cyA9IG1lYXN1cmVtZW50cztcbiAgICAgIH1cblxuICAgICAgY29yZS5jYXB0dXJlRXZlbnQodHJhbnNhY3Rpb25FdmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbnRTcGFucztcbiAgfVxuXG4gIC8qKiBSZW1vdmUgXCJleHBpcmVkXCIgc3BhbiBpZCBlbnRyaWVzIGZyb20gdGhlIF9zZW50U3BhbnMgY2FjaGUuICovXG4gICBfZmx1c2hTZW50U3BhbkNhY2hlKCkge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIC8vIE5vdGUsIGl0IGlzIHNhZmUgdG8gZGVsZXRlIGl0ZW1zIGZyb20gdGhlIG1hcCBhcyB3ZSBnbzogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM1OTQzOTk1LzkwMjk3XG4gICAgZm9yIChjb25zdCBbc3BhbklkLCBleHBpcmF0aW9uVGltZV0gb2YgdGhpcy5fc2VudFNwYW5zLmVudHJpZXMoKSkge1xuICAgICAgaWYgKGV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lc3RhbXApIHtcbiAgICAgICAgdGhpcy5fc2VudFNwYW5zLmRlbGV0ZShzcGFuSWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBDaGVjayBpZiBhIG5vZGUgaXMgYSBjb21wbGV0ZWQgcm9vdCBub2RlIG9yIGEgbm9kZSB3aG9zZSBwYXJlbnQgaGFzIGFscmVhZHkgYmVlbiBzZW50ICovXG4gICBfbm9kZUlzQ29tcGxldGVkUm9vdE5vZGVPckhhc1NlbnRQYXJlbnQobm9kZSkge1xuICAgIHJldHVybiAhIW5vZGUuc3BhbiAmJiAoIW5vZGUucGFyZW50Tm9kZSB8fCB0aGlzLl9zZW50U3BhbnMuaGFzKG5vZGUucGFyZW50Tm9kZS5pZCkpO1xuICB9XG5cbiAgLyoqIEdldCBhbGwgY29tcGxldGVkIHJvb3Qgbm9kZXMgZnJvbSBhIGxpc3Qgb2Ygbm9kZXMgKi9cbiAgIF9nZXRDb21wbGV0ZWRSb290Tm9kZXMobm9kZXMpIHtcbiAgICAvLyBUT0RPOiBXZSBzaG91bGQgYmUgYWJsZSB0byByZW1vdmUgdGhlIGV4cGxpY2l0IGBub2RlIGlzIFNwYW5Ob2RlQ29tcGxldGVkYCB0eXBlIGd1YXJkXG4gICAgLy8gICAgICAgb25jZSB3ZSBzdG9wIHN1cHBvcnRpbmcgVFMgPCA1LjVcbiAgICByZXR1cm4gbm9kZXMuZmlsdGVyKChub2RlKSA9PiB0aGlzLl9ub2RlSXNDb21wbGV0ZWRSb290Tm9kZU9ySGFzU2VudFBhcmVudChub2RlKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VTcGFuKHNwYW4pIHtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHNwYW4uYXR0cmlidXRlcztcblxuICBjb25zdCBvcmlnaW4gPSBhdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU5dIDtcbiAgY29uc3Qgb3AgPSBhdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUF0gO1xuICBjb25zdCBzb3VyY2UgPSBhdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0VdIDtcblxuICByZXR1cm4geyBvcmlnaW4sIG9wLCBzb3VyY2UgfTtcbn1cblxuLyoqIEV4cG9ydGVkIG9ubHkgZm9yIHRlc3RzLiAqL1xuZnVuY3Rpb24gY3JlYXRlVHJhbnNhY3Rpb25Gb3JPdGVsU3BhbihzcGFuKSB7XG4gIGNvbnN0IHsgb3AsIGRlc2NyaXB0aW9uLCBkYXRhLCBvcmlnaW4gPSAnbWFudWFsJywgc291cmNlIH0gPSBnZXRTcGFuRGF0YShzcGFuKTtcbiAgY29uc3QgY2FwdHVyZWRTcGFuU2NvcGVzID0gY29yZS5nZXRDYXB0dXJlZFNjb3Blc09uU3BhbihzcGFuICk7XG5cbiAgY29uc3Qgc2FtcGxlUmF0ZSA9IHNwYW4uYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU0FNUExFX1JBVEVdIDtcblxuICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgIFtjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFXTogc291cmNlLFxuICAgIFtjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU0FNUExFX1JBVEVdOiBzYW1wbGVSYXRlLFxuICAgIFtjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1BdOiBvcCxcbiAgICBbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09SSUdJTl06IG9yaWdpbixcbiAgICAuLi5kYXRhLFxuICAgIC4uLnJlbW92ZVNlbnRyeUF0dHJpYnV0ZXMoc3Bhbi5hdHRyaWJ1dGVzKSxcbiAgfTtcblxuICBjb25zdCB7IGxpbmtzIH0gPSBzcGFuO1xuICBjb25zdCB7IHRyYWNlSWQ6IHRyYWNlX2lkLCBzcGFuSWQ6IHNwYW5faWQgfSA9IHNwYW4uc3BhbkNvbnRleHQoKTtcblxuICAvLyBJZiBwYXJlbnRTcGFuSWRGcm9tVHJhY2VTdGF0ZSBpcyBkZWZpbmVkIGF0IGFsbCwgd2Ugd2FudCBpdCB0byB0YWtlIHByZWNlZGVuY2VcbiAgLy8gSW4gdGhhdCBjYXNlLCBhbiBlbXB0eSBzdHJpbmcgc2hvdWxkIGJlIGludGVycHJldGVkIGFzIFwibm8gcGFyZW50IHNwYW4gaWRcIixcbiAgLy8gZXZlbiBpZiBgc3Bhbi5wYXJlbnRTcGFuSWRgIGlzIHNldFxuICAvLyB0aGlzIGlzIHRoZSBjYXNlIHdoZW4gd2UgYXJlIHN0YXJ0aW5nIGEgbmV3IHRyYWNlLCB3aGVyZSB3ZSBoYXZlIGEgdmlydHVhbCBzcGFuIGJhc2VkIG9uIHRoZSBwcm9wYWdhdGlvbkNvbnRleHRcbiAgLy8gV2Ugb25seSB3YW50IHRvIGNvbnRpbnVlIHRoZSB0cmFjZUlkIGluIHRoaXMgY2FzZSwgYnV0IGlnbm9yZSB0aGUgcGFyZW50IHNwYW5cbiAgY29uc3QgcGFyZW50X3NwYW5faWQgPSBnZXRQYXJlbnRTcGFuSWQoc3Bhbik7XG5cbiAgY29uc3Qgc3RhdHVzID0gbWFwU3RhdHVzKHNwYW4pO1xuXG4gIGNvbnN0IHRyYWNlQ29udGV4dCA9IHtcbiAgICBwYXJlbnRfc3Bhbl9pZCxcbiAgICBzcGFuX2lkLFxuICAgIHRyYWNlX2lkLFxuICAgIGRhdGE6IGF0dHJpYnV0ZXMsXG4gICAgb3JpZ2luLFxuICAgIG9wLFxuICAgIHN0YXR1czogY29yZS5nZXRTdGF0dXNNZXNzYWdlKHN0YXR1cyksIC8vIEFzIHBlciBwcm90b2NvbCwgc3BhbiBzdGF0dXMgaXMgYWxsb3dlZCB0byBiZSB1bmRlZmluZWRcbiAgICBsaW5rczogY29yZS5jb252ZXJ0U3BhbkxpbmtzRm9yRW52ZWxvcGUobGlua3MpLFxuICB9O1xuXG4gIGNvbnN0IHN0YXR1c0NvZGUgPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuQVRUUl9IVFRQX1JFU1BPTlNFX1NUQVRVU19DT0RFXTtcbiAgY29uc3QgcmVzcG9uc2VDb250ZXh0ID0gdHlwZW9mIHN0YXR1c0NvZGUgPT09ICdudW1iZXInID8geyByZXNwb25zZTogeyBzdGF0dXNfY29kZTogc3RhdHVzQ29kZSB9IH0gOiB1bmRlZmluZWQ7XG5cbiAgY29uc3QgdHJhbnNhY3Rpb25FdmVudCA9IHtcbiAgICBjb250ZXh0czoge1xuICAgICAgdHJhY2U6IHRyYWNlQ29udGV4dCxcbiAgICAgIG90ZWw6IHtcbiAgICAgICAgcmVzb3VyY2U6IHNwYW4ucmVzb3VyY2UuYXR0cmlidXRlcyxcbiAgICAgIH0sXG4gICAgICAuLi5yZXNwb25zZUNvbnRleHQsXG4gICAgfSxcbiAgICBzcGFuczogW10sXG4gICAgc3RhcnRfdGltZXN0YW1wOiBjb3JlLnNwYW5UaW1lSW5wdXRUb1NlY29uZHMoc3Bhbi5zdGFydFRpbWUpLFxuICAgIHRpbWVzdGFtcDogY29yZS5zcGFuVGltZUlucHV0VG9TZWNvbmRzKHNwYW4uZW5kVGltZSksXG4gICAgdHJhbnNhY3Rpb246IGRlc2NyaXB0aW9uLFxuICAgIHR5cGU6ICd0cmFuc2FjdGlvbicsXG4gICAgc2RrUHJvY2Vzc2luZ01ldGFkYXRhOiB7XG4gICAgICBjYXB0dXJlZFNwYW5TY29wZTogY2FwdHVyZWRTcGFuU2NvcGVzLnNjb3BlLFxuICAgICAgY2FwdHVyZWRTcGFuSXNvbGF0aW9uU2NvcGU6IGNhcHR1cmVkU3BhblNjb3Blcy5pc29sYXRpb25TY29wZSxcbiAgICAgIHNhbXBsZVJhdGUsXG4gICAgICBkeW5hbWljU2FtcGxpbmdDb250ZXh0OiBjb3JlLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbihzcGFuICksXG4gICAgfSxcbiAgICAuLi4oc291cmNlICYmIHtcbiAgICAgIHRyYW5zYWN0aW9uX2luZm86IHtcbiAgICAgICAgc291cmNlLFxuICAgICAgfSxcbiAgICB9KSxcbiAgfTtcblxuICByZXR1cm4gdHJhbnNhY3Rpb25FdmVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQW5kRmluaXNoU3BhbkZvck90ZWxTcGFuKG5vZGUsIHNwYW5zLCBzZW50U3BhbnMpIHtcbiAgY29uc3Qgc3BhbiA9IG5vZGUuc3BhbjtcblxuICBpZiAoc3Bhbikge1xuICAgIHNlbnRTcGFucy5hZGQoc3Bhbik7XG4gIH1cblxuICBjb25zdCBzaG91bGREcm9wID0gIXNwYW47XG5cbiAgLy8gSWYgdGhpcyBzcGFuIHNob3VsZCBiZSBkcm9wcGVkLCB3ZSBzdGlsbCB3YW50IHRvIGNyZWF0ZSBzcGFucyBmb3IgdGhlIGNoaWxkcmVuIG9mIHRoaXNcbiAgaWYgKHNob3VsZERyb3ApIHtcbiAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgY3JlYXRlQW5kRmluaXNoU3BhbkZvck90ZWxTcGFuKGNoaWxkLCBzcGFucywgc2VudFNwYW5zKTtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzcGFuX2lkID0gc3Bhbi5zcGFuQ29udGV4dCgpLnNwYW5JZDtcbiAgY29uc3QgdHJhY2VfaWQgPSBzcGFuLnNwYW5Db250ZXh0KCkudHJhY2VJZDtcbiAgY29uc3QgcGFyZW50U3BhbklkID0gZ2V0UGFyZW50U3BhbklkKHNwYW4pO1xuXG4gIGNvbnN0IHsgYXR0cmlidXRlcywgc3RhcnRUaW1lLCBlbmRUaW1lLCBsaW5rcyB9ID0gc3BhbjtcblxuICBjb25zdCB7IG9wLCBkZXNjcmlwdGlvbiwgZGF0YSwgb3JpZ2luID0gJ21hbnVhbCcgfSA9IGdldFNwYW5EYXRhKHNwYW4pO1xuICBjb25zdCBhbGxEYXRhID0ge1xuICAgIFtjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOXTogb3JpZ2luLFxuICAgIFtjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1BdOiBvcCxcbiAgICAuLi5yZW1vdmVTZW50cnlBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpLFxuICAgIC4uLmRhdGEsXG4gIH07XG5cbiAgY29uc3Qgc3RhdHVzID0gbWFwU3RhdHVzKHNwYW4pO1xuXG4gIGNvbnN0IHNwYW5KU09OID0ge1xuICAgIHNwYW5faWQsXG4gICAgdHJhY2VfaWQsXG4gICAgZGF0YTogYWxsRGF0YSxcbiAgICBkZXNjcmlwdGlvbixcbiAgICBwYXJlbnRfc3Bhbl9pZDogcGFyZW50U3BhbklkLFxuICAgIHN0YXJ0X3RpbWVzdGFtcDogY29yZS5zcGFuVGltZUlucHV0VG9TZWNvbmRzKHN0YXJ0VGltZSksXG4gICAgLy8gVGhpcyBpcyBbMCwwXSBieSBkZWZhdWx0IGluIE9URUwsIGluIHdoaWNoIGNhc2Ugd2Ugd2FudCB0byBpbnRlcnByZXQgdGhpcyBhcyBubyBlbmQgdGltZVxuICAgIHRpbWVzdGFtcDogY29yZS5zcGFuVGltZUlucHV0VG9TZWNvbmRzKGVuZFRpbWUpIHx8IHVuZGVmaW5lZCxcbiAgICBzdGF0dXM6IGNvcmUuZ2V0U3RhdHVzTWVzc2FnZShzdGF0dXMpLCAvLyBBcyBwZXIgcHJvdG9jb2wsIHNwYW4gc3RhdHVzIGlzIGFsbG93ZWQgdG8gYmUgdW5kZWZpbmVkXG4gICAgb3AsXG4gICAgb3JpZ2luLFxuICAgIG1lYXN1cmVtZW50czogY29yZS50aW1lZEV2ZW50c1RvTWVhc3VyZW1lbnRzKHNwYW4uZXZlbnRzKSxcbiAgICBsaW5rczogY29yZS5jb252ZXJ0U3BhbkxpbmtzRm9yRW52ZWxvcGUobGlua3MpLFxuICB9O1xuXG4gIHNwYW5zLnB1c2goc3BhbkpTT04pO1xuXG4gIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgY3JlYXRlQW5kRmluaXNoU3BhbkZvck90ZWxTcGFuKGNoaWxkLCBzcGFucywgc2VudFNwYW5zKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFNwYW5EYXRhKHNwYW4pXG5cbiB7XG4gIGNvbnN0IHsgb3A6IGRlZmluZWRPcCwgc291cmNlOiBkZWZpbmVkU291cmNlLCBvcmlnaW4gfSA9IHBhcnNlU3BhbihzcGFuKTtcbiAgY29uc3QgeyBvcDogaW5mZXJyZWRPcCwgZGVzY3JpcHRpb24sIHNvdXJjZTogaW5mZXJyZWRTb3VyY2UsIGRhdGE6IGluZmVycmVkRGF0YSB9ID0gcGFyc2VTcGFuRGVzY3JpcHRpb24oc3Bhbik7XG5cbiAgY29uc3Qgb3AgPSBkZWZpbmVkT3AgfHwgaW5mZXJyZWRPcDtcbiAgY29uc3Qgc291cmNlID0gZGVmaW5lZFNvdXJjZSB8fCBpbmZlcnJlZFNvdXJjZTtcblxuICBjb25zdCBkYXRhID0geyAuLi5pbmZlcnJlZERhdGEsIC4uLmdldERhdGEoc3BhbikgfTtcblxuICByZXR1cm4ge1xuICAgIG9wLFxuICAgIGRlc2NyaXB0aW9uLFxuICAgIHNvdXJjZSxcbiAgICBvcmlnaW4sXG4gICAgZGF0YSxcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgY3VzdG9tIGBzZW50cnkuYCBhdHRyaWJ1dGVzIHdlIGRvIG5vdCBuZWVkIHRvIHNlbmQuXG4gKiBUaGVzZSBhcmUgbW9yZSBjYXJyaWVyIGF0dHJpYnV0ZXMgd2UgdXNlIGluc2lkZSBvZiB0aGUgU0RLLCB3ZSBkbyBub3QgbmVlZCB0byBzZW5kIHRoZW0gdG8gdGhlIEFQSS5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlU2VudHJ5QXR0cmlidXRlcyhkYXRhKSB7XG4gIGNvbnN0IGNsZWFuZWREYXRhID0geyAuLi5kYXRhIH07XG5cbiAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWR5bmFtaWMtZGVsZXRlICovXG4gIGRlbGV0ZSBjbGVhbmVkRGF0YVtjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU0FNUExFX1JBVEVdO1xuICBkZWxldGUgY2xlYW5lZERhdGFbU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9QQVJFTlRfSVNfUkVNT1RFXTtcbiAgZGVsZXRlIGNsZWFuZWREYXRhW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9DVVNUT01fU1BBTl9OQU1FXTtcbiAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHluYW1pYy1kZWxldGUgKi9cblxuICByZXR1cm4gY2xlYW5lZERhdGE7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEoc3Bhbikge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gc3Bhbi5hdHRyaWJ1dGVzO1xuICBjb25zdCBkYXRhID0ge307XG5cbiAgaWYgKHNwYW4ua2luZCAhPT0gYXBpLlNwYW5LaW5kLklOVEVSTkFMKSB7XG4gICAgZGF0YVsnb3RlbC5raW5kJ10gPSBhcGkuU3BhbktpbmRbc3Bhbi5raW5kXTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBjb25zdCBtYXliZUh0dHBTdGF0dXNDb2RlQXR0cmlidXRlID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfU1RBVFVTX0NPREVdO1xuICBpZiAobWF5YmVIdHRwU3RhdHVzQ29kZUF0dHJpYnV0ZSkge1xuICAgIGRhdGFbc2VtYW50aWNDb252ZW50aW9ucy5BVFRSX0hUVFBfUkVTUE9OU0VfU1RBVFVTX0NPREVdID0gbWF5YmVIdHRwU3RhdHVzQ29kZUF0dHJpYnV0ZSA7XG4gIH1cblxuICBjb25zdCByZXF1ZXN0RGF0YSA9IGdldFJlcXVlc3RTcGFuRGF0YShzcGFuKTtcblxuICBpZiAocmVxdWVzdERhdGEudXJsKSB7XG4gICAgZGF0YS51cmwgPSByZXF1ZXN0RGF0YS51cmw7XG4gIH1cblxuICBpZiAocmVxdWVzdERhdGFbJ2h0dHAucXVlcnknXSkge1xuICAgIGRhdGFbJ2h0dHAucXVlcnknXSA9IHJlcXVlc3REYXRhWydodHRwLnF1ZXJ5J10uc2xpY2UoMSk7XG4gIH1cbiAgaWYgKHJlcXVlc3REYXRhWydodHRwLmZyYWdtZW50J10pIHtcbiAgICBkYXRhWydodHRwLmZyYWdtZW50J10gPSByZXF1ZXN0RGF0YVsnaHR0cC5mcmFnbWVudCddLnNsaWNlKDEpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIG9uU3BhblN0YXJ0KHNwYW4sIHBhcmVudENvbnRleHQpIHtcbiAgLy8gVGhpcyBpcyBhIHJlbGlhYmxlIHdheSB0byBnZXQgdGhlIHBhcmVudCBzcGFuIC0gYmVjYXVzZSB0aGlzIGlzIGV4YWN0bHkgaG93IHRoZSBwYXJlbnQgaXMgaWRlbnRpZmllZCBpbiB0aGUgT1RFTCBTREtcbiAgY29uc3QgcGFyZW50U3BhbiA9IGFwaS50cmFjZS5nZXRTcGFuKHBhcmVudENvbnRleHQpO1xuXG4gIGxldCBzY29wZXMgPSBnZXRTY29wZXNGcm9tQ29udGV4dChwYXJlbnRDb250ZXh0KTtcblxuICAvLyBXZSBuZWVkIGFjY2VzcyB0byB0aGUgcGFyZW50IHNwYW4gaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBtb3ZlIHVwIHRoZSBzcGFuIHRyZWUgZm9yIGJyZWFkY3J1bWJzXG4gIGlmIChwYXJlbnRTcGFuICYmICFwYXJlbnRTcGFuLnNwYW5Db250ZXh0KCkuaXNSZW1vdGUpIHtcbiAgICBjb3JlLmFkZENoaWxkU3BhblRvU3BhbihwYXJlbnRTcGFuLCBzcGFuKTtcbiAgfVxuXG4gIC8vIFdlIG5lZWQgdGhpcyBpbiB0aGUgc3BhbiBleHBvcnRlclxuICBpZiAocGFyZW50U3Bhbj8uc3BhbkNvbnRleHQoKS5pc1JlbW90ZSkge1xuICAgIHNwYW4uc2V0QXR0cmlidXRlKFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfUEFSRU5UX0lTX1JFTU9URSwgdHJ1ZSk7XG4gIH1cblxuICAvLyBUaGUgcm9vdCBjb250ZXh0IGRvZXMgbm90IGhhdmUgc2NvcGVzIHN0b3JlZCwgc28gd2UgY2hlY2sgZm9yIHRoaXMgc3BlY2lmaWNhbGx5XG4gIC8vIEFzIGZhbGxiYWNrIHdlIGF0dGFjaCB0aGUgZ2xvYmFsIHNjb3Blc1xuICBpZiAocGFyZW50Q29udGV4dCA9PT0gYXBpLlJPT1RfQ09OVEVYVCkge1xuICAgIHNjb3BlcyA9IHtcbiAgICAgIHNjb3BlOiBjb3JlLmdldERlZmF1bHRDdXJyZW50U2NvcGUoKSxcbiAgICAgIGlzb2xhdGlvblNjb3BlOiBjb3JlLmdldERlZmF1bHRJc29sYXRpb25TY29wZSgpLFxuICAgIH07XG4gIH1cblxuICAvLyBXZSBuZWVkIHRoZSBzY29wZSBhdCB0aW1lIG9mIHNwYW4gY3JlYXRpb24gaW4gb3JkZXIgdG8gYXBwbHkgaXQgdG8gdGhlIGV2ZW50IHdoZW4gdGhlIHNwYW4gaXMgZmluaXNoZWRcbiAgaWYgKHNjb3Blcykge1xuICAgIGNvcmUuc2V0Q2FwdHVyZWRTY29wZXNPblNwYW4oc3Bhbiwgc2NvcGVzLnNjb3BlLCBzY29wZXMuaXNvbGF0aW9uU2NvcGUpO1xuICB9XG5cbiAgY29yZS5sb2dTcGFuU3RhcnQoc3Bhbik7XG5cbiAgY29uc3QgY2xpZW50ID0gY29yZS5nZXRDbGllbnQoKTtcbiAgY2xpZW50Py5lbWl0KCdzcGFuU3RhcnQnLCBzcGFuKTtcbn1cblxuZnVuY3Rpb24gb25TcGFuRW5kKHNwYW4pIHtcbiAgY29yZS5sb2dTcGFuRW5kKHNwYW4pO1xuXG4gIGNvbnN0IGNsaWVudCA9IGNvcmUuZ2V0Q2xpZW50KCk7XG4gIGNsaWVudD8uZW1pdCgnc3BhbkVuZCcsIHNwYW4pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIE9wZW5UZWxlbWV0cnkgU3BhbnMgdG8gU2VudHJ5IFNwYW5zIGFuZCBzZW5kcyB0aGVtIHRvIFNlbnRyeSB2aWFcbiAqIHRoZSBTZW50cnkgU0RLLlxuICovXG5jbGFzcyBTZW50cnlTcGFuUHJvY2Vzc29yICB7XG5cbiAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzZXRJc1NldHVwKCdTZW50cnlTcGFuUHJvY2Vzc29yJyk7XG4gICAgdGhpcy5fZXhwb3J0ZXIgPSBuZXcgU2VudHJ5U3BhbkV4cG9ydGVyKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICAgYXN5bmMgZm9yY2VGbHVzaCgpIHtcbiAgICB0aGlzLl9leHBvcnRlci5mbHVzaCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICAgYXN5bmMgc2h1dGRvd24oKSB7XG4gICAgdGhpcy5fZXhwb3J0ZXIuY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIG9uU3RhcnQoc3BhbiwgcGFyZW50Q29udGV4dCkge1xuICAgIG9uU3BhblN0YXJ0KHNwYW4sIHBhcmVudENvbnRleHQpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gICBvbkVuZChzcGFuKSB7XG4gICAgb25TcGFuRW5kKHNwYW4pO1xuXG4gICAgdGhpcy5fZXhwb3J0ZXIuZXhwb3J0KHNwYW4pO1xuICB9XG59XG5cbi8qKlxuICogQSBjdXN0b20gT1RFTCBzYW1wbGVyIHRoYXQgdXNlcyBTZW50cnkgc2FtcGxpbmcgcmF0ZXMgdG8gbWFrZSBpdHMgZGVjaXNpb25cbiAqL1xuY2xhc3MgU2VudHJ5U2FtcGxlciAge1xuXG4gICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgc2V0SXNTZXR1cCgnU2VudHJ5U2FtcGxlcicpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gICBzaG91bGRTYW1wbGUoXG4gICAgY29udGV4dCxcbiAgICB0cmFjZUlkLFxuICAgIHNwYW5OYW1lLFxuICAgIHNwYW5LaW5kLFxuICAgIHNwYW5BdHRyaWJ1dGVzLFxuICAgIF9saW5rcyxcbiAgKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2NsaWVudC5nZXRPcHRpb25zKCk7XG5cbiAgICBjb25zdCBwYXJlbnRTcGFuID0gZ2V0VmFsaWRTcGFuKGNvbnRleHQpO1xuICAgIGNvbnN0IHBhcmVudENvbnRleHQgPSBwYXJlbnRTcGFuPy5zcGFuQ29udGV4dCgpO1xuXG4gICAgaWYgKCFjb3JlLmhhc1NwYW5zRW5hYmxlZChvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIHdyYXBTYW1wbGluZ0RlY2lzaW9uKHsgZGVjaXNpb246IHVuZGVmaW5lZCwgY29udGV4dCwgc3BhbkF0dHJpYnV0ZXMgfSk7XG4gICAgfVxuXG4gICAgLy8gYEFUVFJfSFRUUF9SRVFVRVNUX01FVEhPRGAgaXMgdGhlIG5ldyBhdHRyaWJ1dGUsIGJ1dCB3ZSBzdGlsbCBzdXBwb3J0IHRoZSBvbGQgb25lLCBgU0VNQVRUUlNfSFRUUF9NRVRIT0RgLCBmb3Igbm93LlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgIGNvbnN0IG1heWJlU3Bhbkh0dHBNZXRob2QgPSBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfTUVUSE9EXSB8fCBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLkFUVFJfSFRUUF9SRVFVRVNUX01FVEhPRF07XG5cbiAgICAvLyBJZiB3ZSBoYXZlIGEgaHR0cC5jbGllbnQgc3BhbiB0aGF0IGhhcyBubyBsb2NhbCBwYXJlbnQsIHdlIG5ldmVyIHdhbnQgdG8gc2FtcGxlIGl0XG4gICAgLy8gYnV0IHdlIHdhbnQgdG8gbGVhdmUgZG93bnN0cmVhbSBzYW1wbGluZyBkZWNpc2lvbnMgdXAgdG8gdGhlIHNlcnZlclxuICAgIGlmIChzcGFuS2luZCA9PT0gYXBpLlNwYW5LaW5kLkNMSUVOVCAmJiBtYXliZVNwYW5IdHRwTWV0aG9kICYmICghcGFyZW50U3BhbiB8fCBwYXJlbnRDb250ZXh0Py5pc1JlbW90ZSkpIHtcbiAgICAgIHJldHVybiB3cmFwU2FtcGxpbmdEZWNpc2lvbih7IGRlY2lzaW9uOiB1bmRlZmluZWQsIGNvbnRleHQsIHNwYW5BdHRyaWJ1dGVzIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudFNhbXBsZWQgPSBwYXJlbnRTcGFuID8gZ2V0UGFyZW50U2FtcGxlZChwYXJlbnRTcGFuLCB0cmFjZUlkLCBzcGFuTmFtZSkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgaXNSb290U3BhbiA9ICFwYXJlbnRTcGFuIHx8IHBhcmVudENvbnRleHQ/LmlzUmVtb3RlO1xuXG4gICAgLy8gV2Ugb25seSBzYW1wbGUgYmFzZWQgb24gcGFyYW1ldGVycyAobGlrZSB0cmFjZXNTYW1wbGVSYXRlIG9yIHRyYWNlc1NhbXBsZXIpIGZvciByb290IHNwYW5zICh3aGljaCBpcyBkb25lIGluIHNhbXBsZVNwYW4pLlxuICAgIC8vIE5vbi1yb290LXNwYW5zIHNpbXBseSBpbmhlcml0IHRoZSBzYW1wbGluZyBkZWNpc2lvbiBmcm9tIHRoZWlyIHBhcmVudC5cbiAgICBpZiAoIWlzUm9vdFNwYW4pIHtcbiAgICAgIHJldHVybiB3cmFwU2FtcGxpbmdEZWNpc2lvbih7XG4gICAgICAgIGRlY2lzaW9uOiBwYXJlbnRTYW1wbGVkID8gc2RrVHJhY2VCYXNlLlNhbXBsaW5nRGVjaXNpb24uUkVDT1JEX0FORF9TQU1QTEVEIDogc2RrVHJhY2VCYXNlLlNhbXBsaW5nRGVjaXNpb24uTk9UX1JFQ09SRCxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgc3BhbkF0dHJpYnV0ZXMsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBXZSB3YW50IHRvIHBhc3MgdGhlIGluZmVycmVkIG5hbWUgJiBhdHRyaWJ1dGVzIHRvIHRoZSBzYW1wbGVyIG1ldGhvZFxuICAgIGNvbnN0IHtcbiAgICAgIGRlc2NyaXB0aW9uOiBpbmZlcnJlZFNwYW5OYW1lLFxuICAgICAgZGF0YTogaW5mZXJyZWRBdHRyaWJ1dGVzLFxuICAgICAgb3AsXG4gICAgfSA9IGluZmVyU3BhbkRhdGEoc3Bhbk5hbWUsIHNwYW5BdHRyaWJ1dGVzLCBzcGFuS2luZCk7XG5cbiAgICBjb25zdCBtZXJnZWRBdHRyaWJ1dGVzID0ge1xuICAgICAgLi4uaW5mZXJyZWRBdHRyaWJ1dGVzLFxuICAgICAgLi4uc3BhbkF0dHJpYnV0ZXMsXG4gICAgfTtcblxuICAgIGlmIChvcCkge1xuICAgICAgbWVyZ2VkQXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1BdID0gb3A7XG4gICAgfVxuXG4gICAgY29uc3QgbXV0YWJsZVNhbXBsaW5nRGVjaXNpb24gPSB7IGRlY2lzaW9uOiB0cnVlIH07XG4gICAgdGhpcy5fY2xpZW50LmVtaXQoXG4gICAgICAnYmVmb3JlU2FtcGxpbmcnLFxuICAgICAge1xuICAgICAgICBzcGFuQXR0cmlidXRlczogbWVyZ2VkQXR0cmlidXRlcyxcbiAgICAgICAgc3Bhbk5hbWU6IGluZmVycmVkU3Bhbk5hbWUsXG4gICAgICAgIHBhcmVudFNhbXBsZWQ6IHBhcmVudFNhbXBsZWQsXG4gICAgICAgIHBhcmVudENvbnRleHQ6IHBhcmVudENvbnRleHQsXG4gICAgICB9LFxuICAgICAgbXV0YWJsZVNhbXBsaW5nRGVjaXNpb24sXG4gICAgKTtcbiAgICBpZiAoIW11dGFibGVTYW1wbGluZ0RlY2lzaW9uLmRlY2lzaW9uKSB7XG4gICAgICByZXR1cm4gd3JhcFNhbXBsaW5nRGVjaXNpb24oeyBkZWNpc2lvbjogdW5kZWZpbmVkLCBjb250ZXh0LCBzcGFuQXR0cmlidXRlcyB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB7IGlzb2xhdGlvblNjb3BlIH0gPSBnZXRTY29wZXNGcm9tQ29udGV4dChjb250ZXh0KSA/PyB7fTtcblxuICAgIGNvbnN0IGRzY1N0cmluZyA9IHBhcmVudENvbnRleHQ/LnRyYWNlU3RhdGUgPyBwYXJlbnRDb250ZXh0LnRyYWNlU3RhdGUuZ2V0KFNFTlRSWV9UUkFDRV9TVEFURV9EU0MpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGRzYyA9IGRzY1N0cmluZyA/IGNvcmUuYmFnZ2FnZUhlYWRlclRvRHluYW1pY1NhbXBsaW5nQ29udGV4dChkc2NTdHJpbmcpIDogdW5kZWZpbmVkO1xuXG4gICAgY29uc3Qgc2FtcGxlUmFuZCA9IGNvcmUucGFyc2VTYW1wbGVSYXRlKGRzYz8uc2FtcGxlX3JhbmQpID8/IE1hdGgucmFuZG9tKCk7XG5cbiAgICBjb25zdCBbc2FtcGxlZCwgc2FtcGxlUmF0ZSwgbG9jYWxTYW1wbGVSYXRlV2FzQXBwbGllZF0gPSBjb3JlLnNhbXBsZVNwYW4oXG4gICAgICBvcHRpb25zLFxuICAgICAge1xuICAgICAgICBuYW1lOiBpbmZlcnJlZFNwYW5OYW1lLFxuICAgICAgICBhdHRyaWJ1dGVzOiBtZXJnZWRBdHRyaWJ1dGVzLFxuICAgICAgICBub3JtYWxpemVkUmVxdWVzdDogaXNvbGF0aW9uU2NvcGU/LmdldFNjb3BlRGF0YSgpLnNka1Byb2Nlc3NpbmdNZXRhZGF0YS5ub3JtYWxpemVkUmVxdWVzdCxcbiAgICAgICAgcGFyZW50U2FtcGxlZCxcbiAgICAgICAgcGFyZW50U2FtcGxlUmF0ZTogY29yZS5wYXJzZVNhbXBsZVJhdGUoZHNjPy5zYW1wbGVfcmF0ZSksXG4gICAgICB9LFxuICAgICAgc2FtcGxlUmFuZCxcbiAgICApO1xuXG4gICAgY29uc3QgbWV0aG9kID0gYCR7bWF5YmVTcGFuSHR0cE1ldGhvZH1gLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKG1ldGhvZCA9PT0gJ09QVElPTlMnIHx8IG1ldGhvZCA9PT0gJ0hFQUQnKSB7XG4gICAgICBERUJVR19CVUlMRCAmJiBjb3JlLmRlYnVnLmxvZyhgW1RyYWNpbmddIE5vdCBzYW1wbGluZyBzcGFuIGJlY2F1c2UgSFRUUCBtZXRob2QgaXMgJyR7bWV0aG9kfScgZm9yICR7c3Bhbk5hbWV9YCk7XG5cbiAgICAgIHJldHVybiB3cmFwU2FtcGxpbmdEZWNpc2lvbih7XG4gICAgICAgIGRlY2lzaW9uOiBzZGtUcmFjZUJhc2UuU2FtcGxpbmdEZWNpc2lvbi5OT1RfUkVDT1JELFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBzcGFuQXR0cmlidXRlcyxcbiAgICAgICAgc2FtcGxlUmFuZCxcbiAgICAgICAgZG93bnN0cmVhbVRyYWNlU2FtcGxlUmF0ZTogMCwgLy8gd2UgZG9uJ3Qgd2FudCB0byBzYW1wbGUgYW55dGhpbmcgaW4gdGhlIGRvd25zdHJlYW0gdHJhY2UgZWl0aGVyXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAhc2FtcGxlZCAmJlxuICAgICAgLy8gV2UgY2hlY2sgZm9yIGBwYXJlbnRTYW1wbGVkID09PSB1bmRlZmluZWRgIGJlY2F1c2Ugd2Ugb25seSB3YW50IHRvIHJlY29yZCBjbGllbnQgcmVwb3J0cyBmb3Igc3BhbnMgdGhhdCBhcmUgdHJhY2Ugcm9vdHMgKGllLiB3aGVuIHRoZXJlIHdhcyBpbmNvbWluZyB0cmFjZSlcbiAgICAgIHBhcmVudFNhbXBsZWQgPT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgREVCVUdfQlVJTEQgJiYgY29yZS5kZWJ1Zy5sb2coJ1tUcmFjaW5nXSBEaXNjYXJkaW5nIHJvb3Qgc3BhbiBiZWNhdXNlIGl0cyB0cmFjZSB3YXMgbm90IGNob3NlbiB0byBiZSBzYW1wbGVkLicpO1xuICAgICAgdGhpcy5fY2xpZW50LnJlY29yZERyb3BwZWRFdmVudCgnc2FtcGxlX3JhdGUnLCAndHJhbnNhY3Rpb24nKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4ud3JhcFNhbXBsaW5nRGVjaXNpb24oe1xuICAgICAgICBkZWNpc2lvbjogc2FtcGxlZCA/IHNka1RyYWNlQmFzZS5TYW1wbGluZ0RlY2lzaW9uLlJFQ09SRF9BTkRfU0FNUExFRCA6IHNka1RyYWNlQmFzZS5TYW1wbGluZ0RlY2lzaW9uLk5PVF9SRUNPUkQsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHNwYW5BdHRyaWJ1dGVzLFxuICAgICAgICBzYW1wbGVSYW5kLFxuICAgICAgICBkb3duc3RyZWFtVHJhY2VTYW1wbGVSYXRlOiBsb2NhbFNhbXBsZVJhdGVXYXNBcHBsaWVkID8gc2FtcGxlUmF0ZSA6IHVuZGVmaW5lZCxcbiAgICAgIH0pLFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAvLyBXZSBzZXQgdGhlIHNhbXBsZSByYXRlIG9uIHRoZSBzcGFuIHdoZW4gYSBsb2NhbCBzYW1wbGUgcmF0ZSB3YXMgYXBwbGllZCB0byBiZXR0ZXIgdW5kZXJzdGFuZCBob3cgdHJhY2VzIHdlcmUgc2FtcGxlZCBpbiBTZW50cnlcbiAgICAgICAgW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TQU1QTEVfUkFURV06IGxvY2FsU2FtcGxlUmF0ZVdhc0FwcGxpZWQgPyBzYW1wbGVSYXRlIDogdW5kZWZpbmVkLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgLyoqIFJldHVybnMgdGhlIHNhbXBsZXIgbmFtZSBvciBzaG9ydCBkZXNjcmlwdGlvbiB3aXRoIHRoZSBjb25maWd1cmF0aW9uLiAqL1xuICAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdTZW50cnlTYW1wbGVyJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQYXJlbnRTYW1wbGVkKHBhcmVudFNwYW4sIHRyYWNlSWQsIHNwYW5OYW1lKSB7XG4gIGNvbnN0IHBhcmVudENvbnRleHQgPSBwYXJlbnRTcGFuLnNwYW5Db250ZXh0KCk7XG5cbiAgLy8gT25seSBpbmhlcml0IHNhbXBsZSByYXRlIGlmIGB0cmFjZUlkYCBpcyB0aGUgc2FtZVxuICAvLyBOb3RlIGZvciB0ZXN0aW5nOiBgaXNTcGFuQ29udGV4dFZhbGlkKClgIGNoZWNrcyB0aGUgZm9ybWF0IG9mIHRoZSB0cmFjZUlkL3NwYW5JZCwgc28gd2UgbmVlZCB0byBwYXNzIHZhbGlkIG9uZXNcbiAgaWYgKGFwaS5pc1NwYW5Db250ZXh0VmFsaWQocGFyZW50Q29udGV4dCkgJiYgcGFyZW50Q29udGV4dC50cmFjZUlkID09PSB0cmFjZUlkKSB7XG4gICAgaWYgKHBhcmVudENvbnRleHQuaXNSZW1vdGUpIHtcbiAgICAgIGNvbnN0IHBhcmVudFNhbXBsZWQgPSBnZXRTYW1wbGluZ0RlY2lzaW9uKHBhcmVudFNwYW4uc3BhbkNvbnRleHQoKSk7XG4gICAgICBERUJVR19CVUlMRCAmJlxuICAgICAgICBjb3JlLmRlYnVnLmxvZyhgW1RyYWNpbmddIEluaGVyaXRpbmcgcmVtb3RlIHBhcmVudCdzIHNhbXBsZWQgZGVjaXNpb24gZm9yICR7c3Bhbk5hbWV9OiAke3BhcmVudFNhbXBsZWR9YCk7XG4gICAgICByZXR1cm4gcGFyZW50U2FtcGxlZDtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJlbnRTYW1wbGVkID0gZ2V0U2FtcGxpbmdEZWNpc2lvbihwYXJlbnRDb250ZXh0KTtcbiAgICBERUJVR19CVUlMRCAmJiBjb3JlLmRlYnVnLmxvZyhgW1RyYWNpbmddIEluaGVyaXRpbmcgcGFyZW50J3Mgc2FtcGxlZCBkZWNpc2lvbiBmb3IgJHtzcGFuTmFtZX06ICR7cGFyZW50U2FtcGxlZH1gKTtcbiAgICByZXR1cm4gcGFyZW50U2FtcGxlZDtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogV3JhcCBhIHNhbXBsaW5nIGRlY2lzaW9uIHdpdGggZGF0YSB0aGF0IFNlbnRyeSBuZWVkcyB0byB3b3JrIHByb3Blcmx5IHdpdGggaXQuXG4gKiBJZiB5b3UgcGFzcyBgZGVjaXNpb246IHVuZGVmaW5lZGAsIGl0IHdpbGwgYmUgdHJlYXRlZCBhcyBgTk9UX1JFQ09SRElOR2AsIGJ1dCBpbiBjb250cmFzdCB0byBwYXNzaW5nIGBOT1RfUkVDT1JESU5HYFxuICogaXQgd2lsbCBub3QgcHJvcGFnYXRlIHRoaXMgZGVjaXNpb24gdG8gZG93bnN0cmVhbSBTZW50cnkgU0RLcy5cbiAqL1xuZnVuY3Rpb24gd3JhcFNhbXBsaW5nRGVjaXNpb24oe1xuICBkZWNpc2lvbixcbiAgY29udGV4dCxcbiAgc3BhbkF0dHJpYnV0ZXMsXG4gIHNhbXBsZVJhbmQsXG4gIGRvd25zdHJlYW1UcmFjZVNhbXBsZVJhdGUsXG59XG5cbikge1xuICBsZXQgdHJhY2VTdGF0ZSA9IGdldEJhc2VUcmFjZVN0YXRlKGNvbnRleHQsIHNwYW5BdHRyaWJ1dGVzKTtcblxuICAvLyBXZSB3aWxsIG92ZXJyaWRlIHRoZSBwcm9wYWdhdGVkIHNhbXBsZSByYXRlIGRvd25zdHJlYW0gd2hlblxuICAvLyAtIHRoZSB0cmFjZXNTYW1wbGVSYXRlIGlzIGFwcGxpZWRcbiAgLy8gLSB0aGUgdHJhY2VzU2FtcGxlciBpcyBpbnZva2VkXG4gIC8vIFNpbmNlIHVuc2FtcGxlZCBPVEVMIHNwYW5zIChOb25SZWNvcmRpbmdTcGFucykgY2Fubm90IGhvbGQgYXR0cmlidXRlcyB3ZSBuZWVkIHRvIHN0b3JlIHRoaXMgb24gdGhlICh0cmFjZSljb250ZXh0LlxuICBpZiAoZG93bnN0cmVhbVRyYWNlU2FtcGxlUmF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdHJhY2VTdGF0ZSA9IHRyYWNlU3RhdGUuc2V0KFNFTlRSWV9UUkFDRV9TVEFURV9TQU1QTEVfUkFURSwgYCR7ZG93bnN0cmVhbVRyYWNlU2FtcGxlUmF0ZX1gKTtcbiAgfVxuXG4gIGlmIChzYW1wbGVSYW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICB0cmFjZVN0YXRlID0gdHJhY2VTdGF0ZS5zZXQoU0VOVFJZX1RSQUNFX1NUQVRFX1NBTVBMRV9SQU5ELCBgJHtzYW1wbGVSYW5kfWApO1xuICB9XG5cbiAgLy8gSWYgdGhlIGRlY2lzaW9uIGlzIHVuZGVmaW5lZCwgd2UgdHJlYXQgaXQgYXMgTk9UX1JFQ09SRElORywgYnV0IHdlIGRvbid0IHByb3BhZ2F0ZSB0aGlzIGRlY2lzaW9uIHRvIGRvd25zdHJlYW0gU0RLc1xuICAvLyBXaGljaCBpcyBkb25lIGJ5IG5vdCBzZXR0aW5nIGBTRU5UUllfVFJBQ0VfU1RBVEVfU0FNUExFRF9OT1RfUkVDT1JESU5HYCB0cmFjZVN0YXRlXG4gIGlmIChkZWNpc2lvbiA9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4geyBkZWNpc2lvbjogc2RrVHJhY2VCYXNlLlNhbXBsaW5nRGVjaXNpb24uTk9UX1JFQ09SRCwgdHJhY2VTdGF0ZSB9O1xuICB9XG5cbiAgaWYgKGRlY2lzaW9uID09PSBzZGtUcmFjZUJhc2UuU2FtcGxpbmdEZWNpc2lvbi5OT1RfUkVDT1JEKSB7XG4gICAgcmV0dXJuIHsgZGVjaXNpb24sIHRyYWNlU3RhdGU6IHRyYWNlU3RhdGUuc2V0KFNFTlRSWV9UUkFDRV9TVEFURV9TQU1QTEVEX05PVF9SRUNPUkRJTkcsICcxJykgfTtcbiAgfVxuXG4gIHJldHVybiB7IGRlY2lzaW9uLCB0cmFjZVN0YXRlIH07XG59XG5cbmZ1bmN0aW9uIGdldEJhc2VUcmFjZVN0YXRlKGNvbnRleHQsIHNwYW5BdHRyaWJ1dGVzKSB7XG4gIGNvbnN0IHBhcmVudFNwYW4gPSBhcGkudHJhY2UuZ2V0U3Bhbihjb250ZXh0KTtcbiAgY29uc3QgcGFyZW50Q29udGV4dCA9IHBhcmVudFNwYW4/LnNwYW5Db250ZXh0KCk7XG5cbiAgbGV0IHRyYWNlU3RhdGUgPSBwYXJlbnRDb250ZXh0Py50cmFjZVN0YXRlIHx8IG5ldyBjb3JlJDEuVHJhY2VTdGF0ZSgpO1xuXG4gIC8vIFdlIGFsd2F5cyBrZWVwIHRoZSBVUkwgb24gdGhlIHRyYWNlIHN0YXRlLCBzbyB3ZSBjYW4gYWNjZXNzIGl0IGluIHRoZSBwcm9wYWdhdG9yXG4gIC8vIGBBVFRSX1VSTF9GVUxMYCBpcyB0aGUgbmV3IGF0dHJpYnV0ZSwgYnV0IHdlIHN0aWxsIHN1cHBvcnQgdGhlIG9sZCBvbmUsIGBBVFRSX0hUVFBfVVJMYCwgZm9yIG5vdy5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIGNvbnN0IHVybCA9IHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9VUkxdIHx8IHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuQVRUUl9VUkxfRlVMTF07XG4gIGlmICh1cmwgJiYgdHlwZW9mIHVybCA9PT0gJ3N0cmluZycpIHtcbiAgICB0cmFjZVN0YXRlID0gdHJhY2VTdGF0ZS5zZXQoU0VOVFJZX1RSQUNFX1NUQVRFX1VSTCwgdXJsKTtcbiAgfVxuXG4gIHJldHVybiB0cmFjZVN0YXRlO1xufVxuXG4vKipcbiAqIElmIHRoZSBhY3RpdmUgc3BhbiBpcyBpbnZhbGlkLCB3ZSB3YW50IHRvIGlnbm9yZSBpdCBhcyBwYXJlbnQuXG4gKiBUaGlzIGFsaWducyB3aXRoIGhvdyBvdGVsIHRyYWNlcnMgYW5kIGRlZmF1bHQgc2FtcGxlcnMgaGFuZGxlIHRoZXNlIGNhc2VzLlxuICovXG5mdW5jdGlvbiBnZXRWYWxpZFNwYW4oY29udGV4dCkge1xuICBjb25zdCBzcGFuID0gYXBpLnRyYWNlLmdldFNwYW4oY29udGV4dCk7XG4gIHJldHVybiBzcGFuICYmIGFwaS5pc1NwYW5Db250ZXh0VmFsaWQoc3Bhbi5zcGFuQ29udGV4dCgpKSA/IHNwYW4gOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydHMuZ2V0Q2xpZW50ID0gY29yZS5nZXRDbGllbnQ7XG5leHBvcnRzLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbiA9IGNvcmUuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuO1xuZXhwb3J0cy5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX0dSQVBIUUxfT1BFUkFUSU9OID0gU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9HUkFQSFFMX09QRVJBVElPTjtcbmV4cG9ydHMuU2VudHJ5UHJvcGFnYXRvciA9IFNlbnRyeVByb3BhZ2F0b3I7XG5leHBvcnRzLlNlbnRyeVNhbXBsZXIgPSBTZW50cnlTYW1wbGVyO1xuZXhwb3J0cy5TZW50cnlTcGFuUHJvY2Vzc29yID0gU2VudHJ5U3BhblByb2Nlc3NvcjtcbmV4cG9ydHMuY29udGludWVUcmFjZSA9IGNvbnRpbnVlVHJhY2U7XG5leHBvcnRzLmVuaGFuY2VEc2NXaXRoT3BlblRlbGVtZXRyeVJvb3RTcGFuTmFtZSA9IGVuaGFuY2VEc2NXaXRoT3BlblRlbGVtZXRyeVJvb3RTcGFuTmFtZTtcbmV4cG9ydHMuZ2V0QWN0aXZlU3BhbiA9IGdldEFjdGl2ZVNwYW47XG5leHBvcnRzLmdldFJlcXVlc3RTcGFuRGF0YSA9IGdldFJlcXVlc3RTcGFuRGF0YTtcbmV4cG9ydHMuZ2V0U2NvcGVzRnJvbUNvbnRleHQgPSBnZXRTY29wZXNGcm9tQ29udGV4dDtcbmV4cG9ydHMuZ2V0U3BhbktpbmQgPSBnZXRTcGFuS2luZDtcbmV4cG9ydHMuZ2V0VHJhY2VDb250ZXh0Rm9yU2NvcGUgPSBnZXRUcmFjZUNvbnRleHRGb3JTY29wZTtcbmV4cG9ydHMuaXNTZW50cnlSZXF1ZXN0U3BhbiA9IGlzU2VudHJ5UmVxdWVzdFNwYW47XG5leHBvcnRzLm9wZW5UZWxlbWV0cnlTZXR1cENoZWNrID0gb3BlblRlbGVtZXRyeVNldHVwQ2hlY2s7XG5leHBvcnRzLnNldE9wZW5UZWxlbWV0cnlDb250ZXh0QXN5bmNDb250ZXh0U3RyYXRlZ3kgPSBzZXRPcGVuVGVsZW1ldHJ5Q29udGV4dEFzeW5jQ29udGV4dFN0cmF0ZWd5O1xuZXhwb3J0cy5zZXR1cEV2ZW50Q29udGV4dFRyYWNlID0gc2V0dXBFdmVudENvbnRleHRUcmFjZTtcbmV4cG9ydHMuc2hvdWxkUHJvcGFnYXRlVHJhY2VGb3JVcmwgPSBzaG91bGRQcm9wYWdhdGVUcmFjZUZvclVybDtcbmV4cG9ydHMuc3Bhbkhhc0F0dHJpYnV0ZXMgPSBzcGFuSGFzQXR0cmlidXRlcztcbmV4cG9ydHMuc3Bhbkhhc0V2ZW50cyA9IHNwYW5IYXNFdmVudHM7XG5leHBvcnRzLnNwYW5IYXNLaW5kID0gc3Bhbkhhc0tpbmQ7XG5leHBvcnRzLnNwYW5IYXNOYW1lID0gc3Bhbkhhc05hbWU7XG5leHBvcnRzLnNwYW5IYXNQYXJlbnRJZCA9IHNwYW5IYXNQYXJlbnRJZDtcbmV4cG9ydHMuc3Bhbkhhc1N0YXR1cyA9IHNwYW5IYXNTdGF0dXM7XG5leHBvcnRzLnN0YXJ0SW5hY3RpdmVTcGFuID0gc3RhcnRJbmFjdGl2ZVNwYW47XG5leHBvcnRzLnN0YXJ0U3BhbiA9IHN0YXJ0U3BhbjtcbmV4cG9ydHMuc3RhcnRTcGFuTWFudWFsID0gc3RhcnRTcGFuTWFudWFsO1xuZXhwb3J0cy5zdXBwcmVzc1RyYWNpbmcgPSBzdXBwcmVzc1RyYWNpbmc7XG5leHBvcnRzLndpdGhBY3RpdmVTcGFuID0gd2l0aEFjdGl2ZVNwYW47XG5leHBvcnRzLndyYXBDbGllbnRDbGFzcyA9IHdyYXBDbGllbnRDbGFzcztcbmV4cG9ydHMud3JhcENvbnRleHRNYW5hZ2VyQ2xhc3MgPSB3cmFwQ29udGV4dE1hbmFnZXJDbGFzcztcbmV4cG9ydHMud3JhcFNhbXBsaW5nRGVjaXNpb24gPSB3cmFwU2FtcGxpbmdEZWNpc2lvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@sentry+opentelemetry@10.17.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.1_lnanjtbeaorg7cpyd6d5aj7lji/node_modules/@sentry/opentelemetry/build/cjs/index.js\n");

/***/ })

};
;