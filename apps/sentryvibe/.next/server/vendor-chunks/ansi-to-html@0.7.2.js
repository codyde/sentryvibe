"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ansi-to-html@0.7.2";
exports.ids = ["vendor-chunks/ansi-to-html@0.7.2"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/ansi-to-html@0.7.2/node_modules/ansi-to-html/lib/ansi_to_html.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ansi-to-html@0.7.2/node_modules/ansi-to-html/lib/ansi_to_html.js ***!
  \*************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar entities = __webpack_require__(/*! entities */ \"(ssr)/../../node_modules/.pnpm/entities@2.2.0/node_modules/entities/lib/index.js\");\n\nvar defaults = {\n  fg: '#FFF',\n  bg: '#000',\n  newline: false,\n  escapeXML: false,\n  stream: false,\n  colors: getDefaultColors()\n};\n\nfunction getDefaultColors() {\n  var colors = {\n    0: '#000',\n    1: '#A00',\n    2: '#0A0',\n    3: '#A50',\n    4: '#00A',\n    5: '#A0A',\n    6: '#0AA',\n    7: '#AAA',\n    8: '#555',\n    9: '#F55',\n    10: '#5F5',\n    11: '#FF5',\n    12: '#55F',\n    13: '#F5F',\n    14: '#5FF',\n    15: '#FFF'\n  };\n  range(0, 5).forEach(function (red) {\n    range(0, 5).forEach(function (green) {\n      range(0, 5).forEach(function (blue) {\n        return setStyleColor(red, green, blue, colors);\n      });\n    });\n  });\n  range(0, 23).forEach(function (gray) {\n    var c = gray + 232;\n    var l = toHexString(gray * 10 + 8);\n    colors[c] = '#' + l + l + l;\n  });\n  return colors;\n}\n/**\n * @param {number} red\n * @param {number} green\n * @param {number} blue\n * @param {object} colors\n */\n\n\nfunction setStyleColor(red, green, blue, colors) {\n  var c = 16 + red * 36 + green * 6 + blue;\n  var r = red > 0 ? red * 40 + 55 : 0;\n  var g = green > 0 ? green * 40 + 55 : 0;\n  var b = blue > 0 ? blue * 40 + 55 : 0;\n  colors[c] = toColorHexString([r, g, b]);\n}\n/**\n * Converts from a number like 15 to a hex string like 'F'\n * @param {number} num\n * @returns {string}\n */\n\n\nfunction toHexString(num) {\n  var str = num.toString(16);\n\n  while (str.length < 2) {\n    str = '0' + str;\n  }\n\n  return str;\n}\n/**\n * Converts from an array of numbers like [15, 15, 15] to a hex string like 'FFF'\n * @param {[red, green, blue]} ref\n * @returns {string}\n */\n\n\nfunction toColorHexString(ref) {\n  var results = [];\n\n  var _iterator = _createForOfIteratorHelper(ref),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var r = _step.value;\n      results.push(toHexString(r));\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return '#' + results.join('');\n}\n/**\n * @param {Array} stack\n * @param {string} token\n * @param {*} data\n * @param {object} options\n */\n\n\nfunction generateOutput(stack, token, data, options) {\n  var result;\n\n  if (token === 'text') {\n    result = pushText(data, options);\n  } else if (token === 'display') {\n    result = handleDisplay(stack, data, options);\n  } else if (token === 'xterm256Foreground') {\n    result = pushForegroundColor(stack, options.colors[data]);\n  } else if (token === 'xterm256Background') {\n    result = pushBackgroundColor(stack, options.colors[data]);\n  } else if (token === 'rgb') {\n    result = handleRgb(stack, data);\n  }\n\n  return result;\n}\n/**\n * @param {Array} stack\n * @param {string} data\n * @returns {*}\n */\n\n\nfunction handleRgb(stack, data) {\n  data = data.substring(2).slice(0, -1);\n  var operation = +data.substr(0, 2);\n  var color = data.substring(5).split(';');\n  var rgb = color.map(function (value) {\n    return ('0' + Number(value).toString(16)).substr(-2);\n  }).join('');\n  return pushStyle(stack, (operation === 38 ? 'color:#' : 'background-color:#') + rgb);\n}\n/**\n * @param {Array} stack\n * @param {number} code\n * @param {object} options\n * @returns {*}\n */\n\n\nfunction handleDisplay(stack, code, options) {\n  code = parseInt(code, 10);\n  var codeMap = {\n    '-1': function _() {\n      return '<br/>';\n    },\n    0: function _() {\n      return stack.length && resetStyles(stack);\n    },\n    1: function _() {\n      return pushTag(stack, 'b');\n    },\n    3: function _() {\n      return pushTag(stack, 'i');\n    },\n    4: function _() {\n      return pushTag(stack, 'u');\n    },\n    8: function _() {\n      return pushStyle(stack, 'display:none');\n    },\n    9: function _() {\n      return pushTag(stack, 'strike');\n    },\n    22: function _() {\n      return pushStyle(stack, 'font-weight:normal;text-decoration:none;font-style:normal');\n    },\n    23: function _() {\n      return closeTag(stack, 'i');\n    },\n    24: function _() {\n      return closeTag(stack, 'u');\n    },\n    39: function _() {\n      return pushForegroundColor(stack, options.fg);\n    },\n    49: function _() {\n      return pushBackgroundColor(stack, options.bg);\n    },\n    53: function _() {\n      return pushStyle(stack, 'text-decoration:overline');\n    }\n  };\n  var result;\n\n  if (codeMap[code]) {\n    result = codeMap[code]();\n  } else if (4 < code && code < 7) {\n    result = pushTag(stack, 'blink');\n  } else if (29 < code && code < 38) {\n    result = pushForegroundColor(stack, options.colors[code - 30]);\n  } else if (39 < code && code < 48) {\n    result = pushBackgroundColor(stack, options.colors[code - 40]);\n  } else if (89 < code && code < 98) {\n    result = pushForegroundColor(stack, options.colors[8 + (code - 90)]);\n  } else if (99 < code && code < 108) {\n    result = pushBackgroundColor(stack, options.colors[8 + (code - 100)]);\n  }\n\n  return result;\n}\n/**\n * Clear all the styles\n * @returns {string}\n */\n\n\nfunction resetStyles(stack) {\n  var stackClone = stack.slice(0);\n  stack.length = 0;\n  return stackClone.reverse().map(function (tag) {\n    return '</' + tag + '>';\n  }).join('');\n}\n/**\n * Creates an array of numbers ranging from low to high\n * @param {number} low\n * @param {number} high\n * @returns {Array}\n * @example range(3, 7); // creates [3, 4, 5, 6, 7]\n */\n\n\nfunction range(low, high) {\n  var results = [];\n\n  for (var j = low; j <= high; j++) {\n    results.push(j);\n  }\n\n  return results;\n}\n/**\n * Returns a new function that is true if value is NOT the same category\n * @param {string} category\n * @returns {function}\n */\n\n\nfunction notCategory(category) {\n  return function (e) {\n    return (category === null || e.category !== category) && category !== 'all';\n  };\n}\n/**\n * Converts a code into an ansi token type\n * @param {number} code\n * @returns {string}\n */\n\n\nfunction categoryForCode(code) {\n  code = parseInt(code, 10);\n  var result = null;\n\n  if (code === 0) {\n    result = 'all';\n  } else if (code === 1) {\n    result = 'bold';\n  } else if (2 < code && code < 5) {\n    result = 'underline';\n  } else if (4 < code && code < 7) {\n    result = 'blink';\n  } else if (code === 8) {\n    result = 'hide';\n  } else if (code === 9) {\n    result = 'strike';\n  } else if (29 < code && code < 38 || code === 39 || 89 < code && code < 98) {\n    result = 'foreground-color';\n  } else if (39 < code && code < 48 || code === 49 || 99 < code && code < 108) {\n    result = 'background-color';\n  }\n\n  return result;\n}\n/**\n * @param {string} text\n * @param {object} options\n * @returns {string}\n */\n\n\nfunction pushText(text, options) {\n  if (options.escapeXML) {\n    return entities.encodeXML(text);\n  }\n\n  return text;\n}\n/**\n * @param {Array} stack\n * @param {string} tag\n * @param {string} [style='']\n * @returns {string}\n */\n\n\nfunction pushTag(stack, tag, style) {\n  if (!style) {\n    style = '';\n  }\n\n  stack.push(tag);\n  return \"<\".concat(tag).concat(style ? \" style=\\\"\".concat(style, \"\\\"\") : '', \">\");\n}\n/**\n * @param {Array} stack\n * @param {string} style\n * @returns {string}\n */\n\n\nfunction pushStyle(stack, style) {\n  return pushTag(stack, 'span', style);\n}\n\nfunction pushForegroundColor(stack, color) {\n  return pushTag(stack, 'span', 'color:' + color);\n}\n\nfunction pushBackgroundColor(stack, color) {\n  return pushTag(stack, 'span', 'background-color:' + color);\n}\n/**\n * @param {Array} stack\n * @param {string} style\n * @returns {string}\n */\n\n\nfunction closeTag(stack, style) {\n  var last;\n\n  if (stack.slice(-1)[0] === style) {\n    last = stack.pop();\n  }\n\n  if (last) {\n    return '</' + style + '>';\n  }\n}\n/**\n * @param {string} text\n * @param {object} options\n * @param {function} callback\n * @returns {Array}\n */\n\n\nfunction tokenize(text, options, callback) {\n  var ansiMatch = false;\n  var ansiHandler = 3;\n\n  function remove() {\n    return '';\n  }\n\n  function removeXterm256Foreground(m, g1) {\n    callback('xterm256Foreground', g1);\n    return '';\n  }\n\n  function removeXterm256Background(m, g1) {\n    callback('xterm256Background', g1);\n    return '';\n  }\n\n  function newline(m) {\n    if (options.newline) {\n      callback('display', -1);\n    } else {\n      callback('text', m);\n    }\n\n    return '';\n  }\n\n  function ansiMess(m, g1) {\n    ansiMatch = true;\n\n    if (g1.trim().length === 0) {\n      g1 = '0';\n    }\n\n    g1 = g1.trimRight(';').split(';');\n\n    var _iterator2 = _createForOfIteratorHelper(g1),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var g = _step2.value;\n        callback('display', g);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return '';\n  }\n\n  function realText(m) {\n    callback('text', m);\n    return '';\n  }\n\n  function rgb(m) {\n    callback('rgb', m);\n    return '';\n  }\n  /* eslint no-control-regex:0 */\n\n\n  var tokens = [{\n    pattern: /^\\x08+/,\n    sub: remove\n  }, {\n    pattern: /^\\x1b\\[[012]?K/,\n    sub: remove\n  }, {\n    pattern: /^\\x1b\\[\\(B/,\n    sub: remove\n  }, {\n    pattern: /^\\x1b\\[[34]8;2;\\d+;\\d+;\\d+m/,\n    sub: rgb\n  }, {\n    pattern: /^\\x1b\\[38;5;(\\d+)m/,\n    sub: removeXterm256Foreground\n  }, {\n    pattern: /^\\x1b\\[48;5;(\\d+)m/,\n    sub: removeXterm256Background\n  }, {\n    pattern: /^\\n/,\n    sub: newline\n  }, {\n    pattern: /^\\r+\\n/,\n    sub: newline\n  }, {\n    pattern: /^\\r/,\n    sub: newline\n  }, {\n    pattern: /^\\x1b\\[((?:\\d{1,3};?)+|)m/,\n    sub: ansiMess\n  }, {\n    // CSI n J\n    // ED - Erase in Display Clears part of the screen.\n    // If n is 0 (or missing), clear from cursor to end of screen.\n    // If n is 1, clear from cursor to beginning of the screen.\n    // If n is 2, clear entire screen (and moves cursor to upper left on DOS ANSI.SYS).\n    // If n is 3, clear entire screen and delete all lines saved in the scrollback buffer\n    //   (this feature was added for xterm and is supported by other terminal applications).\n    pattern: /^\\x1b\\[\\d?J/,\n    sub: remove\n  }, {\n    // CSI n ; m f\n    // HVP - Horizontal Vertical Position Same as CUP\n    pattern: /^\\x1b\\[\\d{0,3};\\d{0,3}f/,\n    sub: remove\n  }, {\n    // catch-all for CSI sequences?\n    pattern: /^\\x1b\\[?[\\d;]{0,3}/,\n    sub: remove\n  }, {\n    /**\n     * extracts real text - not containing:\n     * - `\\x1b' - ESC - escape (Ascii 27)\n     * - '\\x08' - BS - backspace (Ascii 8)\n     * - `\\n` - Newline - linefeed (LF) (ascii 10)\n     * - `\\r` - Windows Carriage Return (CR)\n     */\n    pattern: /^(([^\\x1b\\x08\\r\\n])+)/,\n    sub: realText\n  }];\n\n  function process(handler, i) {\n    if (i > ansiHandler && ansiMatch) {\n      return;\n    }\n\n    ansiMatch = false;\n    text = text.replace(handler.pattern, handler.sub);\n  }\n\n  var results1 = [];\n  var _text = text,\n      length = _text.length;\n\n  outer: while (length > 0) {\n    for (var i = 0, o = 0, len = tokens.length; o < len; i = ++o) {\n      var handler = tokens[i];\n      process(handler, i);\n\n      if (text.length !== length) {\n        // We matched a token and removed it from the text. We need to\n        // start matching *all* tokens against the new text.\n        length = text.length;\n        continue outer;\n      }\n    }\n\n    if (text.length === length) {\n      break;\n    }\n\n    results1.push(0);\n    length = text.length;\n  }\n\n  return results1;\n}\n/**\n * If streaming, then the stack is \"sticky\"\n *\n * @param {Array} stickyStack\n * @param {string} token\n * @param {*} data\n * @returns {Array}\n */\n\n\nfunction updateStickyStack(stickyStack, token, data) {\n  if (token !== 'text') {\n    stickyStack = stickyStack.filter(notCategory(categoryForCode(data)));\n    stickyStack.push({\n      token: token,\n      data: data,\n      category: categoryForCode(data)\n    });\n  }\n\n  return stickyStack;\n}\n\nvar Filter = /*#__PURE__*/function () {\n  /**\n   * @param {object} options\n   * @param {string=} options.fg The default foreground color used when reset color codes are encountered.\n   * @param {string=} options.bg The default background color used when reset color codes are encountered.\n   * @param {boolean=} options.newline Convert newline characters to `<br/>`.\n   * @param {boolean=} options.escapeXML Generate HTML/XML entities.\n   * @param {boolean=} options.stream Save style state across invocations of `toHtml()`.\n   * @param {(string[] | {[code: number]: string})=} options.colors Can override specific colors or the entire ANSI palette.\n   */\n  function Filter(options) {\n    _classCallCheck(this, Filter);\n\n    options = options || {};\n\n    if (options.colors) {\n      options.colors = Object.assign({}, defaults.colors, options.colors);\n    }\n\n    this.options = Object.assign({}, defaults, options);\n    this.stack = [];\n    this.stickyStack = [];\n  }\n  /**\n   * @param {string | string[]} input\n   * @returns {string}\n   */\n\n\n  _createClass(Filter, [{\n    key: \"toHtml\",\n    value: function toHtml(input) {\n      var _this = this;\n\n      input = typeof input === 'string' ? [input] : input;\n      var stack = this.stack,\n          options = this.options;\n      var buf = [];\n      this.stickyStack.forEach(function (element) {\n        var output = generateOutput(stack, element.token, element.data, options);\n\n        if (output) {\n          buf.push(output);\n        }\n      });\n      tokenize(input.join(''), options, function (token, data) {\n        var output = generateOutput(stack, token, data, options);\n\n        if (output) {\n          buf.push(output);\n        }\n\n        if (options.stream) {\n          _this.stickyStack = updateStickyStack(_this.stickyStack, token, data);\n        }\n      });\n\n      if (stack.length) {\n        buf.push(resetStyles(stack));\n      }\n\n      return buf.join('');\n    }\n  }]);\n\n  return Filter;\n}();\n\nmodule.exports = Filter;\n//# sourceMappingURL=ansi_to_html.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Fuc2ktdG8taHRtbEAwLjcuMi9ub2RlX21vZHVsZXMvYW5zaS10by1odG1sL2xpYi9hbnNpX3RvX2h0bWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsa0RBQWtELDBDQUEwQzs7QUFFNUYsNENBQTRDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQ7O0FBRS9QLDhEQUE4RCxzRUFBc0UsOERBQThEOztBQUVsTSx5REFBeUQsaUZBQWlGLFdBQVcsd0hBQXdILGdCQUFnQixXQUFXLHlCQUF5QixTQUFTLHdCQUF3Qiw0QkFBNEIsY0FBYyxTQUFTLCtCQUErQixzQkFBc0IsV0FBVyxZQUFZLGdLQUFnSyxrREFBa0QsU0FBUyxrQkFBa0Isa0JBQWtCLG9CQUFvQixzQkFBc0IsOEJBQThCLGNBQWMsdUJBQXVCLGVBQWUsWUFBWSxvQkFBb0IsTUFBTSxpRUFBaUUsVUFBVTs7QUFFNzhCLGtEQUFrRCxnQkFBZ0IsZ0VBQWdFLHdEQUF3RCw2REFBNkQsc0RBQXNEOztBQUU3Uyx1Q0FBdUMsdURBQXVELHVDQUF1QyxTQUFTLE9BQU8sb0JBQW9COztBQUV6SyxlQUFlLG1CQUFPLENBQUMsa0dBQVU7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFD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RUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLEdBQUc7QUFDZCxhQUFhO0FBQ2I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsYUFBYSx1QkFBdUIsSUFBSTtBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEMsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvY29keWRlYXJrbGFuZC9zZW50cnl2aWJlL25vZGVfbW9kdWxlcy8ucG5wbS9hbnNpLXRvLWh0bWxAMC43LjIvbm9kZV9tb2R1bGVzL2Fuc2ktdG8taHRtbC9saWIvYW5zaV90b19odG1sLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG52YXIgZW50aXRpZXMgPSByZXF1aXJlKCdlbnRpdGllcycpO1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGZnOiAnI0ZGRicsXG4gIGJnOiAnIzAwMCcsXG4gIG5ld2xpbmU6IGZhbHNlLFxuICBlc2NhcGVYTUw6IGZhbHNlLFxuICBzdHJlYW06IGZhbHNlLFxuICBjb2xvcnM6IGdldERlZmF1bHRDb2xvcnMoKVxufTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdENvbG9ycygpIHtcbiAgdmFyIGNvbG9ycyA9IHtcbiAgICAwOiAnIzAwMCcsXG4gICAgMTogJyNBMDAnLFxuICAgIDI6ICcjMEEwJyxcbiAgICAzOiAnI0E1MCcsXG4gICAgNDogJyMwMEEnLFxuICAgIDU6ICcjQTBBJyxcbiAgICA2OiAnIzBBQScsXG4gICAgNzogJyNBQUEnLFxuICAgIDg6ICcjNTU1JyxcbiAgICA5OiAnI0Y1NScsXG4gICAgMTA6ICcjNUY1JyxcbiAgICAxMTogJyNGRjUnLFxuICAgIDEyOiAnIzU1RicsXG4gICAgMTM6ICcjRjVGJyxcbiAgICAxNDogJyM1RkYnLFxuICAgIDE1OiAnI0ZGRidcbiAgfTtcbiAgcmFuZ2UoMCwgNSkuZm9yRWFjaChmdW5jdGlvbiAocmVkKSB7XG4gICAgcmFuZ2UoMCwgNSkuZm9yRWFjaChmdW5jdGlvbiAoZ3JlZW4pIHtcbiAgICAgIHJhbmdlKDAsIDUpLmZvckVhY2goZnVuY3Rpb24gKGJsdWUpIHtcbiAgICAgICAgcmV0dXJuIHNldFN0eWxlQ29sb3IocmVkLCBncmVlbiwgYmx1ZSwgY29sb3JzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgcmFuZ2UoMCwgMjMpLmZvckVhY2goZnVuY3Rpb24gKGdyYXkpIHtcbiAgICB2YXIgYyA9IGdyYXkgKyAyMzI7XG4gICAgdmFyIGwgPSB0b0hleFN0cmluZyhncmF5ICogMTAgKyA4KTtcbiAgICBjb2xvcnNbY10gPSAnIycgKyBsICsgbCArIGw7XG4gIH0pO1xuICByZXR1cm4gY29sb3JzO1xufVxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gcmVkXG4gKiBAcGFyYW0ge251bWJlcn0gZ3JlZW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBibHVlXG4gKiBAcGFyYW0ge29iamVjdH0gY29sb3JzXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRTdHlsZUNvbG9yKHJlZCwgZ3JlZW4sIGJsdWUsIGNvbG9ycykge1xuICB2YXIgYyA9IDE2ICsgcmVkICogMzYgKyBncmVlbiAqIDYgKyBibHVlO1xuICB2YXIgciA9IHJlZCA+IDAgPyByZWQgKiA0MCArIDU1IDogMDtcbiAgdmFyIGcgPSBncmVlbiA+IDAgPyBncmVlbiAqIDQwICsgNTUgOiAwO1xuICB2YXIgYiA9IGJsdWUgPiAwID8gYmx1ZSAqIDQwICsgNTUgOiAwO1xuICBjb2xvcnNbY10gPSB0b0NvbG9ySGV4U3RyaW5nKFtyLCBnLCBiXSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGZyb20gYSBudW1iZXIgbGlrZSAxNSB0byBhIGhleCBzdHJpbmcgbGlrZSAnRidcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiB0b0hleFN0cmluZyhudW0pIHtcbiAgdmFyIHN0ciA9IG51bS50b1N0cmluZygxNik7XG5cbiAgd2hpbGUgKHN0ci5sZW5ndGggPCAyKSB7XG4gICAgc3RyID0gJzAnICsgc3RyO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cbi8qKlxuICogQ29udmVydHMgZnJvbSBhbiBhcnJheSBvZiBudW1iZXJzIGxpa2UgWzE1LCAxNSwgMTVdIHRvIGEgaGV4IHN0cmluZyBsaWtlICdGRkYnXG4gKiBAcGFyYW0ge1tyZWQsIGdyZWVuLCBibHVlXX0gcmVmXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gdG9Db2xvckhleFN0cmluZyhyZWYpIHtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocmVmKSxcbiAgICAgIF9zdGVwO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciByID0gX3N0ZXAudmFsdWU7XG4gICAgICByZXN1bHRzLnB1c2godG9IZXhTdHJpbmcocikpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG5cbiAgcmV0dXJuICcjJyArIHJlc3VsdHMuam9pbignJyk7XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5cbiAqIEBwYXJhbSB7Kn0gZGF0YVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlT3V0cHV0KHN0YWNrLCB0b2tlbiwgZGF0YSwgb3B0aW9ucykge1xuICB2YXIgcmVzdWx0O1xuXG4gIGlmICh0b2tlbiA9PT0gJ3RleHQnKSB7XG4gICAgcmVzdWx0ID0gcHVzaFRleHQoZGF0YSwgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAodG9rZW4gPT09ICdkaXNwbGF5Jykge1xuICAgIHJlc3VsdCA9IGhhbmRsZURpc3BsYXkoc3RhY2ssIGRhdGEsIG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKHRva2VuID09PSAneHRlcm0yNTZGb3JlZ3JvdW5kJykge1xuICAgIHJlc3VsdCA9IHB1c2hGb3JlZ3JvdW5kQ29sb3Ioc3RhY2ssIG9wdGlvbnMuY29sb3JzW2RhdGFdKTtcbiAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJ3h0ZXJtMjU2QmFja2dyb3VuZCcpIHtcbiAgICByZXN1bHQgPSBwdXNoQmFja2dyb3VuZENvbG9yKHN0YWNrLCBvcHRpb25zLmNvbG9yc1tkYXRhXSk7XG4gIH0gZWxzZSBpZiAodG9rZW4gPT09ICdyZ2InKSB7XG4gICAgcmVzdWx0ID0gaGFuZGxlUmdiKHN0YWNrLCBkYXRhKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YVxuICogQHJldHVybnMgeyp9XG4gKi9cblxuXG5mdW5jdGlvbiBoYW5kbGVSZ2Ioc3RhY2ssIGRhdGEpIHtcbiAgZGF0YSA9IGRhdGEuc3Vic3RyaW5nKDIpLnNsaWNlKDAsIC0xKTtcbiAgdmFyIG9wZXJhdGlvbiA9ICtkYXRhLnN1YnN0cigwLCAyKTtcbiAgdmFyIGNvbG9yID0gZGF0YS5zdWJzdHJpbmcoNSkuc3BsaXQoJzsnKTtcbiAgdmFyIHJnYiA9IGNvbG9yLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gKCcwJyArIE51bWJlcih2YWx1ZSkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTIpO1xuICB9KS5qb2luKCcnKTtcbiAgcmV0dXJuIHB1c2hTdHlsZShzdGFjaywgKG9wZXJhdGlvbiA9PT0gMzggPyAnY29sb3I6IycgOiAnYmFja2dyb3VuZC1jb2xvcjojJykgKyByZ2IpO1xufVxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fSBzdGFja1xuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGhhbmRsZURpc3BsYXkoc3RhY2ssIGNvZGUsIG9wdGlvbnMpIHtcbiAgY29kZSA9IHBhcnNlSW50KGNvZGUsIDEwKTtcbiAgdmFyIGNvZGVNYXAgPSB7XG4gICAgJy0xJzogZnVuY3Rpb24gXygpIHtcbiAgICAgIHJldHVybiAnPGJyLz4nO1xuICAgIH0sXG4gICAgMDogZnVuY3Rpb24gXygpIHtcbiAgICAgIHJldHVybiBzdGFjay5sZW5ndGggJiYgcmVzZXRTdHlsZXMoc3RhY2spO1xuICAgIH0sXG4gICAgMTogZnVuY3Rpb24gXygpIHtcbiAgICAgIHJldHVybiBwdXNoVGFnKHN0YWNrLCAnYicpO1xuICAgIH0sXG4gICAgMzogZnVuY3Rpb24gXygpIHtcbiAgICAgIHJldHVybiBwdXNoVGFnKHN0YWNrLCAnaScpO1xuICAgIH0sXG4gICAgNDogZnVuY3Rpb24gXygpIHtcbiAgICAgIHJldHVybiBwdXNoVGFnKHN0YWNrLCAndScpO1xuICAgIH0sXG4gICAgODogZnVuY3Rpb24gXygpIHtcbiAgICAgIHJldHVybiBwdXNoU3R5bGUoc3RhY2ssICdkaXNwbGF5Om5vbmUnKTtcbiAgICB9LFxuICAgIDk6IGZ1bmN0aW9uIF8oKSB7XG4gICAgICByZXR1cm4gcHVzaFRhZyhzdGFjaywgJ3N0cmlrZScpO1xuICAgIH0sXG4gICAgMjI6IGZ1bmN0aW9uIF8oKSB7XG4gICAgICByZXR1cm4gcHVzaFN0eWxlKHN0YWNrLCAnZm9udC13ZWlnaHQ6bm9ybWFsO3RleHQtZGVjb3JhdGlvbjpub25lO2ZvbnQtc3R5bGU6bm9ybWFsJyk7XG4gICAgfSxcbiAgICAyMzogZnVuY3Rpb24gXygpIHtcbiAgICAgIHJldHVybiBjbG9zZVRhZyhzdGFjaywgJ2knKTtcbiAgICB9LFxuICAgIDI0OiBmdW5jdGlvbiBfKCkge1xuICAgICAgcmV0dXJuIGNsb3NlVGFnKHN0YWNrLCAndScpO1xuICAgIH0sXG4gICAgMzk6IGZ1bmN0aW9uIF8oKSB7XG4gICAgICByZXR1cm4gcHVzaEZvcmVncm91bmRDb2xvcihzdGFjaywgb3B0aW9ucy5mZyk7XG4gICAgfSxcbiAgICA0OTogZnVuY3Rpb24gXygpIHtcbiAgICAgIHJldHVybiBwdXNoQmFja2dyb3VuZENvbG9yKHN0YWNrLCBvcHRpb25zLmJnKTtcbiAgICB9LFxuICAgIDUzOiBmdW5jdGlvbiBfKCkge1xuICAgICAgcmV0dXJuIHB1c2hTdHlsZShzdGFjaywgJ3RleHQtZGVjb3JhdGlvbjpvdmVybGluZScpO1xuICAgIH1cbiAgfTtcbiAgdmFyIHJlc3VsdDtcblxuICBpZiAoY29kZU1hcFtjb2RlXSkge1xuICAgIHJlc3VsdCA9IGNvZGVNYXBbY29kZV0oKTtcbiAgfSBlbHNlIGlmICg0IDwgY29kZSAmJiBjb2RlIDwgNykge1xuICAgIHJlc3VsdCA9IHB1c2hUYWcoc3RhY2ssICdibGluaycpO1xuICB9IGVsc2UgaWYgKDI5IDwgY29kZSAmJiBjb2RlIDwgMzgpIHtcbiAgICByZXN1bHQgPSBwdXNoRm9yZWdyb3VuZENvbG9yKHN0YWNrLCBvcHRpb25zLmNvbG9yc1tjb2RlIC0gMzBdKTtcbiAgfSBlbHNlIGlmICgzOSA8IGNvZGUgJiYgY29kZSA8IDQ4KSB7XG4gICAgcmVzdWx0ID0gcHVzaEJhY2tncm91bmRDb2xvcihzdGFjaywgb3B0aW9ucy5jb2xvcnNbY29kZSAtIDQwXSk7XG4gIH0gZWxzZSBpZiAoODkgPCBjb2RlICYmIGNvZGUgPCA5OCkge1xuICAgIHJlc3VsdCA9IHB1c2hGb3JlZ3JvdW5kQ29sb3Ioc3RhY2ssIG9wdGlvbnMuY29sb3JzWzggKyAoY29kZSAtIDkwKV0pO1xuICB9IGVsc2UgaWYgKDk5IDwgY29kZSAmJiBjb2RlIDwgMTA4KSB7XG4gICAgcmVzdWx0ID0gcHVzaEJhY2tncm91bmRDb2xvcihzdGFjaywgb3B0aW9ucy5jb2xvcnNbOCArIChjb2RlIC0gMTAwKV0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ2xlYXIgYWxsIHRoZSBzdHlsZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiByZXNldFN0eWxlcyhzdGFjaykge1xuICB2YXIgc3RhY2tDbG9uZSA9IHN0YWNrLnNsaWNlKDApO1xuICBzdGFjay5sZW5ndGggPSAwO1xuICByZXR1cm4gc3RhY2tDbG9uZS5yZXZlcnNlKCkubWFwKGZ1bmN0aW9uICh0YWcpIHtcbiAgICByZXR1cm4gJzwvJyArIHRhZyArICc+JztcbiAgfSkuam9pbignJyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbnVtYmVycyByYW5naW5nIGZyb20gbG93IHRvIGhpZ2hcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAZXhhbXBsZSByYW5nZSgzLCA3KTsgLy8gY3JlYXRlcyBbMywgNCwgNSwgNiwgN11cbiAqL1xuXG5cbmZ1bmN0aW9uIHJhbmdlKGxvdywgaGlnaCkge1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gIGZvciAodmFyIGogPSBsb3c7IGogPD0gaGlnaDsgaisrKSB7XG4gICAgcmVzdWx0cy5wdXNoKGopO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG4vKipcbiAqIFJldHVybnMgYSBuZXcgZnVuY3Rpb24gdGhhdCBpcyB0cnVlIGlmIHZhbHVlIGlzIE5PVCB0aGUgc2FtZSBjYXRlZ29yeVxuICogQHBhcmFtIHtzdHJpbmd9IGNhdGVnb3J5XG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gKi9cblxuXG5mdW5jdGlvbiBub3RDYXRlZ29yeShjYXRlZ29yeSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gKGNhdGVnb3J5ID09PSBudWxsIHx8IGUuY2F0ZWdvcnkgIT09IGNhdGVnb3J5KSAmJiBjYXRlZ29yeSAhPT0gJ2FsbCc7XG4gIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGEgY29kZSBpbnRvIGFuIGFuc2kgdG9rZW4gdHlwZVxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBjYXRlZ29yeUZvckNvZGUoY29kZSkge1xuICBjb2RlID0gcGFyc2VJbnQoY29kZSwgMTApO1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcblxuICBpZiAoY29kZSA9PT0gMCkge1xuICAgIHJlc3VsdCA9ICdhbGwnO1xuICB9IGVsc2UgaWYgKGNvZGUgPT09IDEpIHtcbiAgICByZXN1bHQgPSAnYm9sZCc7XG4gIH0gZWxzZSBpZiAoMiA8IGNvZGUgJiYgY29kZSA8IDUpIHtcbiAgICByZXN1bHQgPSAndW5kZXJsaW5lJztcbiAgfSBlbHNlIGlmICg0IDwgY29kZSAmJiBjb2RlIDwgNykge1xuICAgIHJlc3VsdCA9ICdibGluayc7XG4gIH0gZWxzZSBpZiAoY29kZSA9PT0gOCkge1xuICAgIHJlc3VsdCA9ICdoaWRlJztcbiAgfSBlbHNlIGlmIChjb2RlID09PSA5KSB7XG4gICAgcmVzdWx0ID0gJ3N0cmlrZSc7XG4gIH0gZWxzZSBpZiAoMjkgPCBjb2RlICYmIGNvZGUgPCAzOCB8fCBjb2RlID09PSAzOSB8fCA4OSA8IGNvZGUgJiYgY29kZSA8IDk4KSB7XG4gICAgcmVzdWx0ID0gJ2ZvcmVncm91bmQtY29sb3InO1xuICB9IGVsc2UgaWYgKDM5IDwgY29kZSAmJiBjb2RlIDwgNDggfHwgY29kZSA9PT0gNDkgfHwgOTkgPCBjb2RlICYmIGNvZGUgPCAxMDgpIHtcbiAgICByZXN1bHQgPSAnYmFja2dyb3VuZC1jb2xvcic7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBwdXNoVGV4dCh0ZXh0LCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmVzY2FwZVhNTCkge1xuICAgIHJldHVybiBlbnRpdGllcy5lbmNvZGVYTUwodGV4dCk7XG4gIH1cblxuICByZXR1cm4gdGV4dDtcbn1cbi8qKlxuICogQHBhcmFtIHtBcnJheX0gc3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3R5bGU9JyddXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gcHVzaFRhZyhzdGFjaywgdGFnLCBzdHlsZSkge1xuICBpZiAoIXN0eWxlKSB7XG4gICAgc3R5bGUgPSAnJztcbiAgfVxuXG4gIHN0YWNrLnB1c2godGFnKTtcbiAgcmV0dXJuIFwiPFwiLmNvbmNhdCh0YWcpLmNvbmNhdChzdHlsZSA/IFwiIHN0eWxlPVxcXCJcIi5jb25jYXQoc3R5bGUsIFwiXFxcIlwiKSA6ICcnLCBcIj5cIik7XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBwdXNoU3R5bGUoc3RhY2ssIHN0eWxlKSB7XG4gIHJldHVybiBwdXNoVGFnKHN0YWNrLCAnc3BhbicsIHN0eWxlKTtcbn1cblxuZnVuY3Rpb24gcHVzaEZvcmVncm91bmRDb2xvcihzdGFjaywgY29sb3IpIHtcbiAgcmV0dXJuIHB1c2hUYWcoc3RhY2ssICdzcGFuJywgJ2NvbG9yOicgKyBjb2xvcik7XG59XG5cbmZ1bmN0aW9uIHB1c2hCYWNrZ3JvdW5kQ29sb3Ioc3RhY2ssIGNvbG9yKSB7XG4gIHJldHVybiBwdXNoVGFnKHN0YWNrLCAnc3BhbicsICdiYWNrZ3JvdW5kLWNvbG9yOicgKyBjb2xvcik7XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBjbG9zZVRhZyhzdGFjaywgc3R5bGUpIHtcbiAgdmFyIGxhc3Q7XG5cbiAgaWYgKHN0YWNrLnNsaWNlKC0xKVswXSA9PT0gc3R5bGUpIHtcbiAgICBsYXN0ID0gc3RhY2sucG9wKCk7XG4gIH1cblxuICBpZiAobGFzdCkge1xuICAgIHJldHVybiAnPC8nICsgc3R5bGUgKyAnPic7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0FycmF5fVxuICovXG5cblxuZnVuY3Rpb24gdG9rZW5pemUodGV4dCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIGFuc2lNYXRjaCA9IGZhbHNlO1xuICB2YXIgYW5zaUhhbmRsZXIgPSAzO1xuXG4gIGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVYdGVybTI1NkZvcmVncm91bmQobSwgZzEpIHtcbiAgICBjYWxsYmFjaygneHRlcm0yNTZGb3JlZ3JvdW5kJywgZzEpO1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVh0ZXJtMjU2QmFja2dyb3VuZChtLCBnMSkge1xuICAgIGNhbGxiYWNrKCd4dGVybTI1NkJhY2tncm91bmQnLCBnMSk7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV3bGluZShtKSB7XG4gICAgaWYgKG9wdGlvbnMubmV3bGluZSkge1xuICAgICAgY2FsbGJhY2soJ2Rpc3BsYXknLCAtMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKCd0ZXh0JywgbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgZnVuY3Rpb24gYW5zaU1lc3MobSwgZzEpIHtcbiAgICBhbnNpTWF0Y2ggPSB0cnVlO1xuXG4gICAgaWYgKGcxLnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGcxID0gJzAnO1xuICAgIH1cblxuICAgIGcxID0gZzEudHJpbVJpZ2h0KCc7Jykuc3BsaXQoJzsnKTtcblxuICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZzEpLFxuICAgICAgICBfc3RlcDI7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGcgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgIGNhbGxiYWNrKCdkaXNwbGF5JywgZyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhbFRleHQobSkge1xuICAgIGNhbGxiYWNrKCd0ZXh0JywgbSk7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgZnVuY3Rpb24gcmdiKG0pIHtcbiAgICBjYWxsYmFjaygncmdiJywgbSk7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIC8qIGVzbGludCBuby1jb250cm9sLXJlZ2V4OjAgKi9cblxuXG4gIHZhciB0b2tlbnMgPSBbe1xuICAgIHBhdHRlcm46IC9eXFx4MDgrLyxcbiAgICBzdWI6IHJlbW92ZVxuICB9LCB7XG4gICAgcGF0dGVybjogL15cXHgxYlxcW1swMTJdP0svLFxuICAgIHN1YjogcmVtb3ZlXG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvXlxceDFiXFxbXFwoQi8sXG4gICAgc3ViOiByZW1vdmVcbiAgfSwge1xuICAgIHBhdHRlcm46IC9eXFx4MWJcXFtbMzRdODsyO1xcZCs7XFxkKztcXGQrbS8sXG4gICAgc3ViOiByZ2JcbiAgfSwge1xuICAgIHBhdHRlcm46IC9eXFx4MWJcXFszODs1OyhcXGQrKW0vLFxuICAgIHN1YjogcmVtb3ZlWHRlcm0yNTZGb3JlZ3JvdW5kXG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvXlxceDFiXFxbNDg7NTsoXFxkKyltLyxcbiAgICBzdWI6IHJlbW92ZVh0ZXJtMjU2QmFja2dyb3VuZFxuICB9LCB7XG4gICAgcGF0dGVybjogL15cXG4vLFxuICAgIHN1YjogbmV3bGluZVxuICB9LCB7XG4gICAgcGF0dGVybjogL15cXHIrXFxuLyxcbiAgICBzdWI6IG5ld2xpbmVcbiAgfSwge1xuICAgIHBhdHRlcm46IC9eXFxyLyxcbiAgICBzdWI6IG5ld2xpbmVcbiAgfSwge1xuICAgIHBhdHRlcm46IC9eXFx4MWJcXFsoKD86XFxkezEsM307PykrfCltLyxcbiAgICBzdWI6IGFuc2lNZXNzXG4gIH0sIHtcbiAgICAvLyBDU0kgbiBKXG4gICAgLy8gRUQgLSBFcmFzZSBpbiBEaXNwbGF5IENsZWFycyBwYXJ0IG9mIHRoZSBzY3JlZW4uXG4gICAgLy8gSWYgbiBpcyAwIChvciBtaXNzaW5nKSwgY2xlYXIgZnJvbSBjdXJzb3IgdG8gZW5kIG9mIHNjcmVlbi5cbiAgICAvLyBJZiBuIGlzIDEsIGNsZWFyIGZyb20gY3Vyc29yIHRvIGJlZ2lubmluZyBvZiB0aGUgc2NyZWVuLlxuICAgIC8vIElmIG4gaXMgMiwgY2xlYXIgZW50aXJlIHNjcmVlbiAoYW5kIG1vdmVzIGN1cnNvciB0byB1cHBlciBsZWZ0IG9uIERPUyBBTlNJLlNZUykuXG4gICAgLy8gSWYgbiBpcyAzLCBjbGVhciBlbnRpcmUgc2NyZWVuIGFuZCBkZWxldGUgYWxsIGxpbmVzIHNhdmVkIGluIHRoZSBzY3JvbGxiYWNrIGJ1ZmZlclxuICAgIC8vICAgKHRoaXMgZmVhdHVyZSB3YXMgYWRkZWQgZm9yIHh0ZXJtIGFuZCBpcyBzdXBwb3J0ZWQgYnkgb3RoZXIgdGVybWluYWwgYXBwbGljYXRpb25zKS5cbiAgICBwYXR0ZXJuOiAvXlxceDFiXFxbXFxkP0ovLFxuICAgIHN1YjogcmVtb3ZlXG4gIH0sIHtcbiAgICAvLyBDU0kgbiA7IG0gZlxuICAgIC8vIEhWUCAtIEhvcml6b250YWwgVmVydGljYWwgUG9zaXRpb24gU2FtZSBhcyBDVVBcbiAgICBwYXR0ZXJuOiAvXlxceDFiXFxbXFxkezAsM307XFxkezAsM31mLyxcbiAgICBzdWI6IHJlbW92ZVxuICB9LCB7XG4gICAgLy8gY2F0Y2gtYWxsIGZvciBDU0kgc2VxdWVuY2VzP1xuICAgIHBhdHRlcm46IC9eXFx4MWJcXFs/W1xcZDtdezAsM30vLFxuICAgIHN1YjogcmVtb3ZlXG4gIH0sIHtcbiAgICAvKipcbiAgICAgKiBleHRyYWN0cyByZWFsIHRleHQgLSBub3QgY29udGFpbmluZzpcbiAgICAgKiAtIGBcXHgxYicgLSBFU0MgLSBlc2NhcGUgKEFzY2lpIDI3KVxuICAgICAqIC0gJ1xceDA4JyAtIEJTIC0gYmFja3NwYWNlIChBc2NpaSA4KVxuICAgICAqIC0gYFxcbmAgLSBOZXdsaW5lIC0gbGluZWZlZWQgKExGKSAoYXNjaWkgMTApXG4gICAgICogLSBgXFxyYCAtIFdpbmRvd3MgQ2FycmlhZ2UgUmV0dXJuIChDUilcbiAgICAgKi9cbiAgICBwYXR0ZXJuOiAvXigoW15cXHgxYlxceDA4XFxyXFxuXSkrKS8sXG4gICAgc3ViOiByZWFsVGV4dFxuICB9XTtcblxuICBmdW5jdGlvbiBwcm9jZXNzKGhhbmRsZXIsIGkpIHtcbiAgICBpZiAoaSA+IGFuc2lIYW5kbGVyICYmIGFuc2lNYXRjaCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFuc2lNYXRjaCA9IGZhbHNlO1xuICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoaGFuZGxlci5wYXR0ZXJuLCBoYW5kbGVyLnN1Yik7XG4gIH1cblxuICB2YXIgcmVzdWx0czEgPSBbXTtcbiAgdmFyIF90ZXh0ID0gdGV4dCxcbiAgICAgIGxlbmd0aCA9IF90ZXh0Lmxlbmd0aDtcblxuICBvdXRlcjogd2hpbGUgKGxlbmd0aCA+IDApIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbyA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IG8gPCBsZW47IGkgPSArK28pIHtcbiAgICAgIHZhciBoYW5kbGVyID0gdG9rZW5zW2ldO1xuICAgICAgcHJvY2VzcyhoYW5kbGVyLCBpKTtcblxuICAgICAgaWYgKHRleHQubGVuZ3RoICE9PSBsZW5ndGgpIHtcbiAgICAgICAgLy8gV2UgbWF0Y2hlZCBhIHRva2VuIGFuZCByZW1vdmVkIGl0IGZyb20gdGhlIHRleHQuIFdlIG5lZWQgdG9cbiAgICAgICAgLy8gc3RhcnQgbWF0Y2hpbmcgKmFsbCogdG9rZW5zIGFnYWluc3QgdGhlIG5ldyB0ZXh0LlxuICAgICAgICBsZW5ndGggPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRleHQubGVuZ3RoID09PSBsZW5ndGgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJlc3VsdHMxLnB1c2goMCk7XG4gICAgbGVuZ3RoID0gdGV4dC5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0czE7XG59XG4vKipcbiAqIElmIHN0cmVhbWluZywgdGhlbiB0aGUgc3RhY2sgaXMgXCJzdGlja3lcIlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHN0aWNreVN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5cbiAqIEBwYXJhbSB7Kn0gZGF0YVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5cblxuZnVuY3Rpb24gdXBkYXRlU3RpY2t5U3RhY2soc3RpY2t5U3RhY2ssIHRva2VuLCBkYXRhKSB7XG4gIGlmICh0b2tlbiAhPT0gJ3RleHQnKSB7XG4gICAgc3RpY2t5U3RhY2sgPSBzdGlja3lTdGFjay5maWx0ZXIobm90Q2F0ZWdvcnkoY2F0ZWdvcnlGb3JDb2RlKGRhdGEpKSk7XG4gICAgc3RpY2t5U3RhY2sucHVzaCh7XG4gICAgICB0b2tlbjogdG9rZW4sXG4gICAgICBkYXRhOiBkYXRhLFxuICAgICAgY2F0ZWdvcnk6IGNhdGVnb3J5Rm9yQ29kZShkYXRhKVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHN0aWNreVN0YWNrO1xufVxuXG52YXIgRmlsdGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy5mZyBUaGUgZGVmYXVsdCBmb3JlZ3JvdW5kIGNvbG9yIHVzZWQgd2hlbiByZXNldCBjb2xvciBjb2RlcyBhcmUgZW5jb3VudGVyZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy5iZyBUaGUgZGVmYXVsdCBiYWNrZ3JvdW5kIGNvbG9yIHVzZWQgd2hlbiByZXNldCBjb2xvciBjb2RlcyBhcmUgZW5jb3VudGVyZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdGlvbnMubmV3bGluZSBDb252ZXJ0IG5ld2xpbmUgY2hhcmFjdGVycyB0byBgPGJyLz5gLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRpb25zLmVzY2FwZVhNTCBHZW5lcmF0ZSBIVE1ML1hNTCBlbnRpdGllcy5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0aW9ucy5zdHJlYW0gU2F2ZSBzdHlsZSBzdGF0ZSBhY3Jvc3MgaW52b2NhdGlvbnMgb2YgYHRvSHRtbCgpYC5cbiAgICogQHBhcmFtIHsoc3RyaW5nW10gfCB7W2NvZGU6IG51bWJlcl06IHN0cmluZ30pPX0gb3B0aW9ucy5jb2xvcnMgQ2FuIG92ZXJyaWRlIHNwZWNpZmljIGNvbG9ycyBvciB0aGUgZW50aXJlIEFOU0kgcGFsZXR0ZS5cbiAgICovXG4gIGZ1bmN0aW9uIEZpbHRlcihvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZpbHRlcik7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmIChvcHRpb25zLmNvbG9ycykge1xuICAgICAgb3B0aW9ucy5jb2xvcnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cy5jb2xvcnMsIG9wdGlvbnMuY29sb3JzKTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgdGhpcy5zdGFjayA9IFtdO1xuICAgIHRoaXMuc3RpY2t5U3RhY2sgPSBbXTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXX0gaW5wdXRcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRmlsdGVyLCBbe1xuICAgIGtleTogXCJ0b0h0bWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9IdG1sKGlucHV0KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpbnB1dCA9IHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgPyBbaW5wdXRdIDogaW5wdXQ7XG4gICAgICB2YXIgc3RhY2sgPSB0aGlzLnN0YWNrLFxuICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgYnVmID0gW107XG4gICAgICB0aGlzLnN0aWNreVN0YWNrLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IGdlbmVyYXRlT3V0cHV0KHN0YWNrLCBlbGVtZW50LnRva2VuLCBlbGVtZW50LmRhdGEsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICBidWYucHVzaChvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRva2VuaXplKGlucHV0LmpvaW4oJycpLCBvcHRpb25zLCBmdW5jdGlvbiAodG9rZW4sIGRhdGEpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IGdlbmVyYXRlT3V0cHV0KHN0YWNrLCB0b2tlbiwgZGF0YSwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgIGJ1Zi5wdXNoKG91dHB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5zdHJlYW0pIHtcbiAgICAgICAgICBfdGhpcy5zdGlja3lTdGFjayA9IHVwZGF0ZVN0aWNreVN0YWNrKF90aGlzLnN0aWNreVN0YWNrLCB0b2tlbiwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIGJ1Zi5wdXNoKHJlc2V0U3R5bGVzKHN0YWNrKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBidWYuam9pbignJyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZpbHRlcjtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGaWx0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbnNpX3RvX2h0bWwuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/ansi-to-html@0.7.2/node_modules/ansi-to-html/lib/ansi_to_html.js\n");

/***/ })

};
;